(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("Hammer"), require("Desmos"), require("Chart"));
	else if(typeof define === 'function' && define.amd)
		define("GeoPlot", ["Hammer", "Desmos", "Chart"], factory);
	else if(typeof exports === 'object')
		exports["GeoPlot"] = factory(require("Hammer"), require("Desmos"), require("Chart"));
	else
		root["GeoPlot"] = factory(root["Hammer"], root["Desmos"], root["Chart"]);
})(self, function(__WEBPACK_EXTERNAL_MODULE__4396__, __WEBPACK_EXTERNAL_MODULE__1431__, __WEBPACK_EXTERNAL_MODULE__2370__) {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 554:
/***/ (() => {

__defineTemplate("ActionBar", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).class("context-mode", m => m.selectionManager && m.selectionManager.isActive)
      .beginChild("ul").set("class","nav main")
         .if(m => m.icon != null, t3 => t3
            .beginChild("li").set("class","icon").template("Icon", m => m.icon).endChild()
         )
         .if(m => m.mainAction == 'menu', t3 => t3
            .beginChild("li").set("class","main-action menu").on("click", m => m.showNavigationMenu()).behavoir("ripple")
               .beginChild("i").set("class","icon fas fa-bars").endChild()
            .endChild()
         )
         .if(m => m.mainAction == 'back', t3 => t3
            .beginChild("li").set("class","main-action back").on("click", m => m.back()).behavoir("ripple")
               .beginChild("i").set("class","icon fas fa-chevron-left").endChild()
            .endChild()
         )
         .if(m => m.content != null, t3 => t3
            .beginChild("li").set("class","main-content").content(m => m.content).endChild()
         , t3 => t3
            .if(m => m.title != null, t4 => t4
               .beginChild("li").set("class","main-content title").text(m => m.title).endChild()
            )
         )
         .foreach(m => m.actions, t3 => t3
            .beginChild("li").set("class","action-item").class(m => m.name).content(m => m).endChild()
         )
      .endChild()
      .beginChild("ul").set("class","nav context")
         .beginChild("li").set("class","main-action close").on("click", m => m.selectionManager ? m.selectionManager.close() : null).behavoir("ripple")
            .beginChild("i").set("class","icon fas fa-times").endChild()
         .endChild()
         .if(m => m.selectionManager != null, t3 => t3
            .beginChild("li").set("class","title").text(m => m.selectionManager.selectionText).endChild()
            .foreach(m => m.selectionManager.actions, t4 => t4
               .beginChild("li").set("class","action-item").class(m => m.name).content(m => m).endChild()
            )
         )
      .endChild()
   .endChild()
   .content(m => m.navigationMenu)
});

/***/ }),

/***/ 1179:
/***/ (() => {

__defineTemplate("ActionIcon", t => { t
   .beginChild("button").set("type","button").set("class","action button-text").set("tooltip",m => m.tooltip).on("click", m => m.executeAsync()).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).behavoir("ripple").template("Icon", m => m.content).endChild()
});
__defineTemplate("ActionLink", t => { t
   .beginChild("button").set("type","button").set("class","action button-text").on("click", m => m.executeAsync()).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).behavoir("ripple").content(m => m.content).endChild()
});
__defineTemplate("ActionButton", t => { t
   .beginChild("button").set("type","button").set("class","action button").on("click", m => m.executeAsync()).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).behavoir("ripple").content(m => m.content).endChild()
});

/***/ }),

/***/ 6574:
/***/ (() => {

__defineTemplate("Attach", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).behavoir("attach").endChild()
});

/***/ }),

/***/ 245:
/***/ (() => {

__defineTemplate("DefaultCheckBox", t => { t
   .beginChild("label")
      .beginChild("input").set("type","checkbox").value(m => m.editValue).focus(m => m.hasFocus).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).endChild()
      .beginChild("span").text(m => m.label).endChild()
   .endChild()
});
__defineTemplate("Switch", t => { t
   .beginChild("div").set("class","switch").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).class("selected", m => m.editValue)
      .beginChild("div").set("class","checkbox-container")
         .beginChild("div").set("class","unselected-half").on("click", m => m.editValue = false).endChild()
         .beginChild("div").set("class","selected-half").on("click", m => m.editValue = true).endChild()
         .beginChild("div").set("class","switch-button").endChild()
      .endChild()
      .if(m => m.label != null, t2 => t2
         .beginChild("label").text(m => m.label).endChild()
      )
   .endChild()
});
__defineTemplate("CheckBox", t => { t
   .beginChild("div").set("class","checkbox").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).on("click", m => m.toggle()).class("selected", m => m.editValue)
      .beginChild("div").set("class","checkbox-container")
         .beginChild("i").set("class","fas fa-check").endChild()
      .endChild()
      .if(m => m.label != null, t2 => t2
         .beginChild("label").text(m => m.label).endChild()
      )
   .endChild()
});

/***/ }),

/***/ 1066:
/***/ (() => {

__defineTemplate("BottomSheet", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).class(m => m.status).behavoir("attach")
      .if(m => m.isShowOpener, t2 => t2
         .beginChild("button").set("type","button").set("class","opener button-text").on("click", m => m.toggle())
            .beginChild("i").set("class","fas fa-caret-up").endChild()
         .endChild()
      )
      .content(m => m.content).endChild()
});

/***/ }),

/***/ 4117:
/***/ (() => {

__defineTemplate("ConsoleView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible)
      .beginChild("div").set("class","toolbar")
         .beginChild("button").set("type","button").on("click", m => m.hide()).text("Hide").endChild()
         .beginChild("button").set("type","button").on("click", m => m.clear()).text("Clear").endChild()
      .endChild()
      .beginChild("div").set("class","body")
         .foreach(m => m.root.items, t3 => t3
            .content(m => m)
         )
      .endChild()
   .endChild()
});
__defineTemplate("ConsoleMessageView", t => { t
   .beginChild("div").set("class","console-item console-message").class(m => m.type)
      .if(m => m.content != null, t2 => t2
         .foreach(m => m.content, t3 => t3
            .beginChild("span").text(m => m).endChild()
         )
      )
   .endChild()
});
__defineTemplate("ConsoleGroupView", t => { t
   .beginChild("div").set("class","console-item console-group")
      .beginChild("header").template("ConsoleMessageView", m => m).endChild()
      .beginChild("section")
         .foreach(m => m.items, t3 => t3
            .content(m => m)
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 1906:
/***/ (() => {

__defineTemplate("Container", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).behavoir("attach")
      .if(m => m.title != null, t2 => t2
         .beginChild("header")
            .beginChild("label").text(m => m.title).endChild()
         .endChild()
      )
      .beginChild("div").set("class","content").class("expanded", m => m.isExpanded).class("expandible", m => m.canExpand)
         .if(m => m.canExpand, t3 => t3
            .beginChild("div").set("class","content-wrapper").content(m => m.content, true).endChild()
            .if(m => m.isOverflow, t4 => t4
               .beginChild("a").set("class","base-button expand-collapse").on("click", m => m.toggleExpand()).visible(m => m.canExpand).behavoir("ripple")
                  .beginChild("i").set("class","fas fa-angle-down").endChild()
               .endChild()
            )
         , t3 => t3
            .content(m => m.content, true)
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 751:
/***/ (() => {

__defineTemplate("ContentView", t => { t
   .content(m => m.content)
});
__defineTemplate("ContentViewNested", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).class(m => m.status).behavoir("attach").content(m => m.content).endChild()
});

/***/ }),

/***/ 926:
/***/ (() => {

__defineTemplate("ContextMenu", t => { t
   .beginChild("ul").class(m => m.className)
      .foreach(m => m.actions, t2 => t2
         .beginChild("li").content(m => m).endChild()
      )
   .endChild()
});

/***/ }),

/***/ 939:
/***/ (() => {

__defineTemplate("CounterView", t => { t
   .beginChild("div").set("class","action").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .beginChild("label").set("class","title").text(m => m.title).endChild()
      .beginChild("span").set("class","value").text(m => m.content).endChild()
   .endChild()
});

/***/ }),

/***/ 3325:
/***/ (() => {

__defineTemplate("DateEditor", t => { t
   .beginChild("input").behavoir("attach").set("type","date").value(m => m.editValue).focus(m => m.hasFocus).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).set("placeholder",m => m.placeholder).endChild()
});

/***/ }),

/***/ 7501:
/***/ (() => {

__defineTemplate("DateEditorCombo", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .beginChild("select").set("class","input-element day").value(m => m.selectedDay)
         .beginChild("option").set("value","").text(m => WebApp.Format.text('day-label')).endChild()
         .foreach(m => m.days, t3 => t3
            .beginChild("option").set("value",m => m).text(m => m).endChild()
         )
      .endChild()
      .beginChild("select").set("class","input-element month").value(m => m.selectedMonth)
         .beginChild("option").set("value","").text(m => WebApp.Format.text('month-label')).endChild()
         .foreach(m => m.months, t3 => t3
            .beginChild("option").set("value",m => m.number).text(m => m.name).endChild()
         )
      .endChild()
      .beginChild("select").set("class","input-element year").value(m => m.selectedYear)
         .beginChild("option").set("value","").text(m => WebApp.Format.text('year-label')).endChild()
         .foreach(m => m.years, t3 => t3
            .beginChild("option").set("value",m => m).text(m => m).endChild()
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 4212:
/***/ (() => {

__defineTemplate("Drawer", t => { t
   .beginChild("div").set("class","drawer-container").class(m => m.status)
      .beginChild("div").set("class","drawer").behavoir("gesture")
         .if(m => m.header != null, t3 => t3
            .beginChild("header").content(m => m.header).endChild()
         )
         .foreach(m => m.groups, t3 => t3
            .if(m => m.actions.count > 0, t4 => t4
               .beginChild("section")
                  .if(m => m.label != null, t6 => t6
                     .beginChild("label").text(m => m.label).endChild()
                  )
                  .beginChild("div").set("class","menu")
                     .foreach(m => m.actions, t7 => t7
                        .content(m => m)
                     )
                  .endChild()
               .endChild()
            )
         )
      .endChild()
      .behavoir("attach").endChild()
});

/***/ }),

/***/ 3006:
/***/ (() => {

__defineTemplate("FileUploadView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).class(m => m.status)
      .beginChild("div").set("class","content")
         .beginChild("div").set("class","header")
            .beginChild("button").set("type","button").set("class","select button-text").on("click", m => m.select()).text(m => m.text).set("enabled",m => m.status == 'selected' || m.status== 'empty').endChild()
         .endChild()
         .beginChild("div").set("class","progress")
            .beginChild("div").set("class","bar").style("width", m => (m.progress * 100) + '%').endChild()
            .beginChild("div").set("class","text").text(m => m.progressText).endChild()
         .endChild()
      .endChild()
   .endChild()
});

/***/ }),

/***/ 9337:
/***/ (() => {

__defineTemplate("HeadedContentView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible)
      .beginChild("header").content(m => m.header).endChild()
      .beginChild("div").set("class","content").content(m => m.content).endChild()
   .endChild()
});

/***/ }),

/***/ 8679:
/***/ (() => {

__defineTemplate("Html", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).html(m => m.content).endChild()
});
__defineTemplate("HtmlNode", t => { t
   .appendChild(t.model.content)
});

/***/ }),

/***/ 3123:
/***/ (() => {

__defineTemplate("Icon", t => { t
   .if(m => m != null, t1 => t1
      .if(m => m.substr(0, 4) == 'fas ' || m.substr(0, 4) == 'fab ' || m.substr(0, 4) == 'far ' || m.substr(0, 4) == 'fal '|| m.substr(0, 4) == 'fad ', t2 => t2
         .beginChild("i").set("class","icon").class(m => m).endChild()
      , t2 => t2
         .beginChild("img").set("class","icon").set("src",m => m).endChild()
      )
   )
});

/***/ }),

/***/ 5700:
/***/ (() => {

__defineTemplate("IconTextView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).class(m => m.status)
      .if(m => m.icon != null, t2 => t2
         .template("Icon", m => m.icon)
      )
      .if(m => m.text != null, t2 => t2
         .beginChild("span").set("class","text").text(m => m.text).endChild()
      )
      .if(m => m.badge != null, t2 => t2
         .beginChild("span").set("class","badge").text(m => m.badge).endChild()
      )
   .endChild()
});
__defineTemplate("IconTextViewInline", t => { t
   .class(m => m.status)
   .if(m => m.icon != null, t1 => t1
      .template("Icon", m => m.icon)
   )
   .if(m => m.text != null, t1 => t1
      .beginChild("span").set("class","text").text(m => m.text).endChild()
   )
   .if(m => m.badge != null, t1 => t1
      .beginChild("span").set("class","badge").text(m => m.badge).endChild()
   )
});

/***/ }),

/***/ 7598:
/***/ (() => {

__defineTemplate("ImageInline", t => { t
   .beginChild("img").class(m => m.className).set("src",m => m.content).visible(m => m.visible).set("enabled",m => m.enabled).endChild()
});
__defineTemplate("Image", t => { t
   .beginChild("div").set("class","image-container").visible(m => m.visible).set("enabled",m => m.enabled)
      .beginChild("img").class(m => m.className).set("src",m => m.content).endChild()
   .endChild()
});

/***/ }),

/***/ 3999:
/***/ (() => {

__defineTemplate("ItemSelectorList", t => { t
   .beginChild("div").set("class","items-view").class(m => m.className)
      .foreach(m => m.items, t2 => t2
         .content(m => m)
      )
   .endChild()
});

/***/ }),

/***/ 7641:
/***/ (() => {

__defineTemplate("ItemView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).class(m => m.status).class("activable", m => m.canOpen).class("compact", m => !(m.mainActions && m.mainActions.length > 0))
      .if(m => m.mainActions && m.mainActions.length > 0, t2 => t2
         .beginChild("div").set("class","body-container").template("ItemViewBody", m => m).endChild()
         .beginChild("div").set("class","main-actions")
            .foreach(m => m.mainActions, t4 => t4
               .content(m => m)
            )
         .endChild()
      , t2 => t2
         .template("ItemViewBody", m => m)
      )
   .endChild()
});
__defineTemplate("ItemViewBody", t => { t
   .class("with-menu", m => m.hasActions)
   .beginChild("div").on("click", m => m.open()).class("body", m => true)
      .if(m => m.content.count <= 1, t2 => t2
         .content(m => m.content.get(0), true), t2 => t2
         .foreach(m => m.content, t3 => t3
            .content(m => m)
         )
      )
   .endChild()
   .if(m => m.canOpen, t1 => t1
      .beginChild("i").set("class","open-icon fas fa-angle-right").endChild()
   )
   .if(m => m.hasActions, t1 => t1
      .beginChild("a").set("class","menu").on("click", m => m.showMenu())
         .beginChild("i").set("class","fas fa-ellipsis-v").endChild()
      .endChild()
   )
});

/***/ }),

/***/ 4581:
/***/ (() => {

__defineTemplate("ItemsEditor", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .foreach(m => m.content, t2 => t2
         .beginChild("div").set("class","list-item").content(m => m, true).endChild()
      )
      .if(m => m.canAdd, t2 => t2
         .beginChild("div").set("class","add-item").content(m => m.addAction).endChild()
      )
   .endChild()
});

/***/ }),

/***/ 6506:
/***/ (() => {

__defineTemplate("ItemsView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .foreach(m => m.content, t2 => t2
         .content(m => m)
      )
      .if(m => m.content.count == 0 && m.emptyView != null, t2 => t2
         .content(m => m.emptyView)
      )
   .endChild()
});
__defineTemplate("ItemsViewWrapped", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .beginChild("div").set("class","wrapper")
         .foreach(m => m.content, t3 => t3
            .content(m => m)
         )
         .if(m => m.content.count == 0 && m.emptyView != null, t3 => t3
            .content(m => m.emptyView)
         )
      .endChild()
   .endChild()
});
__defineTemplate("ItemsViewForm", t => { t
   .beginChild("form").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .foreach(m => m.content, t2 => t2
         .content(m => m)
      )
      .if(m => m.content.count == 0 && m.emptyView != null, t2 => t2
         .content(m => m.emptyView)
      )
   .endChild()
});

/***/ }),

/***/ 6228:
/***/ (() => {

__defineTemplate("ListView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).behavoir("scroll-check").class(m => m.status)
      .foreach(m => m.header, t2 => t2
         .beginChild("header").set("class","header-item").content(m => m).endChild()
         .if(m => WebApp.injectProxy(m, "$parent", t.model).showSeparator, t3 => t3
            .beginChild("div").set("class","separator").endChild()
         )
      )
      .if(m => m.content.count == 0 && m.emptyView != null && m.status == 'loaded', t2 => t2
         .content(m => m.emptyView)
      )
      .foreach(m => m.content, t2 => t2
         .beginChild("div").set("class","list-item").content(m => m, true).endChild()
         .if(m => WebApp.injectProxy(m, "$parent", t.model).showSeparator, t3 => t3
            .beginChild("div").set("class","separator").endChild()
         )
      )
      .foreach(m => m.footer, t2 => t2
         .beginChild("footer").set("class","footer-item").content(m => m).endChild()
         .if(m => WebApp.injectProxy(m, "$parent", t.model).showSeparator, t3 => t3
            .beginChild("div").set("class","separator").endChild()
         )
      )
      .beginChild("div").set("class","loading-item")
         .beginChild("i").set("class","fas fa-circle-notch fa-spin fa-3x fa-fw").endChild()
      .endChild()
   .endChild()
});
__defineTemplate("ListViewInline", t => { t
   .beginChild("div").set("class","list-view-inline").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).behavoir("scroll-check").class(m => m.status)
      .if(m => m.header.count > 0, t2 => t2
         .foreach(m => m.header, t3 => t3
            .content(m => m)
         )
         .if(m => m.showSeparator, t3 => t3
            .beginChild("div").set("class","separator").endChild()
         )
      )
      .if(m => m.content.count == 0 && m.emptyView != null && m.status == 'loaded', t2 => t2
         .content(m => m.emptyView)
      )
      .foreach(m => m.content, t2 => t2
         .content(m => m)
         .if(m => WebApp.injectProxy(m, "$parent", t.model).showSeparator, t3 => t3
            .beginChild("div").set("class","separator").endChild()
         )
      )
      .if(m => m.footer.count > 0, t2 => t2
         .foreach(m => m.footer, t3 => t3
            .content(m => m)
         )
         .if(m => m.showSeparator, t3 => t3
            .beginChild("div").set("class","separator").endChild()
         )
      )
      .beginChild("div").set("class","loading-item")
         .beginChild("i").set("class","fas fa-circle-notch fa-spin fa-3x fa-fw").endChild()
      .endChild()
   .endChild()
});

/***/ }),

/***/ 4726:
/***/ (() => {

__defineTemplate("LocationView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .beginChild("address")
         .if(m => m.content.name != null, t3 => t3
            .beginChild("label").text(m => m.content.name).endChild()
         )
         .beginChild("span").text(m => m.content.address).endChild()
      .endChild()
      .beginChild("img").set("src",m => m.map).on("click", m => m.showMap()).endChild()
   .endChild()
});

/***/ }),

/***/ 1368:
/***/ (() => {

__defineTemplate("MediaEditor", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible)
      .beginChild("div").set("class","media-container").on("click", m => m.showMenu()).content(m => m.mediaView).endChild()
      .content(m => m.fileUpload).endChild()
});

/***/ }),

/***/ 163:
/***/ (() => {

__defineTemplate("MediaView", t => { t
   .content(m => m.activeView)
});

/***/ }),

/***/ 6932:
/***/ (() => {

__defineTemplate("MessageBox", t => { t
   .beginChild("div").class(m => m.className)
      .beginChild("h5").set("class","title").text(m => m.title).endChild()
      .beginChild("div").set("class","body")
         .if(m => m.icon != null, t3 => t3
            .template("Icon", m => m.icon)
         )
         .beginChild("div").set("class","text").text(m => m.message).endChild()
      .endChild()
      .beginChild("div").set("class","actions")
         .foreach(m => m.actions, t3 => t3
            .content(m => m)
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 3356:
/***/ (() => {

__defineTemplate("MultiItemPicker", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).class(m => m.status)
      .beginChild("div").set("class","items-container")
         .beginChild("i").set("class","loading-item fas fa-circle-notch fa-spin fa-fw").endChild()
         .foreach(m => m.items, t3 => t3
            .content(m => m)
         )
      .endChild()
      .content(m => m.selectAction).endChild()
});

/***/ }),

/***/ 8958:
/***/ (() => {

__defineTemplate("NavBar", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .beginChild("nav").set("class","nav")
         .foreach(m => m.content, t3 => t3
            .beginChild("button").set("class","button-text").class(m => m.status).on("click", m => m.select()).visible(m => m.visible).behavoir("ripple").content(m => m).endChild()
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 2547:
/***/ (() => {

__defineTemplate("OperationView", t => { t
   .beginChild("div").set("class","operation-view").template("Spinner", m => m)
      .beginChild("div").set("class","text")
         .beginChild("span").text(m => m.message).endChild()
      .endChild()
   .endChild()
});

/***/ }),

/***/ 5471:
/***/ (() => {

__defineTemplate("SlidePageHost", t => { t
   .beginChild("div").set("class","slide-page-host").class(m => m.activeTransaction)
      .beginChild("div").set("class","page-container").class(m => m.pageViews[0].className).content(m => m.pageViews[0].content).endChild()
      .beginChild("div").set("class","page-container").class(m => m.pageViews[1].className).content(m => m.pageViews[1].content).endChild()
   .endChild()
});
__defineTemplate("SinglePageHost", t => { t
   .beginChild("div").set("class","single-page-host").content(m => m.current.view).endChild()
});

/***/ }),

/***/ 5142:
/***/ (() => {

__defineTemplate("PermissionRequestItemView", t => { t
   .beginChild("div").class(m => m.className)
      .beginChild("div").set("class","item-content")
         .beginChild("div").set("class","main").content(m => m.switchView).endChild()
         .beginChild("span").set("class","right bold uppercase").text(m => WebApp.Format.action('permission-why')).on("click", m => m.isShowInfo = true).class("hidden", m => m.isShowInfo).endChild()
      .endChild()
      .beginChild("div").set("class","info-message on-surface-smaller").text(m => WebApp.Format.message(m.request.description)).class("hidden", m => !m.isShowInfo).endChild()
   .endChild()
});

/***/ }),

/***/ 1556:
/***/ (() => {

__defineTemplate("PopUpContent", t => { t
   .beginChild("div").class(m => m.className)
      .beginChild("h5").set("class","title").text(m => m.title).endChild()
      .beginChild("div").set("class","body").content(m => m.contentView).endChild()
      .beginChild("div").set("class","actions")
         .foreach(m => m.actions, t3 => t3
            .content(m => m)
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 7760:
/***/ (() => {

__defineTemplate("ProgressView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).class("visible", m => m.visible)
      .beginChild("i").set("class","spinner fas fa-circle-notch fa-spin fa-3x fa-fw").endChild()
   .endChild()
});

/***/ }),

/***/ 8777:
/***/ (() => {

__defineTemplate("PropertyView", t => { t
   .beginChild("div").set("class","action").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .if(m => m.showLabel && m.label != null, t2 => t2
         .beginChild("label").set("for",m => m.editor.uid).text(m => m.label).endChild()
      )
      .if(m => m.readonly, t2 => t2
         .beginChild("div").set("class","display-value").text(m => m.editor.displayValue).endChild()
      , t2 => t2
         .content(m => m.editor)
         .if(m => m.error != null, t3 => t3
            .beginChild("span").set("class","error").text(m => m.error).endChild()
         )
      )
   .endChild()
});

/***/ }),

/***/ 7183:
/***/ (() => {

__defineTemplate("RemovableItemView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).class(m => m.status)
      .beginChild("div").set("class","content").content(m => m.content).endChild()
      .beginChild("button").set("type","button").set("class","remove button-text").set("href","#!").on("click", m => m.removeAsync())
         .beginChild("i").set("class","fas fa-times").endChild()
      .endChild()
   .endChild()
});

/***/ }),

/***/ 9857:
/***/ (() => {

__defineTemplate("SearchView", t => { t
   .if(m => m.isExpanded, t1 => t1
      .beginChild("div").set("class","search-container").class(m => m.className).visible(m => m.visible).class(m => m.status)
         .beginChild("input").set("type","text").focus(m => m.hasFocus).set("enabled",m => m.enabled).value(m => m.searchText).set("placeholder",m => m.tooltip).endChild()
         .beginChild("i").set("class","loading-item fas fa-circle-notch fa-spin fa-fw").endChild()
      .endChild()
   , t1 => t1
      .template("ActionIcon", m => m)
   )
});

/***/ }),

/***/ 3818:
/***/ (() => {

__defineTemplate("SectionEditor", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).content(m => m.navBar)
      .if(m => m.navBar.selectedItem && m.navBar.selectedItem.content && m.navBar.selectedItem.content.editor != null, t2 => t2
         .content(m => m.navBar.selectedItem.content.editor)
      )
   .endChild()
});

/***/ }),

/***/ 7575:
/***/ (() => {

__defineTemplate("SectionsView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .foreach(m => m.content, t2 => t2
         .beginChild("section")
            .beginChild("h5").set("class","header").content(m => m.header).endChild()
            .beginChild("div").set("class","content").content(m => m.content).endChild()
         .endChild()
      )
   .endChild()
});

/***/ }),

/***/ 4182:
/***/ (() => {

__defineTemplate("SelectableItemView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).on("click", m => m.toggle()).class("selected", m => m.isSelected).class("checkbox", m => true)
      .beginChild("div").set("class","checkbox-container").value(m => m.isSelected)
         .beginChild("i").set("class","fas fa-check").endChild()
      .endChild()
      .content(m => m.content).endChild()
});
__defineTemplate("SelectableItemViewText", t => { t
   .beginChild("div").class(m => m.className).on("click", m => m.toggle()).class("selected", m => m.isSelected).content(m => m.content, true).endChild()
});

/***/ }),

/***/ 6948:
/***/ (() => {

__defineTemplate("SimpleItemView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).class(m => m.status).template("Icon", m => m.icon)
      .beginChild("div").set("class","details")
         .beginChild("h6").text(m => m.text).endChild()
         .if(m => m.subText != null, t3 => t3
            .beginChild("div").set("class","sub-text").text(m => m.subText).endChild()
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 940:
/***/ (() => {

__defineTemplate("SingleItemPicker", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).class(m => m.status)
      .beginChild("div").set("class","items-container")
         .beginChild("i").set("class","loading-item fas fa-circle-notch fa-spin fa-fw").endChild()
         .content(m => m.contentView).endChild()
      .if(m => m.editValue != null, t2 => t2
         .content(m => m.clearAction)
      )
      .content(m => m.selectAction).endChild()
});

/***/ }),

/***/ 9307:
/***/ (() => {

__defineTemplate("SelectEditor", t => { t
   .beginChild("select").set("class","input-element").focus(m => m.hasFocus).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).behavoir("attach")
      .if(m => m.placeholder != null, t2 => t2
         .beginChild("option").set("value","").text(m => m.placeholder).endChild()
      )
      .foreach(m => m.items, t2 => t2
         .beginChild("option").text(m => m.content).endChild()
      )
   .endChild()
});
__defineTemplate("SingleItemSelectorButton", t => { t
   .beginChild("button").set("type","button").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).on("click", m => m.selectAsync())
      .beginChild("span").text(m => m.selectedItemText).endChild()
      .beginChild("i").set("class","fas fa-caret-down").endChild()
   .endChild()
});

/***/ }),

/***/ 1977:
/***/ (() => {

__defineTemplate("SnackBar", t => { t
   .beginChild("div").set("class","snack-bar-container").class(m => m.status)
      .beginChild("div").class(m => m.className)
         .beginChild("div").set("class","content").on("click", m => m.hide(null)).content(m => m.content).endChild()
         .if(m => m.action != null, t3 => t3
            .content(m => m.action)
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 5395:
/***/ (() => {

__defineTemplate("Spinner", t => { t
   .beginChild("div").set("class","spinner-container")
      .beginChild("i").set("class","spinner fas fa-circle-notch fa-spin fa-3x fa-fw").endChild()
   .endChild()
});

/***/ }),

/***/ 8350:
/***/ (() => {

__defineTemplate("TextEditor", t => { t
   .beginChild("input").behavoir("attach").set("class","input-element").set("type","text").value(m => m.editValue).focus(m => m.hasFocus).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).set("placeholder",m => m.placeholder).set("maxlength",m => m.maxLength).endChild()
});
__defineTemplate("NumberEditor", t => { t
   .beginChild("input").behavoir("attach").set("class","input-element").set("inputmode","decimal").set("type","text").set("pattern",m => WebApp.Format.text('decimal-input')).set("lang",m => WebApp.App.language).value(m => m.editValue).focus(m => m.hasFocus).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).set("placeholder",m => m.placeholder).endChild()
});
__defineTemplate("TimeEditor", t => { t
   .beginChild("input").behavoir("attach").set("class","input-element").set("type","time").set("lang",m => WebApp.App.language).value(m => m.editValue).focus(m => m.hasFocus).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).set("placeholder",m => m.placeholder).set("min","00:00").set("max","24:00").endChild()
});
__defineTemplate("PasswordEditor", t => { t
   .beginChild("input").behavoir("attach").set("class","input-element").set("type","password").value(m => m.editValue).focus(m => m.hasFocus).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).set("placeholder",m => m.placeholder).set("maxlength",m => m.maxLength).endChild()
});
__defineTemplate("TextEditorMultiLine", t => { t
   .beginChild("textarea").set("class","input-element").behavoir("attach").value(m => m.editValue).focus(m => m.hasFocus).class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("id",m => m.uid).set("rows",m => m.lineCount).set("placeholder",m => m.placeholder).set("maxlength",m => m.maxLength).endChild()
});

/***/ }),

/***/ 1814:
/***/ (() => {

__defineTemplate("TextContent", t => { t
   .beginChild("span").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).text(m => m.content).endChild()
});
__defineTemplate("TextView", t => { t
   .beginChild("span").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).text(m => m.text).endChild()
});
__defineTemplate("Text", t => { t
   .beginChild("span").text(m => m).endChild()
});

/***/ }),

/***/ 5972:
/***/ (() => {

__defineTemplate("ToastContainer", t => { t
   .foreach(m => m, t1 => t1
      .content(m => m)
   )
});
__defineTemplate("Toast", t => { t
   .beginChild("div").class(m => m.className)
      .if(m => m.icon != null, t2 => t2
         .template("Icon", m => m.icon)
      )
      .beginChild("span").text(m => m.message).endChild()
      .class("visible", m => m.visible).endChild()
});

/***/ }),

/***/ 8164:
/***/ (() => {

__defineTemplate("VideoView", t => { t
   .beginChild("div").set("class","video-container").visible(m => m.visible).set("enabled",m => m.enabled).class(m => m.className)
      .beginChild("video").set("src",m => m.content).behavoir("attach").endChild()
   .endChild()
});
__defineTemplate("VideoViewInline", t => { t
   .beginChild("video").visible(m => m.visible).set("enabled",m => m.enabled).class(m => m.className).set("src",m => m.content).behavoir("attach").endChild()
});

/***/ }),

/***/ 5996:
/***/ (() => {

__defineTemplate("WebView", t => { t
   .beginChild("iframe").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled).set("src",m => m.content).behavoir("attach").endChild()
});

/***/ }),

/***/ 9095:
/***/ (() => {

__defineTemplate("WizardView", t => { t
   .beginChild("div").class(m => m.className).visible(m => m.visible).set("enabled",m => m.enabled)
      .beginChild("div").set("class","wizard-steps")
         .beginChild("ul")
            .foreach(m => m.content, t4 => t4
               .beginChild("li").text(m => m.index + 1).class("active", m => m.isActive).class("done", m => m.index < WebApp.injectProxy(m, "$parent", t.model).currentStepIndex).endChild()
            )
         .endChild()
      .endChild()
      .if(m => m.currentView != null, t2 => t2
         .beginChild("h5").set("class","title").text(m => m.currentView.title).endChild()
         .if(m => m.currentView.coverImage != null, t3 => t3
            .beginChild("div").set("class","cover-image").template("Icon", m => m.currentView.coverImage).endChild()
         )
         .content(m => m.currentView)
      )
      .beginChild("div").set("class","actions").content(m => m.actions.next).content(m => m.actions.finish)
         .foreach(m => m.currentView.actions, t3 => t3
            .content(m => m)
         )
      .endChild()
   .endChild()
});

/***/ }),

/***/ 417:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gV": () => (/* binding */ App),
/* harmony export */   "K9": () => (/* binding */ Services),
/* harmony export */   "eH": () => (/* binding */ runAsync),
/* harmony export */   "N9": () => (/* binding */ install)
/* harmony export */ });
var App = null;
const Services = {};
/****************************************/
async function runAsync(app, args, action) {
    if (typeof app == "function")
        App = new app();
    else
        App = app;
    window.addEventListener("load", async () => {
        await App.runAsync(args);
        action();
    });
}
/****************************************/
async function install(workerUri, versionUri, isDebug) {
    const curVer = localStorage.getItem("AppVer");
    let newVer;
    try {
        newVer = JSON.parse(await (await fetch(versionUri)).text());
    }
    catch (_a) {
        newVer = curVer;
        console.warn("Error fetching version");
    }
    if ("serviceWorker" in navigator) {
        const curReg = await navigator.serviceWorker.getRegistration(workerUri);
        if (curVer != newVer || !curReg) {
            if (curReg)
                await curReg.update();
            else
                await navigator.serviceWorker.register(workerUri);
        }
    }
    ;
    localStorage.setItem("AppVer", newVer);
    if (curVer && curVer != newVer && !isDebug)
        document.location.reload();
}


/***/ }),

/***/ 1141:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "E": () => (/* binding */ Format)
/* harmony export */ });
/* harmony import */ var _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9714);

var Format;
(function (Format) {
    function join(separator, ...args) {
        let result = "";
        for (const arg of args) {
            if (!arg)
                continue;
            if (result.length > 0)
                result += separator;
            result += _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(arg);
        }
        return result;
    }
    Format.join = join;
    /****************************************/
    function text(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args });
    }
    Format.text = text;
    /****************************************/
    function title(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args, usage: _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .StringUsage.Title */ .Fq.Title });
    }
    Format.title = title;
    /****************************************/
    function action(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args, usage: _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .StringUsage.Action */ .Fq.Action });
    }
    Format.action = action;
    /****************************************/
    function tooltip(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args, usage: _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .StringUsage.Tooltip */ .Fq.Tooltip });
    }
    Format.tooltip = tooltip;
    /****************************************/
    function message(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args, usage: _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .StringUsage.Message */ .Fq.Message });
    }
    Format.message = message;
    /****************************************/
    function numberWithCommas(value, separator = ".") {
        if (value == null || value == undefined)
            return "";
        return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, separator);
    }
    Format.numberWithCommas = numberWithCommas;
    /****************************************/
    function currency(value, symbol = "€. ") {
        if (value == null || value == undefined)
            return "";
        return symbol + " " + value.toFixed(2);
    }
    Format.currency = currency;
    /****************************************/
    function replaceArgs(value, args) {
        if (!value)
            return;
        let map;
        if (typeof (args) != "function")
            map = key => args[key];
        else
            map = args;
        let state = 0;
        let result = "";
        let curName = "";
        for (let i = 0; i < value.length; i++) {
            const c = value[i];
            switch (state) {
                case 0:
                    if (c == "{") {
                        curName = "";
                        state = 1;
                    }
                    else
                        result += c;
                    break;
                case 1:
                    if (c == "}" || c == ":" || c == "=") {
                        state = 0;
                        if (args)
                            result += map(curName);
                        if (c == ":" || c == "=")
                            state = 2;
                        else
                            state = 0;
                    }
                    else if (c != "?")
                        curName += c;
                    break;
                case 2:
                    if (c == "}")
                        state = 0;
                    break;
            }
        }
        return result;
    }
    Format.replaceArgs = replaceArgs;
    /****************************************/
    function replaceArgs2(value, args) {
        if (!value)
            return value;
        let map;
        if (typeof (args) != "function")
            map = key => args[key];
        else
            map = args;
        let result = "";
        let paramName = "";
        let state = 0;
        for (let i = 0; i < value.length; i++) {
            const c = value[i];
            switch (state) {
                case 0:
                    if (c == '$')
                        state = 1;
                    else
                        result += c;
                    break;
                case 1:
                    if (c == '(') {
                        state = 2;
                        paramName = "";
                    }
                    else {
                        result += "$" + c;
                        state = 0;
                    }
                    break;
                case 2:
                    if (c == ')') {
                        const paramValue = map(paramName);
                        result += JSON.stringify(paramValue);
                        state = 0;
                    }
                    else
                        paramName += c;
                    break;
            }
        }
        return result;
    }
    Format.replaceArgs2 = replaceArgs2;
    /****************************************/
    function linkify(value) {
        if (!value)
            return "";
        let replacedText, replacePattern1, replacePattern2, replacePattern3;
        //URLs starting with http://, https://, or ftp://
        replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
        replacedText = value.replace(replacePattern1, '<a href="$1" target="_blank">$1</a>');
        //URLs starting with "www." (without // before it, or it'd re-link the ones done above).
        replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
        replacedText = replacedText.replace(replacePattern2, '$1<a href="http://$2" target="_blank">$2</a>');
        //Change email addresses to mailto:: links.
        replacePattern3 = /(([a-zA-Z0-9\-\_\.])+@[a-zA-Z\_]+?(\.[a-zA-Z]{2,6})+)/gim;
        replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>');
        return replacedText;
    }
    Format.linkify = linkify;
})(Format || (Format = {}));


/***/ }),

/***/ 7933:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": () => (/* binding */ Http)
/* harmony export */ });
/* harmony import */ var _Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(417);

var Http;
(function (Http) {
    function getStringAsync(url) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "GET",
        });
    }
    Http.getStringAsync = getStringAsync;
    /****************************************/
    function postStringAsync(url, data) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "POST",
            data: data,
        });
    }
    Http.postStringAsync = postStringAsync;
    /****************************************/
    function getJsonAsync(url) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "GET",
            responseType: "application/json",
        });
    }
    Http.getJsonAsync = getJsonAsync;
    /****************************************/
    function postJsonAsync(url, data) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "POST",
            responseType: "application/json",
            data: data,
        });
    }
    Http.postJsonAsync = postJsonAsync;
    /****************************************/
    function postBinaryAsync(url, data, onProgress) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "POST",
            responseType: "application/json",
            dataType: "application/octet-stream",
            data: data,
            onProgress: onProgress
        });
    }
    Http.postBinaryAsync = postBinaryAsync;
})(Http || (Http = {}));


/***/ }),

/***/ 4044:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nq": () => (/* binding */ isList),
/* harmony export */   "_p": () => (/* binding */ isCloneable),
/* harmony export */   "Ex": () => (/* binding */ isObservableList),
/* harmony export */   "HD": () => (/* binding */ isString),
/* harmony export */   "mf": () => (/* binding */ isFunction),
/* harmony export */   "Kn": () => (/* binding */ isObject),
/* harmony export */   "bU": () => (/* binding */ isStateManager),
/* harmony export */   "kQ": () => (/* binding */ isGuid)
/* harmony export */ });
const GUID_REGEXP = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
function isList(obj) {
    return obj && typeof obj == "object" && "add" in obj && "get" in obj && "count" in obj;
}
/****************************************/
function isCloneable(obj) {
    return obj && typeof obj == "object" && "clone" in obj && typeof obj["clone"] == "function";
}
/****************************************/
function isObservableList(obj) {
    return isList(obj) && "subscribe" in obj;
}
/****************************************/
function isString(obj) {
    return typeof obj == "string";
}
/****************************************/
function isFunction(obj) {
    return typeof obj == "function";
}
/****************************************/
function isObject(obj) {
    return typeof obj == "object";
}
/****************************************/
function isStateManager(obj) {
    return obj && typeof obj == "object" && "setState" in obj && "getState" in obj;
}
function isGuid(obj) {
    return GUID_REGEXP.test(obj === null || obj === void 0 ? void 0 : obj.toString());
}


/***/ }),

/***/ 8883:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": () => (/* binding */ Uri)
/* harmony export */ });
/* harmony import */ var _Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(417);

var Uri;
(function (Uri) {
    var _relativeSegment;
    var _absoluteSegment;
    /****************************************/
    function absolute(uri) {
        if (uri.substr(0, 2) == "./" || uri.substr(0, 2) == "~/")
            return getAbsoluteSegment(document.URL) + _Global__WEBPACK_IMPORTED_MODULE_0__/* .App.baseUrl.substr */ .gV.baseUrl.substr(1) + uri.substr(2);
        else if (uri.substr(0, 1) == "/")
            return getAbsoluteSegment(document.URL) + uri.substr(1);
        else if (isAbsolute(uri))
            return uri;
        return getRelativeSegment(document.URL) + uri.substr(1);
    }
    Uri.absolute = absolute;
    /****************************************/
    function isAbsolute(uri) {
        return uri.indexOf("://") != -1;
    }
    Uri.isAbsolute = isAbsolute;
    /****************************************/
    function getRelativeSegment(uri) {
        if (!_relativeSegment) {
            _relativeSegment = "";
            const index = uri.lastIndexOf("/");
            if (index != -1)
                _relativeSegment = uri.substr(0, index + 1);
        }
        return _relativeSegment;
    }
    Uri.getRelativeSegment = getRelativeSegment;
    /****************************************/
    function getAbsoluteSegment(uri) {
        if (!_absoluteSegment) {
            _absoluteSegment = "";
            let index = uri.indexOf("://");
            if (index != -1) {
                index = uri.indexOf("/", index + 4);
                if (index != -1)
                    _absoluteSegment = uri.substr(0, index + 1);
            }
        }
        return _absoluteSegment;
    }
    Uri.getAbsoluteSegment = getAbsoluteSegment;
})(Uri || (Uri = {}));


/***/ }),

/***/ 9001:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": () => (/* binding */ Linq),
/* harmony export */   "k": () => (/* binding */ linq)
/* harmony export */ });
/* harmony import */ var _Helpers_TypeCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4044);
/* harmony import */ var _Utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1464);


/****************************************/
class EmptyEnumerator {
    get current() {
        return undefined;
    }
    /****************************************/
    moveNext() {
        return false;
    }
    /****************************************/
    reset() {
    }
    /****************************************/
    count() {
        return 0;
    }
}
/****************************************/
class DistinctEnumerator {
    /****************************************/
    constructor(source, selector) {
        this._selector = selector;
        this._source = source;
        if (!this._selector)
            this._selector = a => a;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._current;
    }
    /****************************************/
    moveNext() {
        while (this._source.moveNext()) {
            const item = this._selector(this._source.current);
            if (this._foundItems.indexOf(item) == -1) {
                this._foundItems.push(item);
                this._current = item;
                return true;
            }
        }
        return false;
    }
    /****************************************/
    reset() {
        this._source.reset();
        this._foundItems = [];
        this._current = undefined;
    }
}
/****************************************/
class DictionaryEnumerator {
    /****************************************/
    constructor(value) {
        this._keyList = Object.getOwnPropertyNames(value);
        this._value = value;
        this.reset();
    }
    /****************************************/
    get current() {
        return {
            key: this._keyList[this._curIndex],
            value: this._value[this._keyList[this._curIndex]]
        };
    }
    /****************************************/
    moveNext() {
        this._curIndex++;
        return this._curIndex < this._keyList.length;
    }
    /****************************************/
    reset() {
        this._curIndex = -1;
    }
    /****************************************/
    first() {
        return {
            key: this._keyList[0],
            value: this._value[this._keyList[0]]
        };
    }
    /****************************************/
    last() {
        return {
            key: this._keyList[this._keyList.length - 1],
            value: this._value[this._keyList[this._keyList.length - 1]]
        };
    }
    /****************************************/
    count() {
        return this._keyList.length;
    }
}
/****************************************/
class ArrayEnumerator {
    /****************************************/
    constructor(value) {
        this._value = value;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._value[this._curIndex];
    }
    /****************************************/
    toArray() {
        return this._value;
    }
    /****************************************/
    moveNext() {
        this._curIndex++;
        return this._curIndex < this._value.length;
    }
    /****************************************/
    reset() {
        this._curIndex = -1;
    }
    /****************************************/
    first() {
        return this._value[0];
    }
    /****************************************/
    last() {
        return this._value[this._value.length - 1];
    }
    /****************************************/
    count() {
        return this._value.length;
    }
}
/****************************************/
class CollectionEnumerator {
    /****************************************/
    constructor(value) {
        this._value = value;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._value.item(this._curIndex);
    }
    /****************************************/
    moveNext() {
        this._curIndex++;
        return this._curIndex < this._value.length;
    }
    /****************************************/
    reset() {
        this._curIndex = -1;
    }
    /****************************************/
    first() {
        return this._value.item(0);
    }
    /****************************************/
    last() {
        return this._value.item(this._value.length - 1);
    }
    /****************************************/
    count() {
        return this._value.length;
    }
}
/****************************************/
class SelectManyEnumerator {
    /****************************************/
    constructor(source, selector) {
        this._selector = selector;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        var _a;
        return (_a = this._curGroup) === null || _a === void 0 ? void 0 : _a.current;
    }
    /****************************************/
    moveNext() {
        var _a;
        while (true) {
            while (!this._curGroup) {
                if (!this._source.moveNext())
                    return false;
                this._curGroup = (_a = this._selector(this._source.current, this._index)) === null || _a === void 0 ? void 0 : _a.getEnumerator();
            }
            if (this._curGroup) {
                if (!this._curGroup.moveNext())
                    this._curGroup = null;
                else {
                    this._index++;
                    return true;
                }
            }
        }
    }
    /****************************************/
    reset() {
        this._curGroup = null;
        this._index = -1;
        this._source.reset();
    }
}
/****************************************/
class SelectEnumerator {
    /****************************************/
    constructor(source, selector) {
        this._selector = selector;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._selector(this._source.current, this._index);
    }
    /****************************************/
    moveNext() {
        this._index++;
        return this._source.moveNext();
    }
    /****************************************/
    reset() {
        this._index = -1;
        this._source.reset();
    }
}
/****************************************/
class WhereEnumerator {
    /****************************************/
    constructor(source, condition) {
        this._condition = condition;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._source.current;
    }
    /****************************************/
    moveNext() {
        while (this._source.moveNext()) {
            if (this._condition(this._source.current))
                return true;
        }
        return false;
    }
    /****************************************/
    reset() {
        this._source.reset();
    }
}
/****************************************/
class SkipEnumerator {
    /****************************************/
    constructor(source, count) {
        this._count = count;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._source.current;
    }
    /****************************************/
    moveNext() {
        if (!this._skipped) {
            let elCount = 0;
            while (elCount < this._count) {
                if (!this._source.moveNext())
                    return false;
                elCount++;
            }
            this._skipped = true;
        }
        return this._source.moveNext();
    }
    /****************************************/
    reset() {
        this._source.reset();
        this._skipped = false;
    }
}
/****************************************/
class TakeEnumerator {
    /****************************************/
    constructor(source, count) {
        this._count = count;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._source.current;
    }
    /****************************************/
    moveNext() {
        if (this._taken >= this._count)
            return false;
        if (!this._source.moveNext())
            return false;
        this._taken++;
        return true;
    }
    /****************************************/
    reset() {
        this._source.reset();
        this._taken = 0;
    }
}
/****************************************/
class IteratorEnumerator {
    /****************************************/
    constructor(source) {
        this._source = source;
    }
    /****************************************/
    get current() {
        return this._current;
    }
    /****************************************/
    moveNext() {
        const result = this._source.next();
        if (result.done)
            return false;
        this._current = result.value;
        return true;
    }
    /****************************************/
    reset() {
    }
}
/****************************************/
class Linq {
    /****************************************/
    constructor(value) {
        this._enumerator = value;
    }
    /****************************************/
    selectMany(selector) {
        return linq(new SelectManyEnumerator(this._enumerator, selector));
    }
    /****************************************/
    select(selector) {
        return linq(new SelectEnumerator(this._enumerator, selector));
    }
    ofType(typeOrCheck) {
        if ("prototype" in typeOrCheck)
            return this.where(a => a instanceof typeOrCheck);
        return this.where(a => typeOrCheck(a));
    }
    /****************************************/
    where(condition) {
        return linq(new WhereEnumerator(this._enumerator, condition));
    }
    /****************************************/
    first(condition) {
        if (condition)
            return this.where(condition).first();
        if (this._enumerator.first)
            return this._enumerator.first();
        this._enumerator.reset();
        if (this._enumerator.moveNext())
            return this._enumerator.current;
    }
    /****************************************/
    last() {
        if (this._enumerator.last)
            return this._enumerator.last();
        this._enumerator.reset();
        let lastItem;
        while (this._enumerator.moveNext())
            lastItem = this._enumerator.current;
        return lastItem;
    }
    /****************************************/
    sum(selector) {
        if (selector)
            return this.select(selector).sum();
        let result = 0;
        this.foreach(a => {
            result += parseFloat(a);
        });
        return result;
    }
    /****************************************/
    min(selector) {
        if (selector)
            return this.select(selector).min();
        let result = Number.POSITIVE_INFINITY;
        this.foreach(a => {
            const number = parseFloat(a);
            if (number < result)
                result = number;
        });
        return result;
    }
    /****************************************/
    max(selector) {
        if (selector)
            return this.select(selector).max();
        let result = Number.NEGATIVE_INFINITY;
        this.foreach(a => {
            const number = parseFloat(a);
            if (number > result)
                result = number;
        });
        return result;
    }
    /****************************************/
    avg(selector) {
        if (selector)
            return this.select(selector).avg();
        let result = 0;
        let count = 0;
        this.foreach(a => {
            result += parseFloat(a);
            count++;
        });
        if (count)
            return result / count;
        return NaN;
    }
    /****************************************/
    count(condition) {
        if (condition)
            return this.where(condition).count();
        if (this._enumerator.count)
            return this._enumerator.count();
        this._enumerator.reset();
        let count = 0;
        while (this._enumerator.moveNext())
            count++;
        return count;
    }
    /****************************************/
    concat(separator, selector) {
        let result = "";
        let index = 0;
        if (!selector)
            selector = a => a.toString();
        this.foreach(a => {
            if (index > 0)
                result += separator;
            result += selector(a);
            index++;
        });
        return result;
    }
    /****************************************/
    orderBy(selector) {
        const result = this.toArray();
        result.sort((a, b) => {
            const itemA = selector(a);
            const itemB = selector(b);
            return itemA - itemB;
        });
        return linq(result);
    }
    /****************************************/
    orderByDesc(selector) {
        const result = this.toArray();
        result.sort((a, b) => {
            const itemA = selector(a);
            const itemB = selector(b);
            return itemB - itemA;
        });
        return linq(result);
    }
    /****************************************/
    distinct(selector) {
        return linq(new DistinctEnumerator(this._enumerator, selector));
    }
    groupBy(key, comparer) {
        const result = [];
        if (!comparer)
            comparer = (a, b) => a == b;
        if (typeof key == "function") {
            const keySelector = key;
            this.foreach(item => {
                const itemKey = keySelector(item);
                let groupItem = linq(result).first(a => comparer(a.key, itemKey));
                if (!groupItem) {
                    groupItem = {
                        key: itemKey,
                        values: linq(new ArrayEnumerator([]))
                    };
                    result.push(groupItem);
                }
                groupItem.values._enumerator.toArray().push(item);
            });
        }
        return linq(result);
    }
    /****************************************/
    indexOf(condition) {
        let index = 0;
        this._enumerator.reset();
        while (this._enumerator.moveNext()) {
            if (condition(this._enumerator.current))
                return index;
            index++;
        }
    }
    /****************************************/
    foreach(action) {
        this._enumerator.reset();
        let index = 0;
        while (this._enumerator.moveNext()) {
            action(this._enumerator.current, index);
            index++;
        }
        return this;
    }
    /****************************************/
    async foreachAsync(action, chunkSize = 1) {
        this._enumerator.reset();
        let index = 0;
        while (this._enumerator.moveNext()) {
            await action(this._enumerator.current, index);
            index++;
        }
        return this;
    }
    /****************************************/
    any(condition) {
        if (!condition)
            return this._enumerator.moveNext();
        return this.where(condition).any();
    }
    /****************************************/
    contains(item, comparer) {
        if (!comparer)
            comparer = (a, b) => a == b;
        this._enumerator.reset();
        while (this._enumerator.moveNext())
            if (comparer(this._enumerator.current, item))
                return true;
        return false;
    }
    /****************************************/
    all(condition) {
        return !this.where(a => !condition(a)).any();
    }
    /****************************************/
    take(count) {
        return linq(new TakeEnumerator(this._enumerator, count));
    }
    /****************************************/
    skip(count) {
        return linq(new SkipEnumerator(this._enumerator, count));
    }
    /****************************************/
    replace(condition, newItem) {
        if (!(this._enumerator instanceof ArrayEnumerator))
            throw "Invalid enumerator, expected array";
        const items = this._enumerator.toArray();
        for (let i = 0; i < items.length; i++) {
            if (condition(items[i]))
                items[i] == newItem;
        }
    }
    /****************************************/
    toGenerator() {
        function* generator(self) {
            self._enumerator.reset();
            while (self._enumerator.moveNext())
                yield self._enumerator.current;
        }
        return generator(this);
    }
    /****************************************/
    async toArrayAsync(chunkSize = 1) {
        if (this._enumerator.toArray)
            return this._enumerator.toArray();
        const array = [];
        let index = 0;
        for (const item of this.toGenerator()) {
            array.push(item);
            if (index % chunkSize == 0)
                await (0,_Utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_0__/* .delayAsync */ .$)(0);
            index++;
        }
        return array;
    }
    /****************************************/
    toArray() {
        if (this._enumerator.toArray)
            return this._enumerator.toArray();
        const result = [];
        this.foreach(a => result.push(a));
        return result;
    }
    toDictionary(keySelector, valueSelector) {
        if (!valueSelector)
            valueSelector = a => a;
        const result = {};
        this.foreach(a => result[keySelector(a)] = valueSelector(a));
        return result;
    }
    /****************************************/
    getEnumerator() {
        return this._enumerator;
    }
    /****************************************/
    [Symbol.iterator]() {
        this._enumerator.reset();
        return ({
            next: (value) => {
                const isDone = !this._enumerator.moveNext();
                return {
                    done: isDone,
                    value: this._enumerator.current
                };
            }
        });
    }
}
function linq(value) {
    let enumerator;
    if (!value)
        enumerator = new EmptyEnumerator();
    else if (Array.isArray(value))
        enumerator = new ArrayEnumerator(value);
    else if ("getEnumerator" in value)
        enumerator = value.getEnumerator();
    else if ((0,_Helpers_TypeCheck__WEBPACK_IMPORTED_MODULE_1__/* .isList */ .nq)(value))
        enumerator = new ArrayEnumerator(value.toArray());
    else if ("item" in value)
        enumerator = new CollectionEnumerator(value);
    else if ("next" in value && typeof (value["next"]) == "function")
        enumerator = new IteratorEnumerator(value);
    else if ("current" in value && "reset" in value && "moveNext" in value)
        enumerator = value;
    else
        enumerator = new DictionaryEnumerator(value);
    return new Linq(enumerator);
}


/***/ }),

/***/ 7704:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": () => (/* binding */ Strings),
/* harmony export */   "M": () => (/* binding */ StringTable)
/* harmony export */ });
var Strings;
/****************************************/
class StringTable {
    /****************************************/
    static getKey(config) {
        let key = config.language;
        if (config.sector)
            key += "|" + config.sector;
        return key;
    }
    /****************************************/
    static get(config) {
        if (!config)
            config = this._currentConfig;
        let result = StringTable._tables[this.getKey(config)];
        if (!result && config.sector)
            result = StringTable._tables[this.getKey({ language: config.language })];
        return result;
    }
    /****************************************/
    static add(value, config) {
        const key = this.getKey(config);
        const curValue = this._tables[key];
        if (!curValue)
            this._tables[key] = value;
        else {
            for (const str in value)
                curValue[str] = value[str];
        }
    }
    /****************************************/
    static get currentConfig() {
        return this._currentConfig;
    }
    /****************************************/
    static set currentConfig(value) {
        this._currentConfig = value;
        Strings = StringTable.get();
    }
}
StringTable._tables = {};


/***/ }),

/***/ 9714:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sZ": () => (/* binding */ WordNumber),
/* harmony export */   "ko": () => (/* binding */ WordGender),
/* harmony export */   "Fq": () => (/* binding */ StringUsage),
/* harmony export */   "wI": () => (/* binding */ DynamicString),
/* harmony export */   "tY": () => (/* binding */ $string)
/* harmony export */ });
/* harmony import */ var _StringTable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7704);

var WordNumber;
(function (WordNumber) {
    WordNumber[WordNumber["Singular"] = 0] = "Singular";
    WordNumber[WordNumber["Plural"] = 1] = "Plural";
})(WordNumber || (WordNumber = {}));
/****************************************/
var WordGender;
(function (WordGender) {
    WordGender[WordGender["Male"] = 0] = "Male";
    WordGender[WordGender["Female"] = 1] = "Female";
})(WordGender || (WordGender = {}));
/****************************************/
var StringUsage;
(function (StringUsage) {
    StringUsage[StringUsage["General"] = 0] = "General";
    StringUsage[StringUsage["Label"] = 1] = "Label";
    StringUsage[StringUsage["Column"] = 2] = "Column";
    StringUsage[StringUsage["Action"] = 3] = "Action";
    StringUsage[StringUsage["Message"] = 4] = "Message";
    StringUsage[StringUsage["Question"] = 5] = "Question";
    StringUsage[StringUsage["Title"] = 6] = "Title";
    StringUsage[StringUsage["Tooltip"] = 7] = "Tooltip";
})(StringUsage || (StringUsage = {}));
;
/****************************************/
class DynamicStringManager {
    format(Strings) {
        return cfg => {
            let curValue = Strings(cfg);
            if (cfg) {
                if (cfg.usage === StringUsage.Column ||
                    cfg.usage === StringUsage.Label ||
                    cfg.usage === StringUsage.Action ||
                    cfg.usage === StringUsage.Title ||
                    cfg.usage === StringUsage.Question ||
                    cfg.usage === StringUsage.Tooltip ||
                    cfg.usage === StringUsage.Message)
                    curValue = curValue.substr(0, 1).toUpperCase() + curValue.substr(1);
                if (cfg.usage === StringUsage.Label)
                    curValue += ":";
                if (cfg.usage === StringUsage.Message)
                    curValue += ".";
                if (cfg.usage === StringUsage.Question)
                    curValue += "?";
            }
            return curValue;
        };
    }
    get(name) {
        const value = _StringTable__WEBPACK_IMPORTED_MODULE_0__/* .Strings */ .e[name];
        if (typeof value == "string")
            return DynamicString.simple(value);
        return value;
    }
    getValue(value, usageOrConfig) {
        if (typeof value == "function") {
            let cfg;
            if (usageOrConfig) {
                if (StringUsage[usageOrConfig])
                    cfg = {
                        usage: usageOrConfig
                    };
                else
                    cfg = usageOrConfig;
            }
            return value(cfg);
        }
        else {
            if (value && _StringTable__WEBPACK_IMPORTED_MODULE_0__/* .Strings */ .e && value in _StringTable__WEBPACK_IMPORTED_MODULE_0__/* .Strings */ .e)
                return this.getValue(this.get(value), usageOrConfig);
        }
        return value;
    }
    /****************************************/
    complex(value) {
        return DynamicString.format(cfg => {
            let state = 0;
            let result = "";
            let curName = "";
            let curNameParams = null;
            let curNameParamsDeep = 0;
            if (!cfg)
                cfg = {};
            if (!cfg.gender && cfg.params) {
                //Forzo la valutazione dei parametri x estrarre il genere
                cfg.params.forEach(a => {
                    if (typeof a === "function")
                        a(Object.assign(Object.assign({}, cfg), { params: [] }));
                });
            }
            for (let i = 0; i < value.length; i++) {
                const c = value[i];
                switch (state) {
                    case 0:
                        if (c == "{") {
                            curName = "";
                            curNameParams = null;
                            state = 1;
                        }
                        else
                            result += c;
                        break;
                    case 1:
                        if (c == "}") {
                            state = 3;
                            i--;
                            break;
                        }
                        else if (c == ":") {
                            curNameParams = "";
                            curNameParamsDeep = 0;
                            state = 2;
                        }
                        else
                            curName += c;
                        break;
                    case 2:
                        if (c == "{")
                            curNameParamsDeep++;
                        if (c == "}") {
                            curNameParamsDeep--;
                            if (curNameParamsDeep < 0) {
                                state = 3;
                                i--;
                            }
                            else
                                curNameParams += c;
                        }
                        else
                            curNameParams += c;
                        break;
                    case 3:
                        let paramCfg;
                        if (curNameParams)
                            paramCfg = JSON.parse(curNameParams.trim());
                        else
                            paramCfg = {};
                        let flagFound = true;
                        while (flagFound) {
                            flagFound = false;
                            if (curName.startsWith("*")) {
                                paramCfg.number = WordNumber.Plural;
                                curName = curName.substr(1);
                                flagFound = true;
                            }
                            if (curName.startsWith("!")) {
                                paramCfg.useArticle = true;
                                curName = curName.substr(1);
                                flagFound = true;
                            }
                            if (curName.startsWith(".")) {
                                paramCfg.useArticleInd = true;
                                curName = curName.substr(1);
                                flagFound = true;
                            }
                        }
                        if (cfg.gender && !paramCfg.gender)
                            paramCfg.gender = cfg.gender;
                        if (cfg.cardinality && !paramCfg.cardinality)
                            paramCfg.cardinality = cfg.cardinality;
                        if (cfg.number && !paramCfg.number)
                            paramCfg.number = cfg.number;
                        if (cfg.useArticle !== undefined && paramCfg.useArticle === undefined)
                            paramCfg.useArticle = cfg.useArticle;
                        const number = parseInt(curName);
                        if (!isNaN(number)) {
                            if (cfg.params && number < cfg.params.length) {
                                const param = cfg.params[number];
                                result += this.getValue(param, paramCfg);
                            }
                        }
                        else
                            result += this.get(curName)(paramCfg);
                        if (paramCfg.gender)
                            cfg.gender = paramCfg.gender;
                        state = 0;
                        break;
                }
            }
            return result;
        });
    }
    /****************************************/
    adverb(advCfg) {
        return this.format(cfg => {
            return cfg && cfg.gender == WordGender.Female ? advCfg.female : advCfg.male;
        });
    }
    /****************************************/
    appendArticle(article, name) {
        let result = article;
        if (result.charAt(result.length - 1) != "'")
            result += " ";
        return result + name;
    }
    /****************************************/
    adjective(adjCfg) {
        return this.format(cfg => {
            const gender = cfg && cfg.gender == WordGender.Female ? adjCfg.female : adjCfg.male;
            const fullName = cfg && (cfg.number == WordNumber.Plural || cfg.cardinality > 1) ? gender.plural : gender.singular;
            if (cfg && cfg.useArticle)
                return this.appendArticle(fullName.detArticle, fullName.name);
            if (cfg && cfg.useArticleInd)
                return this.appendArticle(fullName.undetArticle, fullName.name);
            return fullName.name;
        });
    }
    /****************************************/
    noun(nameCfg) {
        return this.format(cfg => {
            if (!cfg)
                cfg = {};
            if (nameCfg.gender)
                cfg.gender = nameCfg.gender;
            const fullName = (cfg.number == WordNumber.Plural || cfg.cardinality > 1) ? nameCfg.plural : nameCfg.singular;
            if (cfg && cfg.useArticle)
                return this.appendArticle(fullName.detArticle, fullName.name);
            if (cfg && cfg.useArticleInd)
                return this.appendArticle(fullName.undetArticle, fullName.name);
            return fullName.name;
        });
    }
    /****************************************/
    map(selector) {
        return cfg => selector(_StringTable__WEBPACK_IMPORTED_MODULE_0__/* .Strings */ .e)(cfg);
    }
    /****************************************/
    simple(value) {
        return this.format(() => value);
    }
}
/****************************************/
var DynamicString = new DynamicStringManager();
function $string(name) {
    return DynamicString.get(name);
}


/***/ }),

/***/ 1464:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ delayAsync)
/* harmony export */ });
function delayAsync(milliseconds) {
    return new Promise(res => setTimeout(res, milliseconds));
}
;


/***/ }),

/***/ 2501:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "W": () => (/* binding */ ScriptLoader),
/* harmony export */   "D": () => (/* binding */ StyleLoader)
/* harmony export */ });
/* harmony import */ var _Core_Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(417);
/* harmony import */ var _Core_Helpers_Uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8883);
/* harmony import */ var _Core_Linq__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9001);



/****************************************/
class ScriptLoader {
    constructor(src) {
        this.src = _Core_Helpers_Uri__WEBPACK_IMPORTED_MODULE_1__/* .Uri.absolute */ .S.absolute(src.replace("~/", "./"));
    }
    /****************************************/
    isLoaded() {
        if (this.src.substr(this.src.length - 3) == ".ts")
            return true;
        return (0,_Core_Linq__WEBPACK_IMPORTED_MODULE_2__/* .linq */ .k)(document.scripts).any(a => a.src.toLowerCase().startsWith(this.src.toLowerCase()));
    }
    /****************************************/
    loadAsync(operation) {
        if (this.isLoaded())
            return Promise.resolve(true);
        return new Promise((resolve, reject) => {
            const curOperation = _Core_Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.operation.begin */ .K9.operation.begin({ parentOperation: operation, message: "Loading script " + this.src });
            const scriptNode = document.createElement("script");
            scriptNode.onload = () => {
                curOperation.end();
                resolve(true);
            };
            scriptNode.onerror = () => {
                curOperation.end();
                resolve(false);
            };
            scriptNode.type = "text/javascript";
            scriptNode.src = this.src;
            document.body.appendChild(scriptNode);
        });
    }
}
/****************************************/
class StyleLoader {
    constructor(src) {
        this.src = _Core_Helpers_Uri__WEBPACK_IMPORTED_MODULE_1__/* .Uri.absolute */ .S.absolute(src.replace("~/", "./"));
    }
    /****************************************/
    isLoaded() {
        return (0,_Core_Linq__WEBPACK_IMPORTED_MODULE_2__/* .linq */ .k)(document.styleSheets).any(a => a.href && a.href.toLowerCase().startsWith(this.src.toLowerCase()));
    }
    /****************************************/
    loadAsync(operation) {
        if (this.isLoaded())
            return Promise.resolve(true);
        return new Promise((resolve, reject) => {
            const curOperation = _Core_Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.operation.begin */ .K9.operation.begin({ parentOperation: operation, message: "Loading style " + this.src });
            const linkNode = document.createElement("link");
            linkNode.onload = () => {
                curOperation.end();
                resolve(true);
            };
            linkNode.onerror = () => {
                curOperation.end();
                resolve(false);
            };
            linkNode.rel = "stylesheet";
            linkNode.href = this.src;
            document.body.appendChild(linkNode);
        });
    }
}


/***/ }),

/***/ 3894:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "I": () => (/* binding */ DynamicPageManager)
/* harmony export */ });
/* harmony import */ var _Core_Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(417);
/* harmony import */ var _Core_Helpers_Format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1141);
/* harmony import */ var _Core_Helpers_Http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7933);
/* harmony import */ var _Core_Linq__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9001);
/* harmony import */ var _Helpers_Loaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2501);





/****************************************/
class DynamicPageManager {
    /****************************************/
    async createPageAsync(pageInfo) {
        const curOperation = _Core_Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.operation.begin */ .K9.operation.begin({ message: "Loading page '" + pageInfo.name + "'..." });
        const clientPage = await this.getClientPageAsync(pageInfo.name, curOperation);
        if (!clientPage.isLoded)
            await this.loadClientPageAsync(clientPage, curOperation);
        const result = eval(clientPage.action);
        let page;
        if (result instanceof Promise)
            page = await result;
        if (page != null)
            page.url = _Core_Helpers_Format__WEBPACK_IMPORTED_MODULE_1__/* .Format.replaceArgs */ .E.replaceArgs(_Core_Global__WEBPACK_IMPORTED_MODULE_0__/* .App.baseUrl */ .gV.baseUrl + clientPage.url, pageInfo.args);
        page.args = pageInfo.args;
        curOperation.end();
        return page;
    }
    /****************************************/
    async loadComponentsAsync(pageName) {
        const curOperation = _Core_Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.operation.begin */ .K9.operation.begin({ message: "Loading page '" + pageName + "'..." });
        const clientPage = await this.getClientPageAsync(pageName, curOperation);
        if (clientPage && !clientPage.isLoded)
            await this.loadClientPageAsync(clientPage, curOperation);
        curOperation.end();
    }
    /****************************************/
    async include(src) {
        const curStruct = await _Core_Helpers_Http__WEBPACK_IMPORTED_MODULE_2__/* .Http.getJsonAsync */ .e.getJsonAsync(src);
        if (curStruct) {
            if (curStruct.include) {
                for (const file of curStruct.include)
                    await this.include(file);
            }
            if (curStruct.components) {
                for (const key in curStruct.components)
                    this._struture.components[key] = curStruct.components[key];
            }
            if (curStruct.pages) {
                for (const key in curStruct.pages)
                    this._struture.pages[key] = curStruct.pages[key];
            }
        }
    }
    async loadAppStructureAsync(operation) {
        if (!this._struture) {
            this._struture = {
                components: {},
                pages: {},
            };
            await this.include("~/app.json");
        }
    }
    /****************************************/
    async loadClientPageAsync(clientPage, operation) {
        const loaders = [];
        clientPage.isLoded = true;
        if (clientPage.scripts)
            clientPage.scripts.forEach(a => loaders.push(new _Helpers_Loaders__WEBPACK_IMPORTED_MODULE_4__/* .ScriptLoader */ .W(a)));
        if (clientPage.styles)
            clientPage.styles.forEach(a => loaders.push(new _Helpers_Loaders__WEBPACK_IMPORTED_MODULE_4__/* .StyleLoader */ .D(a)));
        await Promise.all((0,_Core_Linq__WEBPACK_IMPORTED_MODULE_3__/* .linq */ .k)(loaders).select(a => a.loadAsync(operation)).toArray());
    }
    /****************************************/
    async getClientPageAsync(name, operation) {
        await this.loadAppStructureAsync(operation);
        const result = {};
        const pageInfo = this._struture.pages[name];
        result.styles = [];
        result.scripts = [];
        result.action = pageInfo.action;
        result.url = pageInfo.url;
        this.includeClientPage(result, pageInfo.include);
        return result;
    }
    /****************************************/
    includeClientPage(clientPage, include) {
        if (!include)
            return;
        if (include.components)
            include.components.forEach(a => this.includeClientPage(clientPage, this._struture.components[a].include));
        if (include.styles)
            include.styles.forEach(a => {
                if (clientPage.styles.indexOf(a) == -1)
                    clientPage.styles.push(a);
            });
        if (include.scripts)
            include.scripts.forEach(a => {
                if (clientPage.scripts.indexOf(a) == -1)
                    clientPage.scripts.push(a);
            });
    }
}


/***/ }),

/***/ 1923:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gV": () => (/* binding */ App),
/* harmony export */   "K9": () => (/* binding */ Services)
/* harmony export */ });
/* unused harmony exports runAsync, install */
var App = null;
const Services = {};
/****************************************/
async function runAsync(app, args, action) {
    if (typeof app == "function")
        App = new app();
    else
        App = app;
    window.addEventListener("load", async () => {
        await App.runAsync(args);
        action();
    });
}
/****************************************/
async function install(workerUri, versionUri, isDebug) {
    const curVer = localStorage.getItem("AppVer");
    let newVer;
    try {
        newVer = JSON.parse(await (await fetch(versionUri)).text());
    }
    catch {
        newVer = curVer;
        console.warn("Error fetching version");
    }
    if ("serviceWorker" in navigator) {
        const curReg = await navigator.serviceWorker.getRegistration(workerUri);
        if (curVer != newVer || !curReg) {
            if (curReg)
                await curReg.update();
            else
                await navigator.serviceWorker.register(workerUri);
        }
    }
    ;
    localStorage.setItem("AppVer", newVer);
    if (curVer && curVer != newVer && !isDebug)
        document.location.reload();
}


/***/ }),

/***/ 1691:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "E": () => (/* binding */ Format)
/* harmony export */ });
/* harmony import */ var _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3163);

var Format;
(function (Format) {
    function join(separator, ...args) {
        let result = "";
        for (const arg of args) {
            if (!arg)
                continue;
            if (result.length > 0)
                result += separator;
            result += _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(arg);
        }
        return result;
    }
    Format.join = join;
    /****************************************/
    function text(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args });
    }
    Format.text = text;
    /****************************************/
    function title(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args, usage: _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .StringUsage.Title */ .Fq.Title });
    }
    Format.title = title;
    /****************************************/
    function action(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args, usage: _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .StringUsage.Action */ .Fq.Action });
    }
    Format.action = action;
    /****************************************/
    function tooltip(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args, usage: _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .StringUsage.Tooltip */ .Fq.Tooltip });
    }
    Format.tooltip = tooltip;
    /****************************************/
    function message(value, ...args) {
        return _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .DynamicString.getValue */ .wI.getValue(value, { params: args, usage: _Types_DynamicString__WEBPACK_IMPORTED_MODULE_0__/* .StringUsage.Message */ .Fq.Message });
    }
    Format.message = message;
    /****************************************/
    function numberWithCommas(value, separator = ".") {
        if (value == null || value == undefined)
            return "";
        return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, separator);
    }
    Format.numberWithCommas = numberWithCommas;
    /****************************************/
    function currency(value, symbol = "€. ") {
        if (value == null || value == undefined)
            return "";
        return symbol + " " + value.toFixed(2);
    }
    Format.currency = currency;
    /****************************************/
    function replaceArgs(value, args) {
        if (!value)
            return;
        let map;
        if (typeof (args) != "function")
            map = key => args[key];
        else
            map = args;
        let state = 0;
        let result = "";
        let curName = "";
        for (let i = 0; i < value.length; i++) {
            const c = value[i];
            switch (state) {
                case 0:
                    if (c == "{") {
                        curName = "";
                        state = 1;
                    }
                    else
                        result += c;
                    break;
                case 1:
                    if (c == "}" || c == ":" || c == "=") {
                        state = 0;
                        if (args)
                            result += map(curName);
                        if (c == ":" || c == "=")
                            state = 2;
                        else
                            state = 0;
                    }
                    else if (c != "?")
                        curName += c;
                    break;
                case 2:
                    if (c == "}")
                        state = 0;
                    break;
            }
        }
        return result;
    }
    Format.replaceArgs = replaceArgs;
    /****************************************/
    function replaceArgs2(value, args) {
        if (!value)
            return value;
        let map;
        if (typeof (args) != "function")
            map = key => args[key];
        else
            map = args;
        let result = "";
        let paramName = "";
        let state = 0;
        for (let i = 0; i < value.length; i++) {
            const c = value[i];
            switch (state) {
                case 0:
                    if (c == '$')
                        state = 1;
                    else
                        result += c;
                    break;
                case 1:
                    if (c == '(') {
                        state = 2;
                        paramName = "";
                    }
                    else {
                        result += "$" + c;
                        state = 0;
                    }
                    break;
                case 2:
                    if (c == ')') {
                        const paramValue = map(paramName);
                        result += JSON.stringify(paramValue);
                        state = 0;
                    }
                    else
                        paramName += c;
                    break;
            }
        }
        return result;
    }
    Format.replaceArgs2 = replaceArgs2;
    /****************************************/
    function linkify(value) {
        if (!value)
            return "";
        let replacedText, replacePattern1, replacePattern2, replacePattern3;
        //URLs starting with http://, https://, or ftp://
        replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
        replacedText = value.replace(replacePattern1, '<a href="$1" target="_blank">$1</a>');
        //URLs starting with "www." (without // before it, or it'd re-link the ones done above).
        replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
        replacedText = replacedText.replace(replacePattern2, '$1<a href="http://$2" target="_blank">$2</a>');
        //Change email addresses to mailto:: links.
        replacePattern3 = /(([a-zA-Z0-9\-\_\.])+@[a-zA-Z\_]+?(\.[a-zA-Z]{2,6})+)/gim;
        replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>');
        return replacedText;
    }
    Format.linkify = linkify;
})(Format || (Format = {}));


/***/ }),

/***/ 6615:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": () => (/* binding */ Http)
/* harmony export */ });
/* harmony import */ var _Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1923);

var Http;
(function (Http) {
    function getStringAsync(url) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "GET",
        });
    }
    Http.getStringAsync = getStringAsync;
    /****************************************/
    function postStringAsync(url, data) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "POST",
            data: data,
        });
    }
    Http.postStringAsync = postStringAsync;
    /****************************************/
    function getJsonAsync(url) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "GET",
            responseType: "application/json",
        });
    }
    Http.getJsonAsync = getJsonAsync;
    /****************************************/
    function postJsonAsync(url, data) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "POST",
            responseType: "application/json",
            data: data,
        });
    }
    Http.postJsonAsync = postJsonAsync;
    /****************************************/
    function postBinaryAsync(url, data, onProgress) {
        return _Global__WEBPACK_IMPORTED_MODULE_0__/* .Services.httpClient.requestAsync */ .K9.httpClient.requestAsync({
            url: url,
            method: "POST",
            responseType: "application/json",
            dataType: "application/octet-stream",
            data: data,
            onProgress: onProgress
        });
    }
    Http.postBinaryAsync = postBinaryAsync;
})(Http || (Http = {}));


/***/ }),

/***/ 2696:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nq": () => (/* binding */ isList),
/* harmony export */   "Ex": () => (/* binding */ isObservableList),
/* harmony export */   "HD": () => (/* binding */ isString),
/* harmony export */   "mf": () => (/* binding */ isFunction),
/* harmony export */   "Kn": () => (/* binding */ isObject)
/* harmony export */ });
/* unused harmony exports isCloneable, isStateManager, isGuid */
const GUID_REGEXP = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
function isList(obj) {
    return obj && typeof obj == "object" && "add" in obj && "get" in obj && "count" in obj;
}
/****************************************/
function isCloneable(obj) {
    return obj && typeof obj == "object" && "clone" in obj && typeof obj["clone"] == "function";
}
/****************************************/
function isObservableList(obj) {
    return isList(obj) && "subscribe" in obj;
}
/****************************************/
function isString(obj) {
    return typeof obj == "string";
}
/****************************************/
function isFunction(obj) {
    return typeof obj == "function";
}
/****************************************/
function isObject(obj) {
    return typeof obj == "object";
}
/****************************************/
function isStateManager(obj) {
    return obj && typeof obj == "object" && "setState" in obj && "getState" in obj;
}
function isGuid(obj) {
    return GUID_REGEXP.test(obj?.toString());
}


/***/ }),

/***/ 7985:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": () => (/* binding */ Uri)
/* harmony export */ });
/* harmony import */ var _Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1923);

var Uri;
(function (Uri) {
    var _relativeSegment;
    var _absoluteSegment;
    /****************************************/
    function absolute(uri) {
        if (uri.substr(0, 2) == "./" || uri.substr(0, 2) == "~/")
            return getAbsoluteSegment(document.URL) + _Global__WEBPACK_IMPORTED_MODULE_0__/* .App.baseUrl.substr */ .gV.baseUrl.substr(1) + uri.substr(2);
        else if (uri.substr(0, 1) == "/")
            return getAbsoluteSegment(document.URL) + uri.substr(1);
        else if (isAbsolute(uri))
            return uri;
        return getRelativeSegment(document.URL) + uri.substr(1);
    }
    Uri.absolute = absolute;
    /****************************************/
    function isAbsolute(uri) {
        return uri.indexOf("://") != -1;
    }
    Uri.isAbsolute = isAbsolute;
    /****************************************/
    function getRelativeSegment(uri) {
        if (!_relativeSegment) {
            _relativeSegment = "";
            const index = uri.lastIndexOf("/");
            if (index != -1)
                _relativeSegment = uri.substr(0, index + 1);
        }
        return _relativeSegment;
    }
    Uri.getRelativeSegment = getRelativeSegment;
    /****************************************/
    function getAbsoluteSegment(uri) {
        if (!_absoluteSegment) {
            _absoluteSegment = "";
            let index = uri.indexOf("://");
            if (index != -1) {
                index = uri.indexOf("/", index + 4);
                if (index != -1)
                    _absoluteSegment = uri.substr(0, index + 1);
            }
        }
        return _absoluteSegment;
    }
    Uri.getAbsoluteSegment = getAbsoluteSegment;
})(Uri || (Uri = {}));


/***/ }),

/***/ 81:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": () => (/* binding */ linq)
/* harmony export */ });
/* unused harmony export Linq */
/* harmony import */ var _Helpers_TypeCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2696);
/* harmony import */ var _Utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6196);


/****************************************/
class EmptyEnumerator {
    get current() {
        return undefined;
    }
    /****************************************/
    moveNext() {
        return false;
    }
    /****************************************/
    reset() {
    }
    /****************************************/
    count() {
        return 0;
    }
}
/****************************************/
class DistinctEnumerator {
    _selector;
    _source;
    _foundItems;
    _current;
    /****************************************/
    constructor(source, selector) {
        this._selector = selector;
        this._source = source;
        if (!this._selector)
            this._selector = a => a;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._current;
    }
    /****************************************/
    moveNext() {
        while (this._source.moveNext()) {
            const item = this._selector(this._source.current);
            if (this._foundItems.indexOf(item) == -1) {
                this._foundItems.push(item);
                this._current = item;
                return true;
            }
        }
        return false;
    }
    /****************************************/
    reset() {
        this._source.reset();
        this._foundItems = [];
        this._current = undefined;
    }
}
/****************************************/
class DictionaryEnumerator {
    _curIndex;
    _keyList;
    _value;
    /****************************************/
    constructor(value) {
        this._keyList = Object.getOwnPropertyNames(value);
        this._value = value;
        this.reset();
    }
    /****************************************/
    get current() {
        return {
            key: this._keyList[this._curIndex],
            value: this._value[this._keyList[this._curIndex]]
        };
    }
    /****************************************/
    moveNext() {
        this._curIndex++;
        return this._curIndex < this._keyList.length;
    }
    /****************************************/
    reset() {
        this._curIndex = -1;
    }
    /****************************************/
    first() {
        return {
            key: this._keyList[0],
            value: this._value[this._keyList[0]]
        };
    }
    /****************************************/
    last() {
        return {
            key: this._keyList[this._keyList.length - 1],
            value: this._value[this._keyList[this._keyList.length - 1]]
        };
    }
    /****************************************/
    count() {
        return this._keyList.length;
    }
}
/****************************************/
class ArrayEnumerator {
    _curIndex;
    _value;
    /****************************************/
    constructor(value) {
        this._value = value;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._value[this._curIndex];
    }
    /****************************************/
    toArray() {
        return this._value;
    }
    /****************************************/
    moveNext() {
        this._curIndex++;
        return this._curIndex < this._value.length;
    }
    /****************************************/
    reset() {
        this._curIndex = -1;
    }
    /****************************************/
    first() {
        return this._value[0];
    }
    /****************************************/
    last() {
        return this._value[this._value.length - 1];
    }
    /****************************************/
    count() {
        return this._value.length;
    }
}
/****************************************/
class CollectionEnumerator {
    _curIndex;
    _value;
    /****************************************/
    constructor(value) {
        this._value = value;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._value.item(this._curIndex);
    }
    /****************************************/
    moveNext() {
        this._curIndex++;
        return this._curIndex < this._value.length;
    }
    /****************************************/
    reset() {
        this._curIndex = -1;
    }
    /****************************************/
    first() {
        return this._value.item(0);
    }
    /****************************************/
    last() {
        return this._value.item(this._value.length - 1);
    }
    /****************************************/
    count() {
        return this._value.length;
    }
}
/****************************************/
class SelectManyEnumerator {
    _selector;
    _source;
    _index;
    _curGroup;
    /****************************************/
    constructor(source, selector) {
        this._selector = selector;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._curGroup?.current;
    }
    /****************************************/
    moveNext() {
        while (true) {
            while (!this._curGroup) {
                if (!this._source.moveNext())
                    return false;
                this._curGroup = this._selector(this._source.current, this._index)?.getEnumerator();
            }
            if (this._curGroup) {
                if (!this._curGroup.moveNext())
                    this._curGroup = null;
                else {
                    this._index++;
                    return true;
                }
            }
        }
    }
    /****************************************/
    reset() {
        this._curGroup = null;
        this._index = -1;
        this._source.reset();
    }
}
/****************************************/
class SelectEnumerator {
    _selector;
    _source;
    _index;
    /****************************************/
    constructor(source, selector) {
        this._selector = selector;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._selector(this._source.current, this._index);
    }
    /****************************************/
    moveNext() {
        this._index++;
        return this._source.moveNext();
    }
    /****************************************/
    reset() {
        this._index = -1;
        this._source.reset();
    }
}
/****************************************/
class WhereEnumerator {
    _condition;
    _source;
    /****************************************/
    constructor(source, condition) {
        this._condition = condition;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._source.current;
    }
    /****************************************/
    moveNext() {
        while (this._source.moveNext()) {
            if (this._condition(this._source.current))
                return true;
        }
        return false;
    }
    /****************************************/
    reset() {
        this._source.reset();
    }
}
/****************************************/
class SkipEnumerator {
    _source;
    _count;
    _skipped;
    /****************************************/
    constructor(source, count) {
        this._count = count;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._source.current;
    }
    /****************************************/
    moveNext() {
        if (!this._skipped) {
            let elCount = 0;
            while (elCount < this._count) {
                if (!this._source.moveNext())
                    return false;
                elCount++;
            }
            this._skipped = true;
        }
        return this._source.moveNext();
    }
    /****************************************/
    reset() {
        this._source.reset();
        this._skipped = false;
    }
}
/****************************************/
class TakeEnumerator {
    _source;
    _count;
    _taken;
    /****************************************/
    constructor(source, count) {
        this._count = count;
        this._source = source;
        this.reset();
    }
    /****************************************/
    get current() {
        return this._source.current;
    }
    /****************************************/
    moveNext() {
        if (this._taken >= this._count)
            return false;
        if (!this._source.moveNext())
            return false;
        this._taken++;
        return true;
    }
    /****************************************/
    reset() {
        this._source.reset();
        this._taken = 0;
    }
}
/****************************************/
class IteratorEnumerator {
    _source;
    _current;
    /****************************************/
    constructor(source) {
        this._source = source;
    }
    /****************************************/
    get current() {
        return this._current;
    }
    /****************************************/
    moveNext() {
        const result = this._source.next();
        if (result.done)
            return false;
        this._current = result.value;
        return true;
    }
    /****************************************/
    reset() {
    }
}
/****************************************/
class Linq {
    _enumerator;
    /****************************************/
    constructor(value) {
        this._enumerator = value;
    }
    /****************************************/
    selectMany(selector) {
        return linq(new SelectManyEnumerator(this._enumerator, selector));
    }
    /****************************************/
    select(selector) {
        return linq(new SelectEnumerator(this._enumerator, selector));
    }
    ofType(typeOrCheck) {
        if ("prototype" in typeOrCheck)
            return this.where(a => a instanceof typeOrCheck);
        return this.where(a => typeOrCheck(a));
    }
    /****************************************/
    where(condition) {
        return linq(new WhereEnumerator(this._enumerator, condition));
    }
    /****************************************/
    first(condition) {
        if (condition)
            return this.where(condition).first();
        if (this._enumerator.first)
            return this._enumerator.first();
        this._enumerator.reset();
        if (this._enumerator.moveNext())
            return this._enumerator.current;
    }
    /****************************************/
    last() {
        if (this._enumerator.last)
            return this._enumerator.last();
        this._enumerator.reset();
        let lastItem;
        while (this._enumerator.moveNext())
            lastItem = this._enumerator.current;
        return lastItem;
    }
    /****************************************/
    sum(selector) {
        if (selector)
            return this.select(selector).sum();
        let result = 0;
        this.foreach(a => {
            result += parseFloat(a);
        });
        return result;
    }
    /****************************************/
    min(selector) {
        if (selector)
            return this.select(selector).min();
        let result = Number.POSITIVE_INFINITY;
        this.foreach(a => {
            const number = parseFloat(a);
            if (number < result)
                result = number;
        });
        return result;
    }
    /****************************************/
    max(selector) {
        if (selector)
            return this.select(selector).max();
        let result = Number.NEGATIVE_INFINITY;
        this.foreach(a => {
            const number = parseFloat(a);
            if (number > result)
                result = number;
        });
        return result;
    }
    /****************************************/
    avg(selector) {
        if (selector)
            return this.select(selector).avg();
        let result = 0;
        let count = 0;
        this.foreach(a => {
            result += parseFloat(a);
            count++;
        });
        if (count)
            return result / count;
        return NaN;
    }
    /****************************************/
    count(condition) {
        if (condition)
            return this.where(condition).count();
        if (this._enumerator.count)
            return this._enumerator.count();
        this._enumerator.reset();
        let count = 0;
        while (this._enumerator.moveNext())
            count++;
        return count;
    }
    /****************************************/
    concat(separator, selector) {
        let result = "";
        let index = 0;
        if (!selector)
            selector = a => a.toString();
        this.foreach(a => {
            if (index > 0)
                result += separator;
            result += selector(a);
            index++;
        });
        return result;
    }
    /****************************************/
    orderBy(selector) {
        const result = this.toArray();
        result.sort((a, b) => {
            const itemA = selector(a);
            const itemB = selector(b);
            return itemA - itemB;
        });
        return linq(result);
    }
    /****************************************/
    orderByDesc(selector) {
        const result = this.toArray();
        result.sort((a, b) => {
            const itemA = selector(a);
            const itemB = selector(b);
            return itemB - itemA;
        });
        return linq(result);
    }
    /****************************************/
    distinct(selector) {
        return linq(new DistinctEnumerator(this._enumerator, selector));
    }
    groupBy(key, comparer) {
        const result = [];
        if (!comparer)
            comparer = (a, b) => a == b;
        if (typeof key == "function") {
            const keySelector = key;
            this.foreach(item => {
                const itemKey = keySelector(item);
                let groupItem = linq(result).first(a => comparer(a.key, itemKey));
                if (!groupItem) {
                    groupItem = {
                        key: itemKey,
                        values: linq(new ArrayEnumerator([]))
                    };
                    result.push(groupItem);
                }
                groupItem.values._enumerator.toArray().push(item);
            });
        }
        return linq(result);
    }
    /****************************************/
    indexOf(condition) {
        let index = 0;
        this._enumerator.reset();
        while (this._enumerator.moveNext()) {
            if (condition(this._enumerator.current))
                return index;
            index++;
        }
    }
    /****************************************/
    foreach(action) {
        this._enumerator.reset();
        let index = 0;
        while (this._enumerator.moveNext()) {
            action(this._enumerator.current, index);
            index++;
        }
        return this;
    }
    /****************************************/
    async foreachAsync(action, chunkSize = 1) {
        this._enumerator.reset();
        let index = 0;
        while (this._enumerator.moveNext()) {
            await action(this._enumerator.current, index);
            index++;
        }
        return this;
    }
    /****************************************/
    any(condition) {
        if (!condition)
            return this._enumerator.moveNext();
        return this.where(condition).any();
    }
    /****************************************/
    contains(item, comparer) {
        if (!comparer)
            comparer = (a, b) => a == b;
        this._enumerator.reset();
        while (this._enumerator.moveNext())
            if (comparer(this._enumerator.current, item))
                return true;
        return false;
    }
    /****************************************/
    all(condition) {
        return !this.where(a => !condition(a)).any();
    }
    /****************************************/
    take(count) {
        return linq(new TakeEnumerator(this._enumerator, count));
    }
    /****************************************/
    skip(count) {
        return linq(new SkipEnumerator(this._enumerator, count));
    }
    /****************************************/
    replace(condition, newItem) {
        if (!(this._enumerator instanceof ArrayEnumerator))
            throw "Invalid enumerator, expected array";
        const items = this._enumerator.toArray();
        for (let i = 0; i < items.length; i++) {
            if (condition(items[i]))
                items[i] == newItem;
        }
    }
    /****************************************/
    toGenerator() {
        function* generator(self) {
            self._enumerator.reset();
            while (self._enumerator.moveNext())
                yield self._enumerator.current;
        }
        return generator(this);
    }
    /****************************************/
    async toArrayAsync(chunkSize = 1) {
        if (this._enumerator.toArray)
            return this._enumerator.toArray();
        const array = [];
        let index = 0;
        for (const item of this.toGenerator()) {
            array.push(item);
            if (index % chunkSize == 0)
                await (0,_Utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_0__/* .delayAsync */ .$)(0);
            index++;
        }
        return array;
    }
    /****************************************/
    toArray() {
        if (this._enumerator.toArray)
            return this._enumerator.toArray();
        const result = [];
        this.foreach(a => result.push(a));
        return result;
    }
    toDictionary(keySelector, valueSelector) {
        if (!valueSelector)
            valueSelector = a => a;
        const result = {};
        this.foreach(a => result[keySelector(a)] = valueSelector(a));
        return result;
    }
    /****************************************/
    getEnumerator() {
        return this._enumerator;
    }
    /****************************************/
    [Symbol.iterator]() {
        this._enumerator.reset();
        return ({
            next: (value) => {
                const isDone = !this._enumerator.moveNext();
                return {
                    done: isDone,
                    value: this._enumerator.current
                };
            }
        });
    }
}
function linq(value) {
    let enumerator;
    if (!value)
        enumerator = new EmptyEnumerator();
    else if (Array.isArray(value))
        enumerator = new ArrayEnumerator(value);
    else if ("getEnumerator" in value)
        enumerator = value.getEnumerator();
    else if ((0,_Helpers_TypeCheck__WEBPACK_IMPORTED_MODULE_1__/* .isList */ .nq)(value))
        enumerator = new ArrayEnumerator(value.toArray());
    else if ("item" in value)
        enumerator = new CollectionEnumerator(value);
    else if ("next" in value && typeof (value["next"]) == "function")
        enumerator = new IteratorEnumerator(value);
    else if ("current" in value && "reset" in value && "moveNext" in value)
        enumerator = value;
    else
        enumerator = new DictionaryEnumerator(value);
    return new Linq(enumerator);
}


/***/ }),

/***/ 168:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": () => (/* binding */ Strings),
/* harmony export */   "M": () => (/* binding */ StringTable)
/* harmony export */ });
var Strings;
/****************************************/
class StringTable {
    static _tables = {};
    static _currentConfig;
    /****************************************/
    static getKey(config) {
        let key = config.language;
        if (config.sector)
            key += "|" + config.sector;
        return key;
    }
    /****************************************/
    static get(config) {
        if (!config)
            config = this._currentConfig;
        let result = StringTable._tables[this.getKey(config)];
        if (!result && config.sector)
            result = StringTable._tables[this.getKey({ language: config.language })];
        return result;
    }
    /****************************************/
    static add(value, config) {
        const key = this.getKey(config);
        const curValue = this._tables[key];
        if (!curValue)
            this._tables[key] = value;
        else {
            for (const str in value)
                curValue[str] = value[str];
        }
    }
    /****************************************/
    static get currentConfig() {
        return this._currentConfig;
    }
    /****************************************/
    static set currentConfig(value) {
        this._currentConfig = value;
        Strings = StringTable.get();
    }
}


/***/ }),

/***/ 3163:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sZ": () => (/* binding */ WordNumber),
/* harmony export */   "Fq": () => (/* binding */ StringUsage),
/* harmony export */   "wI": () => (/* binding */ DynamicString)
/* harmony export */ });
/* unused harmony exports WordGender, $string */
/* harmony import */ var _StringTable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(168);

var WordNumber;
(function (WordNumber) {
    WordNumber[WordNumber["Singular"] = 0] = "Singular";
    WordNumber[WordNumber["Plural"] = 1] = "Plural";
})(WordNumber || (WordNumber = {}));
/****************************************/
var WordGender;
(function (WordGender) {
    WordGender[WordGender["Male"] = 0] = "Male";
    WordGender[WordGender["Female"] = 1] = "Female";
})(WordGender || (WordGender = {}));
/****************************************/
var StringUsage;
(function (StringUsage) {
    StringUsage[StringUsage["General"] = 0] = "General";
    StringUsage[StringUsage["Label"] = 1] = "Label";
    StringUsage[StringUsage["Column"] = 2] = "Column";
    StringUsage[StringUsage["Action"] = 3] = "Action";
    StringUsage[StringUsage["Message"] = 4] = "Message";
    StringUsage[StringUsage["Question"] = 5] = "Question";
    StringUsage[StringUsage["Title"] = 6] = "Title";
    StringUsage[StringUsage["Tooltip"] = 7] = "Tooltip";
})(StringUsage || (StringUsage = {}));
;
/****************************************/
class DynamicStringManager {
    format(Strings) {
        return cfg => {
            let curValue = Strings(cfg);
            if (cfg) {
                if (cfg.usage === StringUsage.Column ||
                    cfg.usage === StringUsage.Label ||
                    cfg.usage === StringUsage.Action ||
                    cfg.usage === StringUsage.Title ||
                    cfg.usage === StringUsage.Question ||
                    cfg.usage === StringUsage.Tooltip ||
                    cfg.usage === StringUsage.Message)
                    curValue = curValue.substr(0, 1).toUpperCase() + curValue.substr(1);
                if (cfg.usage === StringUsage.Label)
                    curValue += ":";
                if (cfg.usage === StringUsage.Message)
                    curValue += ".";
                if (cfg.usage === StringUsage.Question)
                    curValue += "?";
            }
            return curValue;
        };
    }
    get(name) {
        const value = _StringTable__WEBPACK_IMPORTED_MODULE_0__/* .Strings */ .e[name];
        if (typeof value == "string")
            return DynamicString.simple(value);
        return value;
    }
    getValue(value, usageOrConfig) {
        if (typeof value == "function") {
            let cfg;
            if (usageOrConfig) {
                if (StringUsage[usageOrConfig])
                    cfg = {
                        usage: usageOrConfig
                    };
                else
                    cfg = usageOrConfig;
            }
            return value(cfg);
        }
        else {
            if (value && _StringTable__WEBPACK_IMPORTED_MODULE_0__/* .Strings */ .e && value in _StringTable__WEBPACK_IMPORTED_MODULE_0__/* .Strings */ .e)
                return this.getValue(this.get(value), usageOrConfig);
        }
        return value;
    }
    /****************************************/
    complex(value) {
        return DynamicString.format(cfg => {
            let state = 0;
            let result = "";
            let curName = "";
            let curNameParams = null;
            let curNameParamsDeep = 0;
            if (!cfg)
                cfg = {};
            if (!cfg.gender && cfg.params) {
                //Forzo la valutazione dei parametri x estrarre il genere
                cfg.params.forEach(a => {
                    if (typeof a === "function")
                        a({ ...cfg, params: [] });
                });
            }
            for (let i = 0; i < value.length; i++) {
                const c = value[i];
                switch (state) {
                    case 0:
                        if (c == "{") {
                            curName = "";
                            curNameParams = null;
                            state = 1;
                        }
                        else
                            result += c;
                        break;
                    case 1:
                        if (c == "}") {
                            state = 3;
                            i--;
                            break;
                        }
                        else if (c == ":") {
                            curNameParams = "";
                            curNameParamsDeep = 0;
                            state = 2;
                        }
                        else
                            curName += c;
                        break;
                    case 2:
                        if (c == "{")
                            curNameParamsDeep++;
                        if (c == "}") {
                            curNameParamsDeep--;
                            if (curNameParamsDeep < 0) {
                                state = 3;
                                i--;
                            }
                            else
                                curNameParams += c;
                        }
                        else
                            curNameParams += c;
                        break;
                    case 3:
                        let paramCfg;
                        if (curNameParams)
                            paramCfg = JSON.parse(curNameParams.trim());
                        else
                            paramCfg = {};
                        let flagFound = true;
                        while (flagFound) {
                            flagFound = false;
                            if (curName.startsWith("*")) {
                                paramCfg.number = WordNumber.Plural;
                                curName = curName.substr(1);
                                flagFound = true;
                            }
                            if (curName.startsWith("!")) {
                                paramCfg.useArticle = true;
                                curName = curName.substr(1);
                                flagFound = true;
                            }
                            if (curName.startsWith(".")) {
                                paramCfg.useArticleInd = true;
                                curName = curName.substr(1);
                                flagFound = true;
                            }
                        }
                        if (cfg.gender && !paramCfg.gender)
                            paramCfg.gender = cfg.gender;
                        if (cfg.cardinality && !paramCfg.cardinality)
                            paramCfg.cardinality = cfg.cardinality;
                        if (cfg.number && !paramCfg.number)
                            paramCfg.number = cfg.number;
                        if (cfg.useArticle !== undefined && paramCfg.useArticle === undefined)
                            paramCfg.useArticle = cfg.useArticle;
                        const number = parseInt(curName);
                        if (!isNaN(number)) {
                            if (cfg.params && number < cfg.params.length) {
                                const param = cfg.params[number];
                                result += this.getValue(param, paramCfg);
                            }
                        }
                        else
                            result += this.get(curName)(paramCfg);
                        if (paramCfg.gender)
                            cfg.gender = paramCfg.gender;
                        state = 0;
                        break;
                }
            }
            return result;
        });
    }
    /****************************************/
    adverb(advCfg) {
        return this.format(cfg => {
            return cfg && cfg.gender == WordGender.Female ? advCfg.female : advCfg.male;
        });
    }
    /****************************************/
    appendArticle(article, name) {
        let result = article;
        if (result.charAt(result.length - 1) != "'")
            result += " ";
        return result + name;
    }
    /****************************************/
    adjective(adjCfg) {
        return this.format(cfg => {
            const gender = cfg && cfg.gender == WordGender.Female ? adjCfg.female : adjCfg.male;
            const fullName = cfg && (cfg.number == WordNumber.Plural || cfg.cardinality > 1) ? gender.plural : gender.singular;
            if (cfg && cfg.useArticle)
                return this.appendArticle(fullName.detArticle, fullName.name);
            if (cfg && cfg.useArticleInd)
                return this.appendArticle(fullName.undetArticle, fullName.name);
            return fullName.name;
        });
    }
    /****************************************/
    noun(nameCfg) {
        return this.format(cfg => {
            if (!cfg)
                cfg = {};
            if (nameCfg.gender)
                cfg.gender = nameCfg.gender;
            const fullName = (cfg.number == WordNumber.Plural || cfg.cardinality > 1) ? nameCfg.plural : nameCfg.singular;
            if (cfg && cfg.useArticle)
                return this.appendArticle(fullName.detArticle, fullName.name);
            if (cfg && cfg.useArticleInd)
                return this.appendArticle(fullName.undetArticle, fullName.name);
            return fullName.name;
        });
    }
    /****************************************/
    map(selector) {
        return cfg => selector(_StringTable__WEBPACK_IMPORTED_MODULE_0__/* .Strings */ .e)(cfg);
    }
    /****************************************/
    simple(value) {
        return this.format(() => value);
    }
}
/****************************************/
var DynamicString = new DynamicStringManager();
function $string(name) {
    return DynamicString.get(name);
}


/***/ }),

/***/ 6196:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ delayAsync)
/* harmony export */ });
function delayAsync(milliseconds) {
    return new Promise(res => setTimeout(res, milliseconds));
}
;


/***/ }),

/***/ 2560:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports ScriptLoader, StyleLoader */
/* harmony import */ var _Core_Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1923);
/* harmony import */ var _Core_Helpers_Uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7985);
/* harmony import */ var _Core_Linq__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);



/****************************************/
class ScriptLoader {
    constructor(src) {
        this.src = Uri.absolute(src.replace("~/", "./"));
    }
    /****************************************/
    isLoaded() {
        if (this.src.substr(this.src.length - 3) == ".ts")
            return true;
        return linq(document.scripts).any(a => a.src.toLowerCase().startsWith(this.src.toLowerCase()));
    }
    /****************************************/
    loadAsync(operation) {
        if (this.isLoaded())
            return Promise.resolve(true);
        return new Promise((resolve, reject) => {
            const curOperation = Services.operation.begin({ parentOperation: operation, message: "Loading script " + this.src });
            const scriptNode = document.createElement("script");
            scriptNode.onload = () => {
                curOperation.end();
                resolve(true);
            };
            scriptNode.onerror = () => {
                curOperation.end();
                resolve(false);
            };
            scriptNode.type = "text/javascript";
            scriptNode.src = this.src;
            document.body.appendChild(scriptNode);
        });
    }
    /****************************************/
    src;
}
/****************************************/
class StyleLoader {
    constructor(src) {
        this.src = Uri.absolute(src.replace("~/", "./"));
    }
    /****************************************/
    isLoaded() {
        return linq(document.styleSheets).any(a => a.href && a.href.toLowerCase().startsWith(this.src.toLowerCase()));
    }
    /****************************************/
    loadAsync(operation) {
        if (this.isLoaded())
            return Promise.resolve(true);
        return new Promise((resolve, reject) => {
            const curOperation = Services.operation.begin({ parentOperation: operation, message: "Loading style " + this.src });
            const linkNode = document.createElement("link");
            linkNode.onload = () => {
                curOperation.end();
                resolve(true);
            };
            linkNode.onerror = () => {
                curOperation.end();
                resolve(false);
            };
            linkNode.rel = "stylesheet";
            linkNode.href = this.src;
            document.body.appendChild(linkNode);
        });
    }
    /****************************************/
    src;
}


/***/ }),

/***/ 8349:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export DynamicPageManager */
/* harmony import */ var _Core_Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1923);
/* harmony import */ var _Core_Helpers_Format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1691);
/* harmony import */ var _Core_Helpers_Http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6615);
/* harmony import */ var _Core_Linq__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);
/* harmony import */ var _Helpers_Loaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2560);





/****************************************/
class DynamicPageManager {
    _struture;
    /****************************************/
    async createPageAsync(pageInfo) {
        const curOperation = Services.operation.begin({ message: "Loading page '" + pageInfo.name + "'..." });
        const clientPage = await this.getClientPageAsync(pageInfo.name, curOperation);
        if (!clientPage.isLoded)
            await this.loadClientPageAsync(clientPage, curOperation);
        const result = eval(clientPage.action);
        let page;
        if (result instanceof Promise)
            page = await result;
        if (page != null)
            page.url = Format.replaceArgs(App.baseUrl + clientPage.url, pageInfo.args);
        page.args = pageInfo.args;
        curOperation.end();
        return page;
    }
    /****************************************/
    async loadComponentsAsync(pageName) {
        const curOperation = Services.operation.begin({ message: "Loading page '" + pageName + "'..." });
        const clientPage = await this.getClientPageAsync(pageName, curOperation);
        if (clientPage && !clientPage.isLoded)
            await this.loadClientPageAsync(clientPage, curOperation);
        curOperation.end();
    }
    /****************************************/
    async include(src) {
        const curStruct = await Http.getJsonAsync(src);
        if (curStruct) {
            if (curStruct.include) {
                for (const file of curStruct.include)
                    await this.include(file);
            }
            if (curStruct.components) {
                for (const key in curStruct.components)
                    this._struture.components[key] = curStruct.components[key];
            }
            if (curStruct.pages) {
                for (const key in curStruct.pages)
                    this._struture.pages[key] = curStruct.pages[key];
            }
        }
    }
    async loadAppStructureAsync(operation) {
        if (!this._struture) {
            this._struture = {
                components: {},
                pages: {},
            };
            await this.include("~/app.json");
        }
    }
    /****************************************/
    async loadClientPageAsync(clientPage, operation) {
        const loaders = [];
        clientPage.isLoded = true;
        if (clientPage.scripts)
            clientPage.scripts.forEach(a => loaders.push(new ScriptLoader(a)));
        if (clientPage.styles)
            clientPage.styles.forEach(a => loaders.push(new StyleLoader(a)));
        await Promise.all(linq(loaders).select(a => a.loadAsync(operation)).toArray());
    }
    /****************************************/
    async getClientPageAsync(name, operation) {
        await this.loadAppStructureAsync(operation);
        const result = {};
        const pageInfo = this._struture.pages[name];
        result.styles = [];
        result.scripts = [];
        result.action = pageInfo.action;
        result.url = pageInfo.url;
        this.includeClientPage(result, pageInfo.include);
        return result;
    }
    /****************************************/
    includeClientPage(clientPage, include) {
        if (!include)
            return;
        if (include.components)
            include.components.forEach(a => this.includeClientPage(clientPage, this._struture.components[a].include));
        if (include.styles)
            include.styles.forEach(a => {
                if (clientPage.styles.indexOf(a) == -1)
                    clientPage.styles.push(a);
            });
        if (include.scripts)
            include.scripts.forEach(a => {
                if (clientPage.scripts.indexOf(a) == -1)
                    clientPage.scripts.push(a);
            });
    }
}


/***/ }),

/***/ 8280:
/***/ (() => {

if (window["ko"]) {
    ko.bindingHandlers.attach = {
        init: (element, valueAccessor, allBindings, viewModel) => {
            let func = ko.unwrap(valueAccessor());
            if (func === true || func == undefined)
                func = viewModel["attachNode"];
            if (typeof func != "function")
                throw "Supplied argument is not a function";
            setTimeout(() => func.call(viewModel, element));
        }
    };
}


/***/ }),

/***/ 2370:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__2370__;

/***/ }),

/***/ 1431:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__1431__;

/***/ }),

/***/ 4396:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__4396__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "$string": () => (/* reexport */ DynamicString/* $string */.tY),
  "ActionBar": () => (/* reexport */ ActionBar_ActionBar),
  "ActionPriority": () => (/* reexport */ IAction_ActionPriority),
  "ActionView": () => (/* reexport */ ActionView_ActionView),
  "Actions": () => (/* reexport */ Actions_Actions),
  "Activity": () => (/* reexport */ Activity),
  "ActivityEditor": () => (/* reexport */ ActivityEditor),
  "AggregationMode": () => (/* reexport */ AggregationMode),
  "Animation": () => (/* reexport */ Animation),
  "App": () => (/* reexport */ Global/* App */.gV),
  "AppContentManager": () => (/* reexport */ AppContentManager),
  "AppEvent": () => (/* reexport */ AppEvent),
  "AttachBehavoir": () => (/* reexport */ AttachBehavoir_AttachBehavoir),
  "BaseEditor": () => (/* reexport */ BaseEditor),
  "BaseItemEditor": () => (/* reexport */ BaseItemEditor),
  "BasePicker": () => (/* reexport */ BasePicker),
  "BasePopUpMessage": () => (/* reexport */ BasePopUpMessage),
  "BaseSearch": () => (/* reexport */ BaseSearch),
  "BaseTextEditor": () => (/* reexport */ BaseTextEditor),
  "BindableObject": () => (/* reexport */ BindableObject_BindableObject),
  "Binder": () => (/* reexport */ Binder),
  "BingMapItem": () => (/* reexport */ BingMapItem),
  "BingMapManager": () => (/* reexport */ BingMapManager),
  "Blocker": () => (/* reexport */ Blocker_Blocker),
  "BooleanEditor": () => (/* reexport */ BooleanEditor_BooleanEditor),
  "BottomSheet": () => (/* reexport */ BottomSheet_BottomSheet),
  "CachedEditableItemsSource": () => (/* reexport */ CachedEditableItemsSource),
  "ColorPicker": () => (/* reexport */ ColorPicker),
  "Components": () => (/* reexport */ Components),
  "ComputedProperty": () => (/* reexport */ ComputedProperty),
  "ConsoleGroupView": () => (/* reexport */ ConsoleGroupView),
  "ConsoleMessageView": () => (/* reexport */ ConsoleMessageView),
  "ConsoleView": () => (/* reexport */ ConsoleView_ConsoleView),
  "Container": () => (/* reexport */ Container_Container),
  "ContentActivity": () => (/* reexport */ ContentActivity_ContentActivity),
  "ContentHostView": () => (/* reexport */ ContentHostView_ContentHostView),
  "ContentSelector": () => (/* reexport */ ContentSelector),
  "ContentView": () => (/* reexport */ ContentView),
  "ContextMenu": () => (/* reexport */ ContextMenu_ContextMenu),
  "ContextMenuBehavoir": () => (/* reexport */ ContextMenuBehavoir_ContextMenuBehavoir),
  "CounterView": () => (/* reexport */ CounterView_CounterView),
  "DateEditor": () => (/* reexport */ DateEditor_DateEditor),
  "DateEditorCombo": () => (/* reexport */ DateEditorCombo_DateEditorCombo),
  "DbStorage": () => (/* reexport */ DbStorage_DbStorage),
  "Drawer": () => (/* reexport */ Drawer_Drawer),
  "DrawerGroup": () => (/* reexport */ DrawerGroup),
  "DynamicPageManager": () => (/* reexport */ Services_DynamicPageManager/* DynamicPageManager */.I),
  "DynamicString": () => (/* reexport */ DynamicString/* DynamicString */.wI),
  "EditableItemsSource": () => (/* reexport */ EditableItemsSource_EditableItemsSource),
  "Editors": () => (/* reexport */ Editors),
  "Exception": () => (/* reexport */ Exception_Exception),
  "FileUploadView": () => (/* reexport */ FileUploadView_FileUploadView),
  "Format": () => (/* reexport */ Helpers_Format/* Format */.E),
  "FullItemsLoader": () => (/* reexport */ FullItemsLoader),
  "GeoPlotApplication": () => (/* reexport */ GeoPlotApplication),
  "GeoPlotPage": () => (/* reexport */ GeoPlotPage),
  "GestureType": () => (/* reexport */ IGestureListener_GestureType),
  "GoogleAnalytics": () => (/* reexport */ GoogleAnalytics_GoogleAnalytics),
  "GridView": () => (/* reexport */ GridView),
  "HeadedContentView": () => (/* reexport */ HeadedContentView_HeadedContentView),
  "HistoryPageHost": () => (/* reexport */ HIstoryPageHost_HistoryPageHost),
  "HtmlView": () => (/* reexport */ HtmlView_HtmlView),
  "Http": () => (/* reexport */ Http/* Http */.e),
  "HttpException": () => (/* reexport */ HttpException),
  "IconTextView": () => (/* reexport */ IconTextView_IconTextView),
  "ImageView": () => (/* reexport */ ImageView_ImageView),
  "Interaction": () => (/* reexport */ Interaction),
  "Item": () => (/* reexport */ Item),
  "ItemEditContent": () => (/* reexport */ ItemEditContent),
  "ItemEditorConverter": () => (/* reexport */ ItemEditorConverter),
  "ItemListContent": () => (/* reexport */ ItemListContent),
  "ItemView": () => (/* reexport */ ItemView_ItemView),
  "ItemsEditor": () => (/* reexport */ ItemsEditor_ItemsEditor),
  "ItemsEditorItemView": () => (/* reexport */ ItemsEditorItemView),
  "ItemsObserver": () => (/* reexport */ ItemsObserver_ItemsObserver),
  "ItemsSource": () => (/* reexport */ ItemsSource_ItemsSource),
  "ItemsView": () => (/* reexport */ ItemsView_ItemsView),
  "Linq": () => (/* reexport */ Linq/* Linq */.C),
  "ListView": () => (/* reexport */ ListView_ListView),
  "LocalDbRrepositoy": () => (/* reexport */ LocalDbRrepositoy),
  "LocalStorageCache": () => (/* reexport */ LocalStorageCache_LocalStorageCache),
  "LocationView": () => (/* reexport */ LocationView_LocationView),
  "LongPressBehavoir": () => (/* reexport */ LongPresssBehavoir_LongPressBehavoir),
  "MONTHS": () => (/* reexport */ MONTHS),
  "MapContent": () => (/* reexport */ MapContent),
  "MapItemsView": () => (/* reexport */ MapItemsView),
  "MapShapeType": () => (/* reexport */ IMapManager_MapShapeType),
  "MapView": () => (/* reexport */ MapView_MapView),
  "MasterDetailsContent": () => (/* reexport */ MasterDetailsContent),
  "MediaEditor": () => (/* reexport */ MediaEditor_MediaEditor),
  "MediaView": () => (/* reexport */ MediaView_MediaView),
  "MessageBox": () => (/* reexport */ MessageBox_MessageBox),
  "MessageContent": () => (/* reexport */ MessageContent),
  "MultiItemPicker": () => (/* reexport */ MultiItemPicker_MultiItemPicker),
  "MultiItemSelector": () => (/* reexport */ MultiItemSelector),
  "NavBar": () => (/* reexport */ NavBar_NavBar),
  "NavBarItem": () => (/* reexport */ NavBarItem),
  "NumberEditor": () => (/* reexport */ NumberEditor),
  "ObjectEditor": () => (/* reexport */ ObjectEditor),
  "ObservableList": () => (/* reexport */ ObservableList),
  "ObservableProperty": () => (/* reexport */ ObservableProperty_ObservableProperty),
  "OperationType": () => (/* reexport */ IOperation_OperationType),
  "Page": () => (/* reexport */ Page),
  "PageHostMode": () => (/* reexport */ PageHostMode),
  "PagedItemsLoader": () => (/* reexport */ PagedItemsLoader_PagedItemsLoader),
  "Panel": () => (/* reexport */ Panel_Panel),
  "ParameterViewModel": () => (/* reexport */ ParameterViewModel),
  "PermissionManager": () => (/* reexport */ PermissionManager),
  "PermissionRequestItemView": () => (/* reexport */ PermissionManager_PermissionRequestItemView),
  "PopUpContent": () => (/* reexport */ PopUpContent_PopUpContent),
  "PopUpEditor": () => (/* reexport */ PopupEditor_PopUpEditor),
  "PrimaryActionMode": () => (/* reexport */ PrimaryActionMode),
  "ProgressView": () => (/* reexport */ ProgressView_ProgressView),
  "Properties": () => (/* reexport */ Properties_Properties),
  "PropertyView": () => (/* reexport */ PropertyView_PropertyView),
  "RemovableItemView": () => (/* reexport */ RemovableItemView_RemovableItemView),
  "RichTextEditor": () => (/* reexport */ RichTextEditor),
  "RippleClickBehavoir": () => (/* reexport */ RippleClickBehavoir_RippleClickBehavoir),
  "ScriptLoader": () => (/* reexport */ Loaders/* ScriptLoader */.W),
  "ScrollCheckBehavoir": () => (/* reexport */ ScrollCheckBehavoir_ScrollCheckBehavoir),
  "SearchActivity": () => (/* reexport */ SearchActivity),
  "SearchView": () => (/* reexport */ SearchView_SearchView),
  "SectionEditor": () => (/* reexport */ SectionEditor_SectionEditor),
  "SectionView": () => (/* reexport */ SectionView),
  "SectionsView": () => (/* reexport */ SectionsView_SectionsView),
  "SelectMultipleItemsActivity": () => (/* reexport */ SelectMultipleItemsActivity),
  "SelectSingleItemActivity": () => (/* reexport */ SelectSingleItemActivity),
  "SelectableItemView": () => (/* reexport */ SelectableItemView_SelectableItemView),
  "SelectionManager": () => (/* reexport */ SelectionManager),
  "SelfHostedPageHost": () => (/* reexport */ SelfHostedPageHost_SelfHostedPageHost),
  "Services": () => (/* reexport */ Global/* Services */.K9),
  "Signal": () => (/* reexport */ Signal_Signal),
  "SimpleItemView": () => (/* reexport */ SimpleItemView_SimpleItemView),
  "SingleItemPicker": () => (/* reexport */ SingleItemPicker_SingleItemPicker),
  "SingleItemSelector": () => (/* reexport */ SingleItemSelector_SingleItemSelector),
  "SlidePageHost": () => (/* reexport */ SlidePageHost_SlidePageHost),
  "SnackBar": () => (/* reexport */ SnackBar_SnackBar),
  "StaticMapView": () => (/* reexport */ StaticMapView),
  "StringTable": () => (/* reexport */ Core_StringTable/* StringTable */.M),
  "StringUsage": () => (/* reexport */ DynamicString/* StringUsage */.Fq),
  "Strings": () => (/* reexport */ Core_StringTable/* Strings */.e),
  "StudioPage": () => (/* reexport */ StudioPage),
  "StyleLoader": () => (/* reexport */ Loaders/* StyleLoader */.D),
  "TemplateBuilder": () => (/* reexport */ TemplateBuilder_TemplateBuilder),
  "TemplateCatalog": () => (/* reexport */ TemplateCatalog),
  "TextEditor": () => (/* reexport */ TextEditor_TextEditor),
  "TextView": () => (/* reexport */ TextView_TextView),
  "TimeEditor": () => (/* reexport */ TimeEditor),
  "TimePart": () => (/* reexport */ TimePart),
  "TimeSpan": () => (/* reexport */ TimeSpan_TimeSpan),
  "Toast": () => (/* reexport */ Toast_Toast),
  "Uri": () => (/* reexport */ Helpers_Uri/* Uri */.S),
  "Validators": () => (/* reexport */ Validators),
  "VibrateClickBehavoir": () => (/* reexport */ VibrateClickBehavoir_VibrateClickBehavoir),
  "VideoView": () => (/* reexport */ VideoView_VideoView),
  "View": () => (/* reexport */ View_View),
  "ViewApplication": () => (/* reexport */ ViewApplication),
  "ViewComponent": () => (/* reexport */ ViewComponent),
  "ViewModes": () => (/* reexport */ ViewModes),
  "ViewOperationManager": () => (/* reexport */ Operation_ViewOperationManager),
  "WEEK_DAYS": () => (/* reexport */ WEEK_DAYS),
  "WebPage": () => (/* reexport */ WebPage),
  "WebView": () => (/* reexport */ WebView_WebView),
  "WizardStepView": () => (/* reexport */ WizardStepView),
  "WizardView": () => (/* reexport */ WizardView_WizardView),
  "WordGender": () => (/* reexport */ DynamicString/* WordGender */.ko),
  "WordNumber": () => (/* reexport */ DynamicString/* WordNumber */.sZ),
  "XHRHttpClient": () => (/* reexport */ XHRHttpClient_XHRHttpClient),
  "actionItems": () => (/* reexport */ actionItems),
  "addClass": () => (/* reexport */ DomUtils_addClass),
  "addDays": () => (/* reexport */ addDays),
  "apply": () => (/* reexport */ apply),
  "arrayItems": () => (/* reexport */ arrayItems),
  "behavoirCatalog": () => (/* reexport */ IBehavoir_behavoirCatalog),
  "capitalizeFirst": () => (/* reexport */ capitalizeFirst),
  "centerElement": () => (/* reexport */ centerElement),
  "clone": () => (/* reexport */ clone),
  "copyText": () => (/* reexport */ copyText),
  "createInstance": () => (/* reexport */ createInstance),
  "createProperty": () => (/* reexport */ createProperty),
  "dateAdd": () => (/* reexport */ dateAdd),
  "dateDiff": () => (/* reexport */ dateDiff),
  "defineTemplate": () => (/* reexport */ defineTemplate),
  "delayAsync": () => (/* reexport */ PromiseUtils/* delayAsync */.$),
  "discretize": () => (/* reexport */ discretize),
  "divideNull": () => (/* reexport */ divideNull),
  "equals": () => (/* reexport */ equals),
  "equalsArray": () => (/* reexport */ equalsArray),
  "event": () => (/* reexport */ Event_event),
  "execAsync": () => (/* reexport */ execAsync),
  "expandCollapse": () => (/* reexport */ expandCollapse),
  "exponential": () => (/* reexport */ exponential),
  "forEachAsync": () => (/* reexport */ forEachAsync),
  "forEachRev": () => (/* reexport */ forEachRev),
  "forEachRevAsync": () => (/* reexport */ forEachRevAsync),
  "formatDate": () => (/* reexport */ formatDate),
  "formatDateArgument": () => (/* reexport */ formatDateArgument),
  "formatForCss": () => (/* reexport */ ViewUtils_formatForCss),
  "generateId": () => (/* reexport */ generateId),
  "generateNodeId": () => (/* reexport */ generateNodeId),
  "get": () => (/* reexport */ get),
  "getBaseType": () => (/* reexport */ getBaseType),
  "getFunctionName": () => (/* reexport */ getFunctionName),
  "getOrCreateProperty": () => (/* reexport */ getOrCreateProperty),
  "getPostionAsync": () => (/* reexport */ getPostionAsync),
  "getScrollParent": () => (/* reexport */ getScrollParent),
  "getType": () => (/* reexport */ getType),
  "getTypeName": () => (/* reexport */ getTypeName),
  "hasProp": () => (/* reexport */ hasProp),
  "injectProxy": () => (/* reexport */ injectProxy),
  "install": () => (/* reexport */ Global/* install */.N9),
  "isActivable": () => (/* reexport */ isActivable),
  "isAndroidApp": () => (/* reexport */ isAndroidApp),
  "isAsyncEditor": () => (/* reexport */ isAsyncEditor),
  "isAsyncLoad": () => (/* reexport */ isAsyncLoad),
  "isCloneable": () => (/* reexport */ TypeCheck/* isCloneable */._p),
  "isEditable": () => (/* reexport */ isEditable),
  "isEmpty": () => (/* reexport */ isEmpty),
  "isFunction": () => (/* reexport */ TypeCheck/* isFunction */.mf),
  "isGuid": () => (/* reexport */ TypeCheck/* isGuid */.kQ),
  "isHTMLAttach": () => (/* reexport */ isHTMLAttach),
  "isHTMLContainer": () => (/* reexport */ isHTMLContainer),
  "isInstanceOf": () => (/* reexport */ isInstanceOf),
  "isList": () => (/* reexport */ TypeCheck/* isList */.nq),
  "isNaNOrNull": () => (/* reexport */ isNaNOrNull),
  "isObject": () => (/* reexport */ TypeCheck/* isObject */.Kn),
  "isObservableList": () => (/* reexport */ TypeCheck/* isObservableList */.Ex),
  "isParentOrSelf": () => (/* reexport */ isParentOrSelf),
  "isSameDay": () => (/* reexport */ isSameDay),
  "isScrolledIntoView": () => (/* reexport */ isScrolledIntoView),
  "isSelectable": () => (/* reexport */ isSelectable),
  "isSingleItemSelector": () => (/* reexport */ isSingleItemSelector),
  "isSmallDevice": () => (/* reexport */ isSmallDevice),
  "isStateManager": () => (/* reexport */ TypeCheck/* isStateManager */.bU),
  "isString": () => (/* reexport */ TypeCheck/* isString */.HD),
  "isTouchDevice": () => (/* reexport */ isTouchDevice),
  "isUpperCase": () => (/* reexport */ isUpperCase),
  "isValidable": () => (/* reexport */ isValidable),
  "isView": () => (/* reexport */ isView),
  "linq": () => (/* reexport */ Linq/* linq */.k),
  "linqNode": () => (/* reexport */ linqNode),
  "listOf": () => (/* reexport */ ObservableList_listOf),
  "loadAllAsync": () => (/* reexport */ loadAllAsync),
  "loadImageAsync": () => (/* reexport */ loadImageAsync),
  "loadVideoAsync": () => (/* reexport */ loadVideoAsync),
  "loadVideoIntoAsync": () => (/* reexport */ loadVideoIntoAsync),
  "mergeArrays": () => (/* reexport */ mergeArrays),
  "model": () => (/* reexport */ model),
  "newProp": () => (/* reexport */ newProp),
  "now": () => (/* reexport */ DateUtils_now),
  "observable": () => (/* reexport */ observable),
  "observableListOf": () => (/* reexport */ ObservableList_observableListOf),
  "padLeft": () => (/* reexport */ padLeft),
  "padRight": () => (/* reexport */ padRight),
  "parentOfClass": () => (/* reexport */ parentOfClass),
  "parseDate": () => (/* reexport */ parseDate),
  "randomString": () => (/* reexport */ StringUtils_randomString),
  "registerType": () => (/* reexport */ registerType),
  "removeClass": () => (/* reexport */ DomUtils_removeClass),
  "repeatString": () => (/* reexport */ repeatString),
  "repositoryItems": () => (/* reexport */ repositoryItems),
  "round": () => (/* reexport */ round),
  "runAsync": () => (/* reexport */ Global/* runAsync */.eH),
  "safeCall": () => (/* reexport */ safeCall),
  "safeCallAsync": () => (/* reexport */ safeCallAsync),
  "set": () => (/* reexport */ set),
  "setEnumerable": () => (/* reexport */ setEnumerable),
  "setTypeName": () => (/* reexport */ setTypeName),
  "staticItems": () => (/* reexport */ staticItems),
  "sumNull": () => (/* reexport */ sumNull),
  "template": () => (/* reexport */ Functions_template),
  "timeOfDay": () => (/* reexport */ timeOfDay),
  "today": () => (/* reexport */ today),
  "truncateTime": () => (/* reexport */ truncateTime),
  "uuidv4": () => (/* reexport */ uuidv4)
});

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/StringTable.js
var Core_StringTable = __webpack_require__(7704);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Types/DynamicString.js
var DynamicString = __webpack_require__(9714);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Language/IT.js


Core_StringTable/* StringTable.add */.M.add({
    "msg-upgrading": "aggiornamento alla nuova versione",
    "confirm": "conferma",
    "yes": "si",
    "no": "no",
    "close": "chiudi",
    "day-label": "[Giorno]",
    "month-label": "[Mese]",
    "year-label": "[Anno]",
    "msg-specify-value": DynamicString/* DynamicString.complex */.wI.complex("specificare un valore per '{0}'"),
    "msg-insert-greater-than": DynamicString/* DynamicString.complex */.wI.complex("inserire un valore maggiore o uguale a {0}"),
    "msg-invalid-email": "email non valida",
    "msg-insert-less-than": DynamicString/* DynamicString.complex */.wI.complex("inserire un valore minore o uguale a {0}"),
}, { language: "IT" });

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Global.js
var Global = __webpack_require__(417);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Android/IAndroidInterface.js
function isAndroidApp() {
    return "android" in window;
}

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Linq.js
var Linq = __webpack_require__(9001);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Abstraction/IOperation.js
var IOperation_OperationType;
(function (OperationType) {
    OperationType[OperationType["Global"] = 0] = "Global";
    OperationType[OperationType["Local"] = 1] = "Local";
})(IOperation_OperationType || (IOperation_OperationType = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Abstraction/IOperationManager.js

async function execAsync(action, operation = "Executing") {
    const op = Global/* Services.operation.begin */.K9.operation.begin(operation);
    try {
        return await action(op);
    }
    catch (ex) {
        Global/* Services.application.handleError */.K9.application.handleError(action, ex);
    }
    finally {
        op.end();
    }
}

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Helpers/Format.js
var Helpers_Format = __webpack_require__(1141);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Helpers/Functions.js
function apply(item, block) {
    block(item);
    return item;
}
/****************************************/
function injectProxy(proxy, propName, value) {
    proxy[propName] = value;
    return proxy[propName];
}
/****************************************/
function safeCall(block, errorHandler) {
    try {
        return block();
    }
    catch (e) {
        if (errorHandler)
            return errorHandler(e);
    }
}
/****************************************/
async function safeCallAsync(block, errorHandler) {
    try {
        return await block();
    }
    catch (e) {
        if (errorHandler)
            return Promise.resolve(errorHandler(e));
    }
}

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Helpers/Http.js
var Http = __webpack_require__(7933);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Helpers/TypeCheck.js
var TypeCheck = __webpack_require__(4044);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Helpers/Uri.js
var Helpers_Uri = __webpack_require__(8883);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Services/DbStorage.js
class DbStorage_DbStorage {
    constructor() {
    }
    /****************************************/
    async openAsync(name) {
        return new Promise((res, rej) => {
            const request = indexedDB.open(name, 2);
            request.onerror = ev => rej();
            request.onsuccess = ev => {
                this._database = request.result;
                res(true);
            };
            request.onupgradeneeded = ev => {
                if (!request.result.objectStoreNames.contains("object"))
                    request.result.createObjectStore("object");
                res(true);
            };
        });
    }
    /****************************************/
    openReadWrite() {
        return this._database.transaction("object", "readwrite").objectStore("object");
    }
    /****************************************/
    openRead() {
        return this._database.transaction("object", "readonly").objectStore("object");
    }
    /****************************************/
    setItem(key, value) {
        return new Promise((res, rej) => {
            const request = this.openReadWrite().put(JSON.stringify(value), key);
            request.onerror = ev => rej();
            request.onsuccess = ev => res(request.result);
        });
    }
    /****************************************/
    getItem(key) {
        return new Promise((res, rej) => {
            const request = this.openRead().get(key);
            request.onerror = ev => rej();
            request.onsuccess = ev => {
                res(!request.result ? null : JSON.parse(request.result));
            };
        });
    }
    /****************************************/
    removeItem(key) {
        return new Promise((res, rej) => {
            const request = this.openReadWrite().delete(key);
            request.onerror = ev => rej();
            request.onsuccess = ev => res();
        });
    }
    /****************************************/
    clear(key) {
        return new Promise((res, rej) => {
            const request = this.openReadWrite().clear();
            request.onerror = ev => rej();
            request.onsuccess = ev => res();
        });
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/StringUtils.js
function StringUtils_randomString(length, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") {
    let result = "";
    for (let i = 0; i < length; i++)
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    return result;
}
/****************************************/
function isUpperCase(value) {
    return value.toUpperCase() === value;
}
/****************************************/
function repeatString(value, count) {
    let result = "";
    for (let i = 0; i < count; i++)
        result += value;
    return result;
}
/****************************************/
function padLeft(value, count, char) {
    if (value == null)
        return;
    if (value.length >= count)
        return value;
    return repeatString(char, count - value.length) + value;
}
/****************************************/
function padRight(value, count, char) {
    if (value == null)
        return;
    if (value.length >= count)
        return value;
    return value + repeatString(char, count - value.length);
}
/****************************************/
function uuidv4() {
    if ("crypto" in window && "randomUUID" in crypto)
        return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Types/TimeSpan.js


var TimePart;
(function (TimePart) {
    TimePart[TimePart["Milliseconds"] = 0] = "Milliseconds";
    TimePart[TimePart["Seconds"] = 1] = "Seconds";
    TimePart[TimePart["Minutes"] = 2] = "Minutes";
    TimePart[TimePart["Hours"] = 3] = "Hours";
    TimePart[TimePart["Days"] = 4] = "Days";
})(TimePart || (TimePart = {}));
class TimeSpan_TimeSpan {
    constructor(ticks = 0) {
        this.ticks = ticks;
    }
    /****************************************/
    get totalDays() {
        return this.ticks / (1000 * 60 * 60 * 24);
    }
    /****************************************/
    get totalHours() {
        return this.ticks / (1000 * 60 * 60);
    }
    /****************************************/
    get totalMinutes() {
        return this.ticks / (1000 * 60);
    }
    /****************************************/
    get totalSeconds() {
        return this.ticks / (1000);
    }
    /****************************************/
    get totalMilliseconds() {
        return this.ticks;
    }
    /****************************************/
    get days() {
        return Math.floor(this.ticks / (1000 * 60 * 60 * 24));
    }
    /****************************************/
    get hours() {
        return Math.floor(this.ticks / (1000 * 60 * 60)) % 24;
    }
    /****************************************/
    get minutes() {
        return Math.floor(this.ticks / (1000 * 60)) % 60;
    }
    /****************************************/
    get seconds() {
        return Math.floor(this.ticks / (1000)) % 60;
    }
    /****************************************/
    get milliseconds() {
        return this.ticks % 1000;
    }
    /****************************************/
    format(format) {
        return Helpers_Format/* Format.replaceArgs */.E.replaceArgs(format, arg => TimeSpan_TimeSpan.formatArgument(this, arg));
    }
    /****************************************/
    toString() {
        return this.format("{hh}:{mm}:{ss}");
    }
    /****************************************/
    static zero() {
        return new TimeSpan_TimeSpan(0);
    }
    /****************************************/
    static fromMilliseconds(value) {
        return new TimeSpan_TimeSpan(value);
    }
    /****************************************/
    static fromSeconds(value) {
        return new TimeSpan_TimeSpan(value * 1000);
    }
    /****************************************/
    static fromMinutes(value) {
        return new TimeSpan_TimeSpan(value * 1000 * 60);
    }
    /****************************************/
    static fromHours(value) {
        return new TimeSpan_TimeSpan(value * 1000 * 60 * 60);
    }
    /****************************************/
    static fromDays(value) {
        return new TimeSpan_TimeSpan(value * 1000 * 60 * 60 * 24);
    }
    /****************************************/
    static create(days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0) {
        return new TimeSpan_TimeSpan((days * 1000 * 60 * 60 * 24) +
            (hours * 1000 * 60 * 60) +
            (minutes * 1000 * 60) +
            (seconds * 1000) +
            (milliseconds));
    }
    /****************************************/
    static formatArgument(value, arg) {
        switch (arg) {
            case "d":
                return value.days.toString();
            case "dd":
                return padLeft(value.days.toString(), 2, "0");
            case "h":
                return value.hours.toString();
            case "hh":
                return padLeft(value.hours.toString(), 2, "0");
            case "m":
                return value.minutes.toString();
            case "mm":
                return padLeft(value.minutes.toString(), 2, "0");
            case "s":
                return value.seconds.toString();
            case "ss":
                return padLeft(value.seconds.toString(), 2, "0");
            case "f":
                return (value.milliseconds / 100).toString();
            case "ff":
                return (value.milliseconds / 10).toString();
            case "fff":
                return value.milliseconds.toString();
        }
        return arg;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/DateUtils.js



const WEEK_DAYS = ["Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato", "Domenica"];
const MONTHS = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"];
/****************************************/
function parseDate(value) {
    if (value instanceof Date)
        return value;
    return new Date(value);
}
/****************************************/
function addDays(date, value) {
    return dateAdd(date, TimeSpan_TimeSpan.fromDays(value));
}
/****************************************/
function dateAdd(date, value) {
    date = parseDate(date);
    return new Date(date.getTime() + value.ticks);
}
/****************************************/
function dateDiff(date1, date2) {
    return new TimeSpan_TimeSpan(parseDate(date1).getTime() - parseDate(date2).getTime());
}
/****************************************/
function DateUtils_now() {
    return new Date();
}
/****************************************/
function isSameDay(dateA, dateB) {
    return truncateTime(dateA).getTime() == truncateTime(dateB).getTime();
}
/****************************************/
function today() {
    return truncateTime(DateUtils_now());
}
/****************************************/
function truncateTime(date) {
    date = parseDate(date);
    return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}
/****************************************/
function timeOfDay(date) {
    date = parseDate(date);
    return new TimeSpan_TimeSpan(date.getTime() - truncateTime(date).getTime());
}
/****************************************/
function formatDate(date, format) {
    date = parseDate(date);
    return Helpers_Format/* Format.replaceArgs */.E.replaceArgs(Helpers_Format/* Format.text */.E.text(format), arg => formatDateArgument(date, arg));
}
/****************************************/
function formatDateArgument(value, arg) {
    value = parseDate(value);
    switch (arg) {
        case "D":
            return value.getDate().toString();
        case "DD":
            return padLeft(value.getDate().toString(), 2, "0");
        case "W":
            return WEEK_DAYS[(value.getDay() + 6) % 7].substr(0, 3);
        case "WW":
            return WEEK_DAYS[(value.getDay() + 6) % 7];
        case "M":
            return value.getMonth().toString();
        case "MM":
            return padLeft((value.getMonth() + 1).toString(), 2, "0");
        case "MMM":
            return MONTHS[value.getMonth()].substr(0, 3);
        case "MMMM":
            return MONTHS[value.getMonth()];
        case "YY":
            return value.getFullYear().toString().substr(2);
        case "YYYY":
            return value.getFullYear().toString();
        case "h":
            return value.getHours().toString();
        case "hh":
            return padLeft(value.getHours().toString(), 2, "0");
        case "m":
            return value.getMinutes().toString();
        case "mm":
            return padLeft(value.getMinutes().toString(), 2, "0");
        case "s":
            return value.getSeconds().toString();
        case "ss":
            return padLeft(value.getSeconds().toString(), 2, "0");
        case "f":
            return (value.getMilliseconds() / 100).toString();
        case "ff":
            return (value.getMilliseconds() / 10).toString();
        case "fff":
            return value.getMilliseconds().toString();
    }
    return arg;
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Services/LocalStorageCache.js

class LocalStorageCache_LocalStorageCache {
    read(key) {
        const entryJson = localStorage.getItem("cache:" + key);
        if (entryJson) {
            const entry = JSON.parse(entryJson);
            entry.readCount++;
            entry.lastReadTime = DateUtils_now();
            localStorage.setItem("cache:" + key, JSON.stringify(entry));
            return entry;
        }
        return null;
    }
    /****************************************/
    update(key, value) {
        let entry = this.read(key);
        if (!entry) {
            entry = {
                creationTime: DateUtils_now(),
                key: key,
                lastReadTime: null,
                lastWriteTime: null,
                value: value,
                readCount: 0,
                writeCount: 0
            };
        }
        else {
            entry.writeCount++;
            entry.lastWriteTime = DateUtils_now();
            entry.value = value;
        }
        localStorage.setItem("cache:" + key, JSON.stringify(entry));
        return entry;
    }
    /****************************************/
    remove(key) {
        localStorage.removeItem("cache:" + key);
    }
    /****************************************/
    clear() {
        for (let i = localStorage.length - 1; i >= 0; i--) {
            const key = localStorage.key(i);
            if (key.startsWith("cache:"))
                localStorage.removeItem(key);
        }
    }
    /****************************************/
    contains(key) {
        return localStorage.getItem("cache:" + key) != null;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Types/Exception.js
class Exception_Exception extends Error {
    constructor(message, innerException) {
        super();
        this.message = message;
        this.innerException = innerException;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Services/XHRHttpClient.js




class HttpException extends Exception_Exception {
    constructor(request, status, innerException) {
        super("HTTP error, status code: " + status, innerException);
        this.request = request;
    }
}
/****************************************/
class XHRHttpClient_XHRHttpClient {
    onNewRequest(config) {
    }
    /****************************************/
    requestAsync(config) {
        this.onNewRequest(config);
        return new Promise((resolve, reject) => {
            const xmlhttp = new XMLHttpRequest();
            let curOperation;
            if (Global/* Services.operation */.K9.operation) {
                curOperation = Global/* Services.operation.begin */.K9.operation.begin({
                    message: config.method + " " + config.url,
                    type: IOperation_OperationType.Local
                });
            }
            xmlhttp.onreadystatechange = ev => {
                if (xmlhttp.readyState == XMLHttpRequest.DONE) {
                    if (curOperation)
                        curOperation.end();
                    if (xmlhttp.status == 200) {
                        let data = xmlhttp.responseText;
                        const isJson = config.responseType == "application/json";
                        if (isJson)
                            data = JSON.parse(data);
                        resolve(data);
                    }
                    else
                        reject(new HttpException(config, xmlhttp.status));
                }
            };
            if (config.onProgress)
                xmlhttp.upload.onprogress = ev => {
                    const result = config.onProgress(ev);
                    if (!result)
                        xmlhttp.abort();
                };
            xmlhttp.open(config.method, Helpers_Uri/* Uri.absolute */.S.absolute(config.url), true);
            let contentType = config.dataType;
            let data = config.data;
            if (config.data) {
                const isJson = contentType == "application/json" || typeof config.data == "object";
                const isObj = contentType == "application/octet-stream";
                if (isJson && !isObj) {
                    contentType = "application/json";
                    if (data && typeof config.data != "string")
                        data = JSON.stringify(data);
                }
            }
            if (contentType)
                xmlhttp.setRequestHeader("Content-type", contentType);
            if (config.headers) {
                for (const header in config.headers)
                    xmlhttp.setRequestHeader(header, config.headers[header]);
            }
            xmlhttp.send(data);
        });
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Services/GoogleAnalytics.js
/****************************************/
class GoogleAnalytics_GoogleAnalytics {
    constructor(gaId) {
        this.gaId = gaId !== null && gaId !== void 0 ? gaId : window["__gaid"];
        if (!("gtag" in window))
            window["gtag"] = () => { };
    }
    /****************************************/
    pageView(uri) {
        gtag("config", this.gaId, { page_path: uri });
    }
    /****************************************/
    action(name, data) {
        gtag("event", name, {
            event_category: 'Action',
            event_label: data
        });
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Services/LocalDbRepository.js
/****************************************/
class LocalDbRrepositoy {
    constructor(config) {
        this._config = config;
        if (config.getObjectId)
            this.getObjectId = config.getObjectId;
    }
    /****************************************/
    getObjectId(obj) {
        return obj["id"];
    }
    /****************************************/
    openOrCreateAsync() {
        if (this._database)
            return;
        return new Promise((res, rej) => {
            const request = indexedDB.open(this._config.dbName, 2);
            request.onerror = ev => rej();
            request.onsuccess = ev => {
                this._database = request.result;
                res(true);
            };
            request.onupgradeneeded = ev => {
                if (!request.result.objectStoreNames.contains(this._config.tableName))
                    request.result.createObjectStore(this._config.tableName);
                //this._database = request.result;
                //res(true);
            };
        });
    }
    /****************************************/
    async beginTransactionAsync(readwrite = true) {
        await this.openOrCreateAsync();
        return this._database.transaction(this._config.tableName, readwrite ? "readwrite" : "readonly").objectStore(this._config.tableName);
    }
    /****************************************/
    async requestAsync(action, readwrite = true) {
        const store = await this.beginTransactionAsync(readwrite);
        return new Promise((res, rej) => {
            const request = action(store);
            request.onerror = ev => rej();
            request.onsuccess = ev => res(request.result);
        });
    }
    /****************************************/
    async listAsync(filter) {
        const items = await this.requestAsync(store => store.getAll());
        return items;
    }
    /****************************************/
    async getByIdAsync(id) {
        const item = await this.requestAsync(store => store.get(id));
        return item;
    }
    /****************************************/
    async deleteByIdAsync(id) {
        await this.requestAsync(store => store.delete(id));
        return true;
    }
    /****************************************/
    async addAsync(obj) {
        const key = await this.requestAsync(store => store.add(obj, this.getObjectId(obj)));
        return key;
    }
    /****************************************/
    async updateAsync(obj, id) {
        const curItem = await this.getByIdAsync(id);
        Object.assign(curItem, obj);
        await this.requestAsync(store => store.put(obj, id));
        return true;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Types/Event.js
class AppEvent {
    constructor(awaitHandler = false) {
        if (awaitHandler)
            this._awaitHandler = true;
    }
    add(handler) {
        if (!this._handlers)
            this._handlers = [];
        if (this._handlers.indexOf(handler) == -1)
            this._handlers.push(handler);
        return handler;
    }
    remove(handler) {
        if (this._handlers) {
            const index = this._handlers.indexOf(handler);
            if (index != -1)
                this._handlers.splice(index, 1);
        }
    }
    async raise(sender, data) {
        if (this._handlers) {
            for (const handler of this._handlers) {
                const result = handler(sender, data);
                if (this._awaitHandler && result instanceof Promise)
                    await result;
            }
        }
    }
    get hasHandlers() { var _a; return ((_a = this._handlers) === null || _a === void 0 ? void 0 : _a.length) > 0; }
    ;
}
function Event_event(awaitHandler = false) {
    return new AppEvent(awaitHandler);
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Types/Signal.js
class Signal_Signal {
    /****************************************/
    constructor(isSet = false, autoReset = true) {
        this._waitHandlers = [];
        this._isSet = isSet;
        this._autoReset = autoReset;
    }
    /****************************************/
    set() {
        this._isSet = true;
        for (let i = this._waitHandlers.length - 1; i >= 0; i--)
            this._waitHandlers[i](true);
    }
    /****************************************/
    reset() {
        this._isSet = false;
    }
    /****************************************/
    waitFor(timeout) {
        if (this._isSet) {
            if (this._autoReset && this._waitHandlers.length == 0)
                this.reset();
            return Promise.resolve(true);
        }
        return new Promise((res) => {
            const handler = isSuccess => {
                res(isSuccess);
                const index = this._waitHandlers.indexOf(handler);
                if (index != -1)
                    this._waitHandlers.splice(index, 1);
                if (this._waitHandlers.length == 0 && this._autoReset)
                    this.reset();
            };
            if (timeout) {
                setTimeout(() => {
                    const index = this._waitHandlers.indexOf(handler);
                    if (index != -1) {
                        this._waitHandlers.splice(index, 1);
                        res(false);
                    }
                }, timeout.totalMilliseconds);
            }
            this._waitHandlers.push(handler);
        });
    }
    /****************************************/
    get isSet() {
        return this._isSet;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/ObjectUtils.js


function isEmpty(value) {
    return value === undefined || value === null || (Array.isArray(value) && value.length == 0);
}
/****************************************/
function equals(valueA, valueB) {
    if (Array.isArray(valueA) || Array.isArray(valueB))
        return equalsArray(valueA, valueB);
    return valueA == valueB;
}
/****************************************/
function createInstance(typeName, ...args) {
    const parts = typeName.split(".");
    let curType = window;
    for (const part of parts)
        curType = curType[part];
    return new curType(...args);
}
/****************************************/
function hasProp(obj, propName) {
    return (propName in obj);
}
/****************************************/
function isInstanceOf(obj, type) {
    if (!obj)
        return;
    let curType = getType(obj);
    while (curType != null) {
        if (curType == type)
            return true;
        curType = getBaseType(curType);
    }
    return false;
}
/****************************************/
function getOrCreateProperty(obj, propName, value) {
    const desc = Object.getOwnPropertyDescriptor(obj, propName);
    if (!desc) {
        createProperty(obj, propName, value);
        return value;
    }
    return get(obj, propName);
}
/****************************************/
function createProperty(obj, propName, value) {
    if (propName.substr(0, 1) == "@") {
        Object.defineProperty(obj, propName, {
            writable: true,
            enumerable: false,
            value: value
        });
    }
    else {
        Object.defineProperty(obj, propName, {
            value: value
        });
    }
}
/****************************************/
function get(obj, propName, defValue) {
    if (!obj)
        return defValue;
    const value = obj[propName];
    if (value === undefined || value === null)
        return defValue;
    return value;
}
/****************************************/
function set(obj, propName, value) {
    if (propName.substr(0, 1) == "@") {
        const desc = Object.getOwnPropertyDescriptor(obj, propName);
        if (!desc)
            createProperty(obj, propName, value);
        else
            obj[propName] = value;
    }
    else
        obj[propName] = value;
}
/****************************************/
function setTypeName(obj, name) {
    if ((0,TypeCheck/* isObject */.Kn)(obj))
        set(obj, "@typeName", name);
    else
        set(Object.getPrototypeOf(obj), "@typeName", name);
}
/****************************************/
function getTypeName(obj) {
    if (!obj)
        return undefined;
    let name = obj["@typeName"];
    if (!name) {
        name = typeof obj;
        if (name == "function")
            return getFunctionName(obj);
        if (name == "object") {
            const constFunc = obj.constructor;
            if (constFunc)
                return getTypeName(constFunc);
        }
    }
    return name;
}
function getBaseType(objOrFun) {
    let proto;
    if ((0,TypeCheck/* isFunction */.mf)(objOrFun))
        proto = objOrFun.prototype;
    else
        proto = Object.getPrototypeOf(objOrFun);
    return Object.getPrototypeOf(proto).constructor;
}
function getType(typeOrName) {
    if ((0,TypeCheck/* isString */.HD)(typeOrName)) {
        const parts = typeOrName.split(".");
        let curObj = self;
        parts.forEach(part => {
            curObj = curObj[part];
            if (!curObj)
                return null;
        });
        return curObj;
    }
    return typeOrName.constructor;
}
/****************************************/
function getFunctionName(func) {
    let curName = func.name;
    if (!curName) {
        const funcNameRegex = /function\s([^(]{1,})\(/;
        const results = (funcNameRegex).exec(func.toString());
        curName = (results && results.length > 1) ? results[1].trim() : "";
    }
    return curName;
}
/****************************************/
function clone(obj) {
    if ((0,TypeCheck/* isCloneable */._p)(obj))
        return obj.clone();
    return JSON.parse(JSON.stringify(obj));
}
/****************************************/
function registerType(type, name) {
    set(type, "@typeName", name);
}

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/PromiseUtils.js
var PromiseUtils = __webpack_require__(1464);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/ArrayUtils.js


function equalsArray(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b))
        return false;
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (!equals(a[i], b[i]))
            return false;
    }
    return true;
}
/****************************************/
async function forEachAsync(items, chunkSize, action) {
    let index = 0;
    for (const item of items) {
        action(item, index);
        if (index % chunkSize == 0)
            await (0,PromiseUtils/* delayAsync */.$)(0);
        index++;
    }
}
/****************************************/
function mergeArrays(...args) {
    const result = [];
    for (const item of args) {
        if (!item)
            continue;
        result.push(...item);
    }
    return result;
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/DomUtils.js


class LinqNode {
    constructor(node) {
        this.node = node;
    }
    /****************************************/
    get childNodes() {
        return (0,Linq/* linq */.k)(this.node.childNodes).select(a => new LinqNode(a));
    }
    /****************************************/
    descendsFrom(target) {
        let curItem = this.node;
        while (curItem != null) {
            if (curItem == target)
                return true;
            curItem = curItem.parentNode;
        }
        return false;
    }
    /****************************************/
    hasClass(className) {
        if ("classList" in this.node)
            return this.node.classList.contains(className);
        return false;
    }
    /****************************************/
    get discendants() {
        function* iterator(node) {
            for (const child of this.node.childNodes) {
                yield new LinqNode(child);
                for (const innerChild of iterator(child))
                    yield innerChild;
            }
            ;
        }
        return (0,Linq/* linq */.k)(iterator(this.node));
    }
    /****************************************/
    get parentNodesOrSelf() {
        function* iterator(node) {
            let curItem = node;
            while (curItem != null) {
                yield new LinqNode(curItem);
                curItem = curItem.parentNode;
            }
        }
        return (0,Linq/* linq */.k)(iterator(this.node));
    }
    /****************************************/
    get parentNodes() {
        return this.parentNodesOrSelf.skip(1);
    }
    /****************************************/
    get name() {
        return this.node.nodeName;
    }
}
/****************************************/
function parentOfClass(src, className) {
    return linqNode(src).parentNodes.where(a => a.hasClass(className)).select(a => a.node).first();
}
/****************************************/
function linqNode(src) {
    return new LinqNode(src);
}
/****************************************/
function isParentOrSelf(element, parent) {
    let curElement = element;
    while (curElement) {
        if (curElement == parent)
            return true;
        curElement = curElement.parentElement;
    }
    return false;
}
/****************************************/
function generateNodeId(base = "id_") {
    while (true) {
        const curId = base + StringUtils_randomString(8);
        if (!document.getElementById(curId))
            return curId;
    }
}
/****************************************/
function DomUtils_removeClass(element, className) {
    if (element.classList.contains(className))
        element.classList.remove(className);
}
/****************************************/
function DomUtils_addClass(element, className) {
    if (!element.classList.contains(className))
        element.classList.add(className);
}
/****************************************/
function isTouchDevice() {
    return ("ontouchstart" in window) ||
        (navigator.maxTouchPoints > 0);
}
/****************************************/
function isSmallDevice() {
    return window.innerWidth < 610;
}
/****************************************/
async function copyText(value) {
    if (navigator["clipboard"])
        await navigator.clipboard.writeText(value);
    else {
        const input = document.createElement("textarea");
        document.body.appendChild(input);
        input.value = value;
        input.select();
        //input.setSelectionRange(0, input.value.length);
        document.execCommand("copy");
        document.body.removeChild(input);
    }
}
/****************************************/
function getScrollParent(element) {
    if (!element)
        return null;
    if (element.scrollHeight > element.clientHeight)
        return element;
    return getScrollParent(element.parentElement);
}
/****************************************/
function isScrolledIntoView(element) {
    const scrollParent = getScrollParent(element);
    if (!scrollParent)
        return true;
    const scrollTop = scrollParent.scrollTop;
    const scrollBottom = scrollTop + scrollParent.clientHeight;
    const elemTop = element.offsetTop;
    const elemBottom = element.clientHeight + elemTop;
    return elemTop < scrollBottom && elemBottom > scrollTop;
}
/****************************************/
function centerElement(element, always = true) {
    const topOfPage = document.documentElement.scrollTop;
    const heightOfPage = window.innerHeight;
    let elY = 0;
    let elH = 0;
    for (let p = element; p && p != document.body; p = p.offsetParent)
        elY += p.offsetTop;
    elH = element.offsetHeight;
    if (always || elY + elH > topOfPage + heightOfPage || elY < topOfPage)
        document.documentElement.scrollTop = Math.max(0, elY - (heightOfPage - elH) / 2);
    return elY - document.documentElement.scrollTop;
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/Identifier.js
const idMap = {};
function generateId(base) {
    if (!base)
        base = "item";
    if (idMap[base] === undefined)
        idMap[base] = 0;
    idMap[base]++;
    if (idMap[base] == 1)
        return base;
    return base + idMap[base];
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/MathUtils.js
function discretize(value, steps) {
    if (isNaNOrNull(value))
        return undefined;
    return Math.round(value * steps) / steps;
}
/****************************************/
function round(value, digits) {
    if (isNaNOrNull(value))
        return undefined;
    return Math.round(value * Math.pow(10, digits)) / Math.pow(10, digits);
}
/****************************************/
function exponential(value, weight = 2) {
    if (isNaNOrNull(value))
        return undefined;
    return 1 - Math.pow(1 - value, weight);
}
/****************************************/
function isNaNOrNull(a) {
    return isNaN(a) || a === null;
}
/****************************************/
function sumNull(a, b) {
    if (isNaNOrNull(a) && isNaNOrNull(b))
        return undefined;
    if (isNaNOrNull(b))
        return a;
    if (isNaNOrNull(a))
        return b;
    return a + b;
}
/****************************************/
function divideNull(a, b) {
    if (isNaNOrNull(a) || isNaNOrNull(b) || b == 0)
        return undefined;
    return a / b;
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Core/Utils/PositionUtils.js
function getPostionAsync(options) {
    return new Promise((res, rej) => {
        navigator.geolocation.getCurrentPosition(pos => res(pos.coords), err => rej(err.message), options);
    });
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/ComputedProperty.js

class ComputedProperty {
    /****************************************/
    constructor(getter, name) {
        this.isReadOnly = true;
        this.get = getter;
        this.name = name;
    }
    /****************************************/
    get() {
        throw "Not implemented";
    }
    /****************************************/
    set(value) {
        //throw "Not supported";
    }
    /****************************************/
    notifyChanged() {
        const value = this.get();
        forEachRev(this._handlers, handler => handler(value, undefined));
    }
    /****************************************/
    subscribe(handler) {
        if (!this._handlers)
            this._handlers = [];
        const index = this._handlers.indexOf(handler);
        if (index == -1)
            this._handlers.push(handler);
        return handler;
    }
    /****************************************/
    unsubscribe(handler) {
        if (!this._handlers)
            return;
        const index = this._handlers.indexOf(handler);
        if (index != -1)
            this._handlers.splice(index, 1);
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/ObservableProperty.js

class ObservableProperty_ObservableProperty {
    /****************************************/
    constructor(desc, name) {
        this._descriptor = desc;
        this.name = name;
    }
    /****************************************/
    get() {
        if (this._descriptor.get)
            return this._descriptor.get();
        return this._descriptor.value;
    }
    /****************************************/
    set(value) {
        const oldValue = this.get();
        if (this._descriptor.set)
            this._descriptor.set(value);
        else
            this._descriptor.value = value;
        if (oldValue != value && this._handlers) {
            forEachRev(this._handlers, handler => handler(value, oldValue));
        }
    }
    /****************************************/
    notifyChanged() {
        const value = this.get();
        forEachRev(this._handlers, handler => handler(value, undefined));
    }
    /****************************************/
    subscribe(handler) {
        if (!this._handlers)
            this._handlers = [];
        const index = this._handlers.indexOf(handler);
        if (index == -1)
            this._handlers.push(handler);
        return handler;
    }
    /****************************************/
    unsubscribe(handler) {
        if (!this._handlers)
            return;
        const index = this._handlers.indexOf(handler);
        if (index != -1)
            this._handlers.splice(index, 1);
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/Properties.js



/****************************************/
function newProp(name, value, onChanged) {
    const result = new ObservableProperty_ObservableProperty({
        value: value
    }, name);
    if (onChanged)
        result.subscribe(onChanged);
    return result;
}
/****************************************/
var Properties_Properties;
(function (Properties) {
    function converter(obj, propName, convert, convertBack) {
        let conValue;
        return {
            get: () => {
                if (conValue == undefined)
                    conValue = convert(obj[propName]);
                return conValue;
            },
            set: value => {
                conValue = value;
                if (convertBack)
                    obj[propName] = convertBack(value);
            },
            name: propName
        };
    }
    Properties.converter = converter;
    /****************************************/
    function create(obj, propName, property) {
        let desc = Object.getOwnPropertyDescriptor(obj, propName);
        if (!desc) {
            console.warn("'", propName, "' not defined in ", getTypeName(obj));
            desc = {};
        }
        if (!property)
            property = new ObservableProperty_ObservableProperty(desc, propName);
        const props = getOrCreateProperty(obj, "@props", {});
        props[propName] = property;
        Object.defineProperty(obj, propName, {
            get: () => property.get(),
            set: (newValue) => property.set(newValue)
        });
        return property;
    }
    Properties.create = create;
    /****************************************/
    function createAll(obj) {
        const props = Object.getOwnPropertyNames(obj);
        props.forEach(propName => {
            if (propName[0] == "_" || propName[0] == "$")
                return;
            const propDesc = Object.getOwnPropertyDescriptor(obj, propName);
            if (propDesc && !propDesc.writable)
                return;
            create(obj, propName);
        });
        return obj;
    }
    Properties.createAll = createAll;
    /****************************************/
    function get(obj, propName) {
        if (hasProp(obj, "@props")) {
            const prop = obj["@props"][propName];
            if (prop)
                return prop;
        }
        return undefined;
    }
    Properties.get = get;
    /****************************************/
    function getOrCreate(obj, propName, property) {
        const prop = get(obj, propName);
        if (prop)
            return prop;
        return create(obj, propName, property);
    }
    Properties.getOrCreate = getOrCreate;
    /****************************************/
    function isProperty(obj) {
        return (obj && typeof obj == "object" && typeof obj["get"] == "function" && obj["get"].length == 0 && typeof obj["set"] == "function" && obj["set"].length == 1);
    }
    Properties.isProperty = isProperty;
    /****************************************/
    function isObservableProperty(obj) {
        //TODO improve this check
        return obj instanceof ObservableProperty_ObservableProperty || obj instanceof ComputedProperty;
    }
    Properties.isObservableProperty = isObservableProperty;
    /****************************************/
    function bind(dest, src, converter) {
        let value;
        if (isProperty(src)) {
            if (isObservableProperty(src)) {
                src.subscribe(value => {
                    if (converter)
                        dest.set(converter.convertTo(value));
                    else
                        dest.set(value);
                });
            }
            dest.subscribe(value => {
                if (converter)
                    src.set(converter.convertFrom(value));
                else
                    src.set(value);
            });
            value = src.get();
        }
        else
            value = src;
        if (converter)
            dest.set(converter.convertTo(value));
        else
            dest.set(value);
        return undefined;
    }
    Properties.bind = bind;
})(Properties_Properties || (Properties_Properties = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/Binder.js


/****************************************/
class Binder {
    /****************************************/
    constructor(model) {
        this._bindings = [];
        this._modelBinders = [];
        this._depBinders = [];
        this.model = model;
    }
    /****************************************/
    register(binder) {
        this._modelBinders.push(binder);
    }
    /****************************************/
    registerDependant(binder) {
        this._depBinders.push(binder);
    }
    /****************************************/
    unregisterDependant(binder) {
        const index = this._depBinders.indexOf(binder);
        if (index != -1)
            this._depBinders.splice(index, 1);
    }
    /****************************************/
    getBindValue(value) {
        if (typeof value == "function")
            return value(this.model);
        return value;
    }
    /****************************************/
    bind(value, action) {
        if (typeof value == "function") {
            const binding = {
                value: value,
                action: action,
                subscriptions: [],
                lastValue: undefined
            };
            this._bindings.push(binding);
            binding.value(this.createProxy(this.model, (obj, propName) => {
                this.subscribe(obj, propName, binding);
                return true;
            }));
            const bindValue = binding.value(this.model);
            binding.action(bindValue, undefined, false);
            binding.lastValue = bindValue;
        }
        else
            action(value, undefined, false);
    }
    /****************************************/
    unsubscribe(binding, cleanValue) {
        binding.subscriptions.forEach(sub => {
            if ((0,TypeCheck/* isObservableList */.Ex)(sub.source))
                sub.source.unsubscribe(sub.handler);
            else
                sub.property.unsubscribe(sub.handler);
        });
        if (cleanValue && binding.lastValue) {
            binding.action(null, binding.lastValue, true, true);
            binding.lastValue = null;
        }
        binding.subscriptions = [];
    }
    /****************************************/
    subscribe(obj, propName, binding) {
        for (let i = 0; i < binding.subscriptions.length; i++) {
            const sub = binding.subscriptions[i];
            if (sub.source == obj && sub.property.name == propName)
                return;
        }
        if ((0,TypeCheck/* isObservableList */.Ex)(obj)) {
            const handler = {
                onChanged: () => {
                    const bindValue = binding.value(this.model);
                    if (bindValue == binding.lastValue)
                        return;
                    binding.action(bindValue, binding.lastValue, true);
                    binding.lastValue = bindValue;
                }
            };
            obj.subscribe(handler);
            binding.subscriptions.push({
                source: obj,
                property: null,
                handler: handler
            });
        }
        else {
            const propDesc = Object.getOwnPropertyDescriptor(obj, propName);
            if (!propDesc || (!propDesc.writable && !propDesc.set)) {
                console.warn("Property ", propName, " for object ", obj, " not exists or is not writeable.");
                return;
            }
            const prop = Properties_Properties.getOrCreate(obj, propName);
            const handler = (value, oldValue) => {
                const bindValue = binding.value(this.model);
                if (bindValue == binding.lastValue)
                    return;
                this.unsubscribe(binding, false);
                binding.value(this.createProxy(this.model, (obj, propName) => {
                    this.subscribe(obj, propName, binding);
                    return true;
                }));
                binding.action(bindValue, binding.lastValue, true);
                binding.lastValue = bindValue;
            };
            prop.subscribe(handler);
            binding.subscriptions.push({
                source: obj,
                property: prop,
                handler: handler
            });
        }
    }
    /****************************************/
    getBindingProperty(value) {
        if (typeof value != "function")
            return null;
        let lastProp;
        value(this.createProxy(this.model, (obj, propName) => {
            lastProp = {
                obj: obj,
                propName: propName
            };
            return true;
        }));
        if (lastProp && lastProp.obj)
            return Properties_Properties.getOrCreate(lastProp.obj, lastProp.propName);
    }
    /****************************************/
    createProxy(obj, action) {
        if (!obj || typeof (obj) != "object")
            return obj;
        const propList = [];
        const proxy = {};
        if ((0,TypeCheck/* isObservableList */.Ex)(obj)) {
            const listProxy = proxy;
            propList.push("count");
            listProxy._innerProxies = {};
            listProxy.get = (index) => {
                if (!(index in listProxy._innerProxies)) {
                    if (action(obj, index.toString()))
                        listProxy._innerProxies[index] = this.createProxy(obj.get(index), action);
                    else
                        listProxy._innerProxies[index] = obj.get(index);
                }
                return listProxy._innerProxies[index];
            };
        }
        else {
            for (const propName in obj)
                propList.push(propName);
        }
        for (const propName of propList) {
            let innerProxy;
            let isInit = false;
            let lastValueSet;
            Object.defineProperty(proxy, propName, {
                get: () => {
                    if (!isInit) {
                        if (action(obj, propName))
                            innerProxy = this.createProxy(obj[propName], action);
                        else
                            innerProxy = obj[propName];
                        isInit = true;
                    }
                    return innerProxy;
                },
                set: value => {
                    if (lastValueSet == value)
                        return;
                    if (action(obj, propName))
                        innerProxy = this.createProxy(value, action);
                    else
                        innerProxy = value;
                    lastValueSet = value;
                    isInit = true;
                }
            });
        }
        return proxy;
    }
    /****************************************/
    cleanBindings(cleanValue) {
        this._bindings.forEach(binding => this.unsubscribe(binding, cleanValue));
        this._modelBinders.forEach(binder => binder.cleanBindings(cleanValue));
        this._depBinders.forEach(binder => binder.cleanBindings(cleanValue));
        this._modelBinders = [];
        this._bindings = [];
        this._depBinders = [];
    }
    /****************************************/
    updateModel(model) {
        this.model = model;
        forEachRev(this._bindings, binding => {
            const value = binding.value(model);
            if (binding.lastValue == value)
                return;
            binding.action(value, binding.lastValue, true);
            binding.lastValue = value;
        });
        forEachRev(this._modelBinders, binder => binder.updateModel(model));
    }
}
/****************************************/
function forEachRev(items, action) {
    if (!items || items.length == 0)
        return;
    for (let i = items.length - 1; i >= 0; i--)
        action(items[i]);
}
/****************************************/
async function forEachRevAsync(items, action) {
    if (!items || items.length == 0)
        return;
    for (let i = items.length - 1; i >= 0; i--)
        await action(items[i]);
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/BindableObject.js




class BindableObject_BindableObject {
    prop(propName) {
        return Properties_Properties.getOrCreate(this, propName);
    }
    /****************************************/
    static bindValue(value) {
        if (Properties_Properties.isProperty(value))
            return value.get();
        return value;
    }
    /****************************************/
    bindConfig(propName, config, converter, onValueChanged) {
        this.bind(propName, config && propName in config ? config[propName] : undefined, converter, onValueChanged);
    }
    /****************************************/
    bindConfigString(propName, config, configOrUsage, onValueChanged) {
        this.bindString(propName, config && propName in config ? config[propName] : undefined, configOrUsage, onValueChanged);
    }
    /****************************************/
    computed(propName, compute) {
        return Properties_Properties.create(this, propName, this.createComputed(compute, propName));
    }
    /****************************************/
    createComputed(compute, name) {
        if (!this._computedBinder)
            this._computedBinder = new Binder(this);
        const prop = new ComputedProperty(() => compute(this), name);
        this._computedBinder.bind(compute, () => prop.notifyChanged());
        return prop;
    }
    /****************************************/
    bind(propName, value, converter, onValueChanged) {
        const prop = Properties_Properties.getOrCreate(this, propName);
        if (onValueChanged)
            prop.subscribe(onValueChanged);
        if (value !== undefined)
            Properties_Properties.bind(prop, value, converter);
    }
    /****************************************/
    bindString(propName, value, configOrUsage, onValueChanged) {
        return this.bind(propName, value, {
            convertTo: a => DynamicString/* DynamicString.getValue */.wI.getValue(a, configOrUsage),
            convertFrom: a => a
        }, onValueChanged);
    }
    /****************************************/
    apply(block) {
        block(this);
        return this;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Abstraction/IMapManager.js
var IMapManager_MapShapeType;
(function (MapShapeType) {
    MapShapeType[MapShapeType["None"] = 0] = "None";
    MapShapeType[MapShapeType["Circle"] = 1] = "Circle";
})(IMapManager_MapShapeType || (IMapManager_MapShapeType = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Maps/BingMapManager.js
/// <reference path="../../node_modules/bingmaps/types/microsoftmaps/microsoft.maps.all.d.ts" />
/*******************************
*  BingMapItem
*******************************/




class BingMapItem {
    constructor(manager, options) {
        this.id = options.id;
        this.title = options.title;
        this.description = options.description;
        this.location = options.location;
        this.shape = options.shape;
        this.icon = options.icon;
        this.color = options.color;
    }
    /*******************************/
    openInfo() {
        this.infoWindow.setOptions({
            visible: true,
            location: this.marker.getLocation()
        });
    }
    /*******************************/
    closeInfo() {
        this.infoWindow.setOptions({
            visible: false
        });
    }
}
/*******************************
 *  BingMapManager
 *******************************/
class BingMapManager extends BindableObject_BindableObject {
    /*******************************/
    constructor(apiKey) {
        super();
        this._items = [];
        this.isReady = false;
        this.selectedItem = null;
        this.selectionColor = "#000000";
        this._apiKey = apiKey;
        this.prop("selectedItem").subscribe((newVal, oldVal) => {
            if (newVal)
                newVal.marker.setOptions({ color: this.selectionColor });
            if (oldVal)
                oldVal.marker.setOptions({ color: oldVal.color });
            this.onSelectionChanged();
        });
    }
    /*******************************/
    updateSize() {
        const currentCenter = this._map.getCenter();
        this._map.setView({
            center: currentCenter
        });
    }
    /*******************************/
    staticMap(options) {
        let result = "https://dev.virtualearth.net/REST/v1/Imagery/Map/Road";
        if (options.center) {
            result += "/" + options.center.latitude + "," + options.center.longitude;
            result += "/" + (options.zoomLevel ? options.zoomLevel : 15);
        }
        result += "?";
        if (options.size)
            result += "mapSize=" + options.size.width + "," + options.size.height + "&";
        if (options.pins) {
            options.pins.forEach(pin => {
                result += "pushpin=" + pin.center.latitude + "," + pin.center.longitude + ";";
                result += (pin.icon ? pin.icon : 5) + ";";
                if (pin.name)
                    result += encodeURIComponent(pin.name);
                result += "&";
            });
        }
        result += "format=PNG&key=" + encodeURIComponent(this._apiKey);
        return result;
    }
    /*******************************/
    attach(element) {
        this.loadModuleAsync("Microsoft.Maps.SpatialMath");
        this._map = new Microsoft.Maps.Map(element, {
            credentials: this._apiKey,
            zoom: 16,
            showMapTypeSelector: false,
            showLocateMeButton: true,
            liteMode: true
        });
        this._posLayer = new Microsoft.Maps.Layer();
        this._map.layers.insert(this._posLayer);
        this.isReady = true;
        this.onAttached();
    }
    /*******************************/
    onAttached() {
    }
    /*******************************/
    onSelectionChanged() {
    }
    /*******************************/
    zoomToItems() {
        if (this._items.length == 1) {
            this.centerTo(this._items[0].location);
        }
        else if (this._items.length > 1) {
            const locations = [];
            this._items.forEach(item => locations.push(new Microsoft.Maps.Location(item.location.latitude, item.location.longitude)));
            this._map.setView({
                bounds: Microsoft.Maps.LocationRect.fromLocations(locations)
            });
        }
    }
    /*******************************/
    centerToCurrent() {
        if (!navigator.geolocation)
            return;
        navigator.geolocation.getCurrentPosition(pos => {
            this.centerTo({
                latitude: pos.coords.latitude,
                longitude: pos.coords.longitude
            });
        });
    }
    /*******************************/
    getZoomLevel(radiusInKilometer, latitude) {
        const widthOfMapInPixels = this.map.getRootElement().clientWidth;
        const heightOfMapInPixels = this.map.getRootElement().clientHeight;
        const rangeInMeters = radiusInKilometer * 1000;
        const limitBoundPixels = Math.min(heightOfMapInPixels, widthOfMapInPixels);
        const zoom = Math.floor(Math.log(156543.03392 * Math.cos(latitude * Math.PI / 180) / (rangeInMeters / limitBoundPixels)) / Math.log(2));
        return zoom;
    }
    /*******************************/
    centerTo(location, radiusMeters) {
        this._map.setView({
            center: new Microsoft.Maps.Location(location.latitude, location.longitude),
            zoom: radiusMeters ? this.getZoomLevel(radiusMeters / 1000, location.latitude) : undefined
        });
    }
    /*******************************/
    async getSearchManagerAsync() {
        if (!this._searchManager) {
            await this.loadModuleAsync("Microsoft.Maps.Search");
            this._searchManager = new Microsoft.Maps.Search.SearchManager(this._map);
        }
        return this._searchManager;
    }
    /*******************************/
    async getAddressAsync(location) {
        const sm = await this.getSearchManagerAsync();
        return new Promise((res, rej) => {
            sm.reverseGeocode({
                location: new Microsoft.Maps.Location(location.latitude, location.longitude),
                callback: r => {
                    if (r && r.address)
                        res(r.address.formattedAddress);
                    else
                        res(undefined);
                }
            });
        });
    }
    /*******************************/
    async getLocationAsync(address) {
        const sm = await this.getSearchManagerAsync();
        return new Promise((res, rej) => {
            sm.geocode({
                where: address,
                bounds: this._map.getBounds(),
                callback: r => {
                    if (r && r.results && r.results.length > 0)
                        res({ latitude: r.results[0].location.latitude, longitude: r.results[0].location.longitude });
                    else
                        res(undefined);
                }
            });
        });
    }
    /*******************************/
    async showCurrentPositionAsync(value) {
        if (value == this._isShowPostion)
            return;
        this._isShowPostion = value;
        if (value) {
            if (await Global/* Services.permissionManager.geolocation.isGranted */.K9.permissionManager.geolocation.isGranted())
                this.updatePositionAsyc();
        }
        this._posLayer.setVisible(value);
    }
    /*******************************/
    async updatePositionAsyc(pos) {
        if (!pos)
            pos = await new Promise(res => navigator.geolocation.getCurrentPosition(res));
        const location = new Microsoft.Maps.Location(pos.coords.latitude, pos.coords.longitude);
        const path = Microsoft.Maps.SpatialMath.getRegularPolygon(location, pos.coords.accuracy, 36, Microsoft.Maps.SpatialMath.DistanceUnits.Meters);
        console.log(pos.coords.heading);
        const rotation = pos.coords.heading - 180;
        const transform = `rotate(${rotation} 77 77)`;
        const scaleFactor = 154 / 24;
        const width = 380 / scaleFactor;
        const height = 446 / scaleFactor;
        const svgIcon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-154 -223 380 446" width="${width}" height="${height}"><defs><clipPath id="id_377bbc1f_2559_44c8_a0ba_6bf58d6c86bf" role="canvas"><rect width="154.00000" height="223.00000" x="0.00000" y="0.00000"></rect></clipPath><linearGradient x1="387.48379" y1="146.66474" x2="193.95144" y2="235.10915" gradientUnits="userSpaceOnUse" id="id_b4527e8c_865b_4f93_a70e_92dd29ceed6a"><stop offset="0.0%" style="stop-color: rgb(3, 169, 244); stop-opacity: 1;"></stop><stop offset="100.0%" style="stop-color: rgb(255, 255, 255); stop-opacity: 0.368627;"></stop></linearGradient></defs><g id="id_b1da7e8c_0f77_4801_a9e9_d3df1cffa865" transform="${transform}" name="ArtProjectItems"><g fill="#ffffff" id="id_26d8e2e5_6f5c_4be3_a4e4_a1dc17c2cbfa" name="ArtGeometry" transform="matrix(1, 0, 0, 1, -171.15539470071286, -72.25095774122973)"><circle r="75.61522" cx="248.01568" cy="149.22398" name="geometry" id="id_26d8e2e5_6f5c_4be3_a4e4_a1dc17c2cbfa_main" role="main"></circle><use href="#id_26d8e2e5_6f5c_4be3_a4e4_a1dc17c2cbfa_main" fill="none" stroke="#000000" stroke-width="1.00000"></use></g><g fill="#03a9f4" id="id_6b0e97c8_13a8_474f_b76a_b8b8120d5d24" name="ArtGeometry" transform="matrix(1, 0, 0, 1, -157.81934710884875, -58.308758751842205)"><circle r="60.47326" cx="234.67963" cy="135.28178" name="geometry" id="id_6b0e97c8_13a8_474f_b76a_b8b8120d5d24_main" role="main"></circle></g><g fill="none" id="id_ba6838f0_76d9_4faf_9e41_9845f139ba0f" name="ArtGeometry" transform="matrix(0.40060806370973984, -0.9162495180302699, 0.9162495180302938, 0.4006080637097503, -214.48539209923712, 389.6257066762629)"><path d="M243.16623,141.34362h160l-109.87824,116.27396z" name="geometry" id="id_ba6838f0_76d9_4faf_9e41_9845f139ba0f_main" role="main" fill="url(#id_b4527e8c_865b_4f93_a70e_92dd29ceed6a)"></path></g></g></svg>`;
        if (!this._curPosItem) {
            this._curPosItem = new Microsoft.Maps.Pushpin(location, {
                icon: svgIcon,
                anchor: new Microsoft.Maps.Point((154 + 77) / scaleFactor, (223 + 77) / scaleFactor),
                enableClickedStyle: false,
                draggable: false,
                color: "#03a9f4"
            });
            this._posLayer.add(this._curPosItem);
        }
        if (!this._curPosPrecision) {
            this._curPosPrecision = new Microsoft.Maps.Polygon(path, {
                fillColor: "#03a9f450"
            });
            this._posLayer.add(this._curPosPrecision);
        }
        this._curPosItem.setOptions({ icon: svgIcon });
        this._curPosItem.setLocation(location);
        this._curPosPrecision.setLocations(path);
        if (this._isShowPostion)
            setTimeout(() => this.updatePositionAsyc(), 1000);
    }
    /*******************************/
    addItems(itemsOptions) {
        const items = [];
        const entities = [];
        itemsOptions.forEach(options => {
            const item = new BingMapItem(this, options);
            item.marker = new Microsoft.Maps.Pushpin(new Microsoft.Maps.Location(options.location.latitude, options.location.longitude), {
                title: options.title,
                icon: options.icon,
                color: options.color
            });
            if (options.shape) {
                if (options.shape.type == IMapManager_MapShapeType.Circle) {
                    const shape = Microsoft.Maps.SpatialMath.getRegularPolygon(new Microsoft.Maps.Location(options.location.latitude, options.location.longitude), options.shape.radius ? options.shape.radius : 1, 36, Microsoft.Maps.SpatialMath.DistanceUnits.Meters);
                    let stroke, fill;
                    if (options.shape.style) {
                        stroke = options.shape.style.strokeColor ? Microsoft.Maps.Color.fromHex(options.shape.style.strokeColor) : undefined;
                        if (stroke && options.shape.style.opacity)
                            stroke.a = options.shape.style.opacity * 255;
                        fill = options.shape.style.fillColor ? Microsoft.Maps.Color.fromHex(options.shape.style.fillColor) : undefined;
                        if (fill && options.shape.style.opacity)
                            fill.a = options.shape.style.opacity * 255;
                    }
                    const poly = new Microsoft.Maps.Polygon(shape, {
                        strokeColor: stroke,
                        fillColor: fill,
                        strokeThickness: options.shape.style && options.shape.style.strokeSize ? options.shape.style.strokeSize : undefined,
                    });
                    item.shapeObj = poly;
                }
            }
            /*
            item.infoWindow = new Microsoft.Maps.Infobox(item.marker.getLocation(), {

                title: options.title,
                description: options.description,
                visible: false
            });

            item.infoWindow.setMap(this._map);
            */
            Microsoft.Maps.Events.addHandler(item.marker, "click", () => {
                this.selectedItem = item;
            });
            entities.push(item.marker);
            if (item.shapeObj)
                entities.push(item.shapeObj);
            this._items.push(item);
            items.push(item);
        });
        this._map.entities.add(entities);
        return items;
    }
    /*******************************/
    clear() {
        this._items = [];
        this.map.entities.clear();
    }
    /*******************************/
    getItemById(id) {
        return (0,Linq/* linq */.k)(this._items).first(a => a.id == id);
    }
    /*******************************/
    removeItem(item) {
        this._items.splice(this._items.indexOf(item), 1);
        this._map.entities.remove(item.marker);
        if (item.infoWindow)
            item.infoWindow.setMap(null);
        if (item.shapeObj)
            this._map.entities.remove(item.shapeObj);
    }
    /*******************************/
    loadModuleAsync(name) {
        return new Promise((res, rej) => Microsoft.Maps.loadModule(name, () => res()));
    }
    /*******************************/
    get map() {
        return this._map;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/TypeCheck.js
function isAsyncEditor(value) {
    return value && typeof value == "object" && "editAsync" in value && typeof value["editAsync"] == "function";
}
/****************************************/
function isView(value) {
    return value && typeof value == "object" && "parentView" in value && "template" in value;
}
/****************************************/
function isActivable(value) {
    return value && typeof value == "object" && typeof value["activateAsync"] == "function" && value["activateAsync"].length == 0;
}
/****************************************/
function isSelectable(value) {
    return value && typeof value == "object" && "isSelected" in value && "select" in value && typeof value["select"] == "function";
}
/****************************************/
function isSingleItemSelector(value) {
    return value && typeof value == "object" && "selectedItem" in value;
}
/****************************************/
function isAsyncLoad(value) {
    return value && typeof value == "object" && typeof value["loadAsync"] == "function" && value["loadAsync"].length == 0;
}
/****************************************/
function isValidable(value) {
    return value && typeof value == "object" && typeof value["validateAsync"] == "function" && value["validateAsync"].length < 2;
}
/****************************************/
function isHTMLContainer(value) {
    return value && typeof value == "object" && "nodes" in value;
}
/****************************************/
function isEditable(value) {
    return value && typeof value == "object" && "createEditor" in value && typeof value.createEditor == "function";
}
/****************************************/
function isHTMLAttach(value) {
    return typeof value == "object" && "attach" in value && typeof value["attach"] == "function";
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/Abstraction/IBehavoir.js
/****************************************/
var IBehavoir_behavoirCatalog = {};

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/TemplateBuilder.js





/****************************************/
const TemplateCatalog = {};
function defineTemplate(name, template) {
    TemplateCatalog[name] = template;
}
window["__defineTemplate"] = defineTemplate;
/****************************************/
class TemplateBuilder_TemplateBuilder extends Binder {
    /****************************************/
    constructor(model, element, parent) {
        super(model);
        this._childCount = 0;
        this._updateCount = 0;
        this._updateNode = null;
        /****************************************/
        this.namespace = null;
        this.element = null;
        this.parent = null;
        this.isInline = false;
        this.inlineMode = "never";
        this.index = 0;
        this.parent = parent;
        this.element = element;
        if (element.namespaceURI && element.namespaceURI != "http://www.w3.org/1999/xhtml")
            this.namespace = element.namespaceURI;
    }
    /****************************************/
    beginTemplate(model, refNode, refNodePos = "after", marker) {
        const innerBuilder = new TemplateBuilder_TemplateBuilder(model, this.element, this);
        innerBuilder._lastElement = this._lastElement;
        innerBuilder.begin(refNode, refNodePos, marker);
        if (this.inlineMode == "explicit") {
            innerBuilder.isInline = this.isInline;
            innerBuilder.inlineMode = "inherit";
        }
        return innerBuilder;
    }
    /****************************************/
    endTemplate(childBuilder) {
        childBuilder.end();
        if (childBuilder.element == this.element)
            this._lastElement = childBuilder._lastElement;
    }
    /****************************************/
    beginUpdate() {
        if (this._updateCount == 0 && this.element.parentNode) {
            this._updateNode = document.createTextNode("");
            this.element.parentNode.replaceChild(this._updateNode, this.element);
        }
        this._updateCount++;
    }
    /****************************************/
    endUpdate() {
        this._updateCount--;
        if (this._updateCount == 0 && this._updateNode) {
            this._updateNode.parentNode.replaceChild(this.element, this._updateNode);
            this._updateNode = null;
        }
    }
    /****************************************/
    begin(refNode, refNodePos, marker) {
        this._startElement = marker ? document.createComment("begin-" + marker) : document.createTextNode("");
        if (refNode) {
            if (refNodePos == "after") {
                if (!refNode.nextSibling)
                    refNode.parentNode.appendChild(this._startElement);
                else
                    refNode.parentNode.insertBefore(this._startElement, refNode.nextSibling);
            }
            else if (refNodePos == "before")
                refNode.parentNode.insertBefore(this._startElement, refNode);
            else if (refNodePos == "inside")
                refNode.appendChild(this._startElement);
        }
        else
            this.appendChild(this._startElement);
        this._lastElement = this._startElement;
        return this;
    }
    /****************************************/
    end() {
        if (this._endElement)
            return;
        if (this._startElement.nodeType == Node.COMMENT_NODE)
            this._endElement = document.createComment(this._startElement.textContent.replace("begin-", "end-"));
        else
            this._endElement = document.createTextNode("");
        this.appendChild(this._endElement);
        return this;
    }
    /****************************************/
    clear(remove = false) {
        this._childCount = 0;
        if (!this._endElement) {
            console.warn("Missing end element: " + this.model);
            this.end();
        }
        let curNode = this._endElement;
        while (true) {
            let mustDelete = true;
            if ((curNode == this._startElement || curNode == this._endElement) && !remove)
                mustDelete = false;
            const prev = curNode.previousSibling;
            if (mustDelete) {
                if (mustDelete)
                    curNode.parentNode.removeChild(curNode);
            }
            if (curNode == this._startElement)
                break;
            curNode = prev;
        }
        if (remove) {
            this._endElement = null;
            this._startElement = null;
            this._lastElement = null;
        }
        else
            this._lastElement = this._startElement;
        this.cleanBindings(true);
        return this;
    }
    /****************************************/
    appendChild(node) {
        if (!this._lastElement || !this._lastElement.parentNode) //TODO this || didn't exists
            this.element.appendChild(node);
        else {
            if (this._lastElement.nextSibling)
                this._lastElement.parentNode.insertBefore(node, this._lastElement.nextSibling);
            else
                this._lastElement.parentNode.appendChild(node);
        }
        //TODO this line was inside else
        this._lastElement = node;
        //
        return this;
    }
    /****************************************/
    foreach(selector, templateOrName) {
        const value = this.getBindValue(selector);
        if (Array.isArray(value) || !value)
            this.foreachArray(selector, templateOrName);
        else
            this.foreachList(selector, templateOrName);
        return this;
    }
    /****************************************/
    foreachList(selector, templateOrName) {
        let itemsBuilders = [];
        const template = this.loadTemplate(templateOrName);
        const marker = document.createTextNode("");
        this.appendChild(marker);
        const handler = {
            onClear: () => {
                itemsBuilders.forEach(a => a.clear(true));
                itemsBuilders = [];
            },
            onItemRemoved: (item, index, reason) => {
                if (reason == "replace" || reason == "clear")
                    return;
                itemsBuilders[index].clear(true);
                itemsBuilders.splice(index, 1);
            },
            onItemSwap: (index, newIndex) => {
            },
            onItemReplaced: (newItem, oldItem, index) => {
                itemsBuilders[index].updateModel(newItem);
            },
            onItemAdded: (item, index, reason) => {
                if (reason == "replace")
                    return;
                let itemBuilder;
                if (index == itemsBuilders.length) {
                    if (index == 0)
                        itemBuilder = this.beginTemplate(item, marker, "after", this.createMarker(item));
                    else
                        itemBuilder = this.beginTemplate(item, itemsBuilders[index - 1]._endElement, "after", this.createMarker(item));
                    itemsBuilders.push(itemBuilder);
                }
                else {
                    itemBuilder = this.beginTemplate(item, itemsBuilders[index]._startElement, "before", this.createMarker(item));
                    itemsBuilders.splice(index, 0, itemBuilder);
                }
                itemBuilder.index = index;
                template(itemBuilder);
                this.endTemplate(itemBuilder);
            }
        };
        this.bind(selector, (value, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            this.beginUpdate();
            if (isUpdate)
                handler.onClear();
            if (oldValue)
                oldValue.unsubscribe(handler);
            if (value) {
                value.subscribe(handler);
                for (let i = 0; i < value.count; i++)
                    handler.onItemAdded(value.get(i), i, "add");
            }
            this.endUpdate();
        });
        return this;
    }
    /****************************************/
    foreachArray(selector, templateOrName) {
        let itemsBuilders = [];
        const template = this.loadTemplate(templateOrName);
        const marker = document.createTextNode("");
        this.appendChild(marker);
        this.bind(selector, (value, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            if (isUpdate) {
                itemsBuilders.forEach(a => a.clear());
                itemsBuilders = [];
            }
            if (value) {
                this._lastElement = marker;
                this.beginUpdate();
                value.forEach(item => {
                    const itemBuilder = this.beginTemplate(item);
                    itemBuilder.index = itemsBuilders.length;
                    template(itemBuilder);
                    this.endTemplate(itemBuilder);
                    itemsBuilders.push(itemBuilder);
                });
                this.endUpdate();
            }
        });
        return this;
    }
    /****************************************/
    if(condition, trueTemplate, falseTemplate) {
        const childBuilder = this.beginTemplate(this.model);
        this.register(childBuilder);
        this.bind(condition, (value, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            if (isUpdate)
                childBuilder.clear();
            if (value)
                childBuilder.template(trueTemplate);
            else if (falseTemplate)
                childBuilder.template(falseTemplate);
        });
        this.endTemplate(childBuilder);
        return this;
    }
    /****************************************/
    replaceContent(nodes) {
        if (this.isInline)
            throw "'replaceContent' not supported in inline elements";
        this.clear();
        for (const node of nodes)
            this.appendChild(node);
    }
    /****************************************/
    extractContent() {
        const result = [];
        for (const child of (0,Linq/* linq */.k)(this.element.childNodes)) {
            if (child != this._startElement && child != this._endElement)
                result.push(child);
        }
        return result;
    }
    /****************************************/
    content(content, inline = false) {
        const childBuilder = this.beginTemplate(undefined, undefined, undefined, this.createMarker(content));
        childBuilder.isInline = inline;
        childBuilder.inlineMode = "explicit";
        this.bind(content, (value, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            this.beginUpdate();
            if (!childBuilder.isInline && isHTMLContainer(value) && value.nodes && value.isCacheEnabled === true)
                childBuilder.replaceContent(value.nodes);
            else {
                if (oldValue && value && oldValue.template == value.template)
                    childBuilder.updateModel(value);
                else {
                    if (isUpdate)
                        childBuilder.clear();
                    if (value) {
                        const template = this.templateFor(value);
                        if (!template)
                            throw "Template '" + value.template + "' not found.";
                        childBuilder.updateModel(value);
                        template(childBuilder);
                    }
                }
                if (isHTMLContainer(value) && value.isCacheEnabled === true)
                    value.nodes = this.extractContent();
            }
            this.endUpdate();
        });
        this.endTemplate(childBuilder);
        return this;
    }
    /****************************************/
    templateFor(value) {
        if (typeof value == "string" || typeof value == "number")
            return this.loadTemplate("Text");
        if (typeof value == "object" && "template" in value)
            return this.loadTemplate(value.template);
        throw "cannot determine template for model";
    }
    /****************************************/
    loadTemplate(templateOrName) {
        if (typeof templateOrName == "string") {
            const result = TemplateCatalog[templateOrName];
            if (!result)
                console.error("Template ", templateOrName, " not found.");
            return result;
        }
        return templateOrName;
    }
    template(templateOrName, model) {
        const template = this.loadTemplate(templateOrName);
        if (model) {
            const childBuilder = this.beginTemplate(undefined, undefined, undefined, this.createMarker(model, "template"));
            this.bind(model, (value, oldValue, isUpdate, isClear) => {
                if (isClear)
                    return;
                childBuilder.updateModel(value);
                if (!isUpdate)
                    template(childBuilder);
            });
            this.endTemplate(childBuilder);
        }
        else
            template(this);
        return this;
    }
    /****************************************/
    exec(action) {
        action(this);
        return this;
    }
    /****************************************/
    beginChild(name, namespace) {
        if (this.isInline && this._childCount > 0)
            throw "In inline mode you must have a single root element for your template";
        const childElement = this.isInline && name.toUpperCase() == this.element.tagName ? this.element : this.createElement(name, namespace);
        const childBuilder = new ChildTemplateBuilder(this.model, childElement, this);
        if (childElement == this.element)
            childBuilder._lastElement = this._lastElement;
        this.register(childBuilder);
        this._childCount++;
        return childBuilder;
    }
    child(name, builderOrAttributes, namespace) {
        const childBuilder = new TemplateBuilder_TemplateBuilder(this.model, this.createElement(name, namespace), this);
        this.register(childBuilder);
        if (typeof builderOrAttributes == "function")
            builderOrAttributes(childBuilder);
        else
            childBuilder.attribs(builderOrAttributes);
        this.appendChild(childBuilder.element);
        return this;
    }
    /****************************************/
    set(attribute, value) {
        this.bind(value, a => {
            if (a !== null && a !== undefined) {
                if (a instanceof Promise) {
                    a.then(newValue => this.element.setAttribute(attribute, newValue));
                }
                else
                    this.element.setAttribute(attribute, a);
            }
            else
                this.element.removeAttribute(attribute);
        });
        return this;
    }
    /****************************************/
    on(event, handler) {
        this.element.addEventListener(event, ev => handler(this.model, ev));
        return this;
    }
    class(name, condition) {
        if (condition) {
            const nameParts = name ? name.split(" ") : [];
            this.bind(condition, value => {
                if (value)
                    nameParts.forEach(a => this.element.classList.add(a));
                else
                    nameParts.forEach(a => this.element.classList.remove(a));
            });
        }
        else
            this.bind(name, (value, oldValue) => {
                if (oldValue)
                    oldValue.split(" ").forEach(item => this.element.classList.remove(item));
                if (value)
                    value.split(" ").forEach(item => this.element.classList.add(item));
            });
        return this;
    }
    /****************************************/
    visible(value) {
        this.bind(value, (newValue, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            if (newValue) {
                this.element.classList.add("visible");
                this.element.classList.remove("hidden");
            }
            else {
                this.element.classList.add("hidden");
                this.element.classList.remove("visible");
            }
        });
        return this;
    }
    /****************************************/
    text(value) {
        const textNode = document.createTextNode("");
        this.appendChild(textNode);
        this.bind(value, a => textNode.textContent = a);
        return this;
    }
    /****************************************/
    html(value) {
        this.bind(value, a => this.element.innerHTML = a);
        return this;
    }
    /****************************************/
    focus(value) {
        const valueProp = this.getBindingProperty(value);
        if (valueProp) {
            this.element.addEventListener("focus", ev => valueProp.set(true));
            this.element.addEventListener("focusout", ev => valueProp.set(false));
        }
        this.bind(value, a => {
            if (a && document.activeElement != this.element)
                this.element.focus();
        });
        return this;
    }
    /****************************************/
    value(value) {
        const element = this.element;
        const valueProp = this.getBindingProperty(value);
        if (valueProp) {
            if (element.tagName == "INPUT" || element.tagName == "TEXTAREA") {
                if (element.type == "checkbox" || element.type == "radio")
                    element.addEventListener("change", ev => {
                        valueProp.set(element.checked);
                    });
                else {
                    element.addEventListener("keyup", ev => {
                        valueProp.set(element.value);
                    });
                    element.addEventListener("change", ev => {
                        valueProp.set(element.value);
                    });
                }
            }
            else if (element.tagName == "SELECT") {
                element.addEventListener("change", ev => {
                    valueProp.set(element.value);
                });
            }
        }
        if (element.tagName == "INPUT" || element.tagName == "TEXTAREA" || element.tagName == "SELECT") {
            if (element.type == "checkbox" || element.type == "radio")
                this.bind(value, (a) => element.checked = a);
            else
                this.bind(value, (a) => a ? element.value = a : element.value = null);
        }
        return this;
    }
    /****************************************/
    style(name, value) {
        this.bind(value, a => this.element.style[name] = a);
        return this;
    }
    behavoir(nameOrValue) {
        if (typeof nameOrValue == "string")
            IBehavoir_behavoirCatalog[nameOrValue]().attach(this.element, this.model);
        else
            nameOrValue.attach(this.element, this.model);
        return this;
    }
    /****************************************/
    styles(value) {
        for (const name in value)
            this.bind(value[name], a => this.element.style[name] = a);
        return this;
    }
    /****************************************/
    attribs(value) {
        for (const name in value)
            this.set(name, value[name]);
        return this;
    }
    /****************************************/
    debugger() {
        debugger;
        return this;
    }
    /****************************************/
    createElement(name, namespace) {
        if (!namespace)
            namespace = this.namespace;
        if (namespace)
            return document.createElementNS(namespace, name);
        return document.createElement(name);
    }
    /****************************************/
    createMarker(obj, baseName = "") {
        return undefined;
        if (typeof obj == "function")
            return this.createMarker(obj(this.model), baseName);
        if (typeof obj == "string")
            return baseName + obj;
        if (obj == null)
            return baseName + "null";
        return this.createMarker(getTypeName(obj), baseName);
    }
}
/****************************************/
class ChildTemplateBuilder extends TemplateBuilder_TemplateBuilder {
    constructor(model, element, parent) {
        super(model, element, parent);
    }
    /****************************************/
    endChild() {
        if (this.parent.element != this.element)
            this.parent.appendChild(this.element);
        else {
            if (this._lastElement)
                this.parent["_lastElement"] = this._lastElement;
        }
        return this.parent;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/Functions.js



function model(obj) {
    Properties_Properties.createAll(obj);
    return obj;
}
/****************************************/
function Functions_template(root, template, model) {
    root.innerHTML = "";
    const builder = new TemplateBuilder_TemplateBuilder(model, root);
    builder.begin();
    builder.loadTemplate(template)(builder);
    builder.end();
}
/****************************************/
function setEnumerable(obj, propName) {
    let curType = getType(obj);
    while (true) {
        const desc = Object.getOwnPropertyDescriptor(curType.prototype, propName);
        if (desc) {
            if (!desc.enumerable) {
                desc.enumerable = true;
                Object.defineProperty(obj, propName, desc);
            }
            return;
        }
        curType = getBaseType(curType);
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/Templating/ObservableList.js
class ObservableList {
    /****************************************/
    constructor(items, equalityComparer) {
        this._items = [];
        this._items = items || [];
        this.equalityComparer = equalityComparer;
    }
    /****************************************/
    add(item) {
        this._items.push(item);
        this.invoke(a => a.onItemAdded ? a.onItemAdded(item, this._items.length - 1, "add") : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
        return item;
    }
    /****************************************/
    addRange(items) {
        for (const item of items) {
            this._items.push(item);
            this.invoke(a => a.onItemAdded ? a.onItemAdded(item, this._items.length - 1, "add") : undefined);
        }
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
    }
    /****************************************/
    insert(index, item) {
        this._items.splice(index, 0, item);
        this.invoke(a => a.onItemAdded ? a.onItemAdded(item, index, "insert") : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
        return item;
    }
    /****************************************/
    remove(item) {
        const index = this.indexOf(item);
        if (index != -1)
            this.removeAt(index);
    }
    /****************************************/
    removeWhen(condition) {
        for (let i = this._items.length - 1; i >= 0; i--) {
            if (condition(this._items[i]))
                this.removeAt(i);
        }
    }
    /****************************************/
    removeRange(startIndex, count) {
        const items = this._items.splice(startIndex, count);
        let isChanged = false;
        for (let i = items.length - 1; i >= 0; i--) {
            this.invoke(a => a.onItemRemoved ? a.onItemRemoved(items[i], startIndex + i, "remove") : undefined);
            isChanged = true;
        }
        if (isChanged)
            this.invoke(a => a.onChanged ? a.onChanged() : undefined);
        return items;
    }
    /****************************************/
    removeAt(index) {
        const item = this._items.splice(index, 1)[0];
        this.invoke(a => a.onItemRemoved ? a.onItemRemoved(item, index, "remove") : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
        return item;
    }
    /****************************************/
    clear() {
        if (this._items.length == 0)
            return;
        for (let i = this._items.length - 1; i >= 0; i--)
            this.invoke(a => a.onItemRemoved ? a.onItemRemoved(this._items[i], i, "clear") : undefined);
        this._items.splice(0, this._items.length);
        this.invoke(a => a.onClear ? a.onClear() : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
    }
    /****************************************/
    contains(item) {
        return this.indexOf(item) != -1;
    }
    /****************************************/
    indexOf(item) {
        if (this.equalityComparer) {
            for (let i = 0; i < this._items.length; i++) {
                if (this.equalityComparer(item, this._items[i]))
                    return i;
            }
            return -1;
        }
        return this._items.indexOf(item);
    }
    /****************************************/
    *[Symbol.iterator]() {
        for (const item of this._items)
            yield item;
    }
    /****************************************/
    toArray() {
        return this._items;
    }
    /****************************************/
    get(index) {
        return this._items[index];
    }
    /****************************************/
    set(index, value) {
        const oldItem = this._items[index];
        if (oldItem == value)
            return;
        this.invoke(a => a.onItemRemoved ? a.onItemRemoved(oldItem, index, "replace") : undefined);
        this._items[index] = value;
        this.invoke(a => a.onItemAdded ? a.onItemAdded(value, index, "replace") : undefined);
        this.invoke(a => a.onItemReplaced ? a.onItemReplaced(value, oldItem, index) : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
    }
    /****************************************/
    swap(index, newIndex) {
        const temp = this._items[newIndex];
        this._items[newIndex] = this._items[index];
        this._items[index] = temp;
        this.invoke(a => a.onItemSwap ? a.onItemSwap(index, newIndex) : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
    }
    /****************************************/
    subscribe(handler) {
        if (!this._handlers)
            this._handlers = [];
        const index = this._handlers.indexOf(handler);
        if (index == -1)
            this._handlers.push(handler);
        return handler;
    }
    /****************************************/
    unsubscribe(handler) {
        if (!this._handlers)
            return;
        const index = this._handlers.indexOf(handler);
        if (index != -1)
            this._handlers.splice(index, 1);
    }
    /****************************************/
    forEach(action) {
        let index = 0;
        for (const item of this) {
            action(item, index);
            index++;
        }
    }
    /****************************************/
    invoke(action) {
        if (!this._handlers)
            return;
        this._handlers.forEach(handler => action(handler));
    }
    /****************************************/
    get first() {
        return this._items[0];
    }
    get last() {
        return this._items[this._items.length - 1];
    }
    get count() {
        return this._items.length;
    }
    toJSON() {
        return this._items;
    }
}
/****************************************/
function ObservableList_listOf(items) {
    return new ObservableList(items);
}
/****************************************/
function ObservableList_observableListOf(items, equalityComparer) {
    return new ObservableList(items, equalityComparer);
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/BaseSearch.js

/****************************************/
class BaseSearch {
    searchAsync(query, chunkSize = 25) {
        if (!query)
            query = "";
        const queryParts = (0,Linq/* linq */.k)(query.toLowerCase().split(" ")).select(a => a.trim()).where(a => a != "").toArray();
        const result = [];
        if (queryParts.length > 0)
            this.doSearch(queryParts, result);
        return (0,Linq/* linq */.k)(result).orderByDesc(a => a.rank).select(a => a.value).toArrayAsync(chunkSize);
    }
    /****************************************/
    macthWeight(keyword, text) {
        if (!text)
            return 0;
        if (typeof text != "string")
            text = text.toString();
        text = text.toLowerCase();
        const index = text.indexOf(keyword);
        if (index == -1)
            return 0;
        return (text.length == keyword.length ? 1 : (text.length - keyword.length - index) / (text.length - keyword.length)) +
            (text.length - keyword.length) / text.length;
    }
    /****************************************/
    matchValue(value, queryParts) {
        var _a;
        if (queryParts.length == 0)
            return 1;
        let totWeight = 0;
        for (const qPart of queryParts) {
            let partWeight = 0;
            for (const valuePart of this.getSearchParts(value))
                partWeight += (_a = this.macthWeight(qPart, valuePart.text) * valuePart.weight) !== null && _a !== void 0 ? _a : 1;
            if (partWeight == 0)
                return 0;
            totWeight += partWeight;
        }
        return totWeight;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/HIstoryPageHost.js





class HIstoryPageHost_HistoryPageHost {
    constructor(innerHost) {
        this._isSyncing = 0;
        this._backSignal = new Signal_Signal();
        this._isFirstPage = true;
        this.innerHost = innerHost;
        this._startHistoryIndex = window.history.length;
        this._sessionId = new Date().getTime().toString();
        window.addEventListener("popstate", ev => this.onPopState(ev.state));
    }
    /****************************************/
    async onPopState(state) {
        console.debug("begin popState: ", state, " isSyncing: ", this._isSyncing);
        if (this._isSyncing)
            return;
        if (state)
            await this.goToAsync(state.index);
        this._backSignal.set();
        console.debug("end popState: ", state);
    }
    /****************************************/
    onStateChanged(page) {
        if (this._isSyncing)
            return;
        if (page == this.current)
            this.updateState();
    }
    /****************************************/
    updateState(isNew = false) {
        if (!this.current) {
            window.history.replaceState(window.history.state, "", "/");
            document.title = "";
            return;
        }
        const title = Global/* App.formatTitle */.gV.formatTitle(this.current.title);
        const url = this.current.url ? Helpers_Uri/* Uri.absolute */.S.absolute(Helpers_Format/* Format.replaceArgs */.E.replaceArgs(this.current.url, Global/* App.startupArgs */.gV.startupArgs)) : null;
        this.registerPageView();
        if (isNew) {
            const curState = {
                sessionId: this._sessionId,
                index: this.currentIndex
            };
            window.history.pushState(curState, title, url);
        }
        else
            window.history.replaceState(window.history.state, title, url);
        document.title = title;
    }
    /****************************************/
    registerPageView() {
        const url = this.current.url ? Helpers_Uri/* Uri.absolute */.S.absolute(Helpers_Format/* Format.replaceArgs */.E.replaceArgs(this.current.url, Global/* App.startupArgs */.gV.startupArgs)) : null;
        if ((url != document.location.href || this._isFirstPage) && this.current.url) {
            const relUrl = Helpers_Format/* Format.replaceArgs */.E.replaceArgs(this.current.url, Global/* App.startupArgs */.gV.startupArgs).replace("~/", "");
            if (Global/* Services.analytics */.K9.analytics)
                Global/* Services.analytics.pageView */.K9.analytics.pageView(relUrl);
        }
    }
    /****************************************/
    async clearAsync() {
        await this.innerHost.clearAsync();
        await this.syncHistoryAsync();
        this._isSyncing++;
        window.history.pushState(null, null, null);
        window.history.go(-1);
        this._isSyncing--;
    }
    /****************************************/
    get(index) {
        return this.innerHost.get(index);
    }
    /****************************************/
    async goBackAsync() {
        if (this.currentIndex > 0) {
            console.debug("begin goBack");
            this._backSignal.reset();
            window.history.back();
            const waitRes = await this._backSignal.waitFor(TimeSpan_TimeSpan.fromMilliseconds(500));
            console.debug("end goBack: ", waitRes);
        }
        else {
            await this.clearAsync();
            await Global/* App.mainAsync */.gV.mainAsync();
        }
    }
    /****************************************/
    goForwardAsync() {
        window.history.forward();
        return Promise.resolve();
    }
    /****************************************/
    async goToAsync(index) {
        await this.innerHost.goToAsync(index);
        this.updateState();
    }
    /****************************************/
    async syncHistoryAsync() {
        if (this._isSyncing)
            return;
        this._isSyncing++;
        try {
            let curState = window.history.state;
            while (curState && curState.sessionId == this._sessionId && curState.index > 0) {
                this._backSignal.reset();
                window.history.back();
                await this._backSignal.waitFor(TimeSpan_TimeSpan.fromMilliseconds(500));
                curState = window.history.state;
            }
            let curIndex = 0;
            while (curIndex < this.pageCount) {
                const curPage = this.get(curIndex);
                const title = Global/* App.formatTitle */.gV.formatTitle(curPage.title);
                const url = curPage.url ? Helpers_Uri/* Uri.absolute */.S.absolute(Helpers_Format/* Format.replaceArgs */.E.replaceArgs(curPage.url, Global/* App.startupArgs */.gV.startupArgs)) : null;
                curState = {
                    sessionId: this._sessionId,
                    index: curIndex
                };
                if (curIndex == 0)
                    window.history.replaceState(curState, title, url);
                else
                    window.history.pushState(curState, title, url);
                if (curIndex == this.currentIndex)
                    document.title = title;
                curIndex++;
            }
            const delta = this.currentIndex - (this.pageCount - 1);
            if (delta < 0)
                window.history.go(delta);
        }
        finally {
            this._isSyncing--;
        }
    }
    /****************************************/
    async loadAsync(page, options) {
        const curState = window.history.state;
        const inSync = curState && curState.sessionId == this._sessionId && curState.index == this.currentIndex;
        await this.innerHost.loadAsync(page, options);
        page.prop("title").subscribe(a => this.onStateChanged(page));
        page.prop("url").subscribe(a => this.onStateChanged(page));
        page.host = this;
        if (inSync)
            this.updateState(true);
        else {
            await this.syncHistoryAsync();
            this.registerPageView();
        }
        this._isFirstPage = false;
        return page;
    }
    find(nameOrType) {
        return this.innerHost.find(nameOrType);
    }
    /****************************************/
    async bringFrontAsync(page) {
        await this.innerHost.bringFrontAsync(page);
        await this.syncHistoryAsync();
    }
    /****************************************/
    get currentIndex() {
        return this.innerHost.currentIndex;
    }
    set setCurrentIndex(value) {
        this.innerHost.currentIndex = value;
        this.syncHistoryAsync();
    }
    /****************************************/
    get current() {
        return this.innerHost.current;
    }
    /****************************************/
    get pageCount() {
        return this.innerHost.pageCount;
    }
    /****************************************/
    get canGoBack() {
        return this.innerHost.canGoBack || Global/* App.hasMain */.gV.hasMain;
    }
}

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/OperationView.html
var OperationView = __webpack_require__(2547);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/View.js


/********************************************/
class View_View extends BindableObject_BindableObject {
    constructor(config) {
        super();
        /********************************************/
        this.template = null;
        this.parentView = null;
        this.bindConfig("template", config);
        if (!this.template)
            this.template = getTypeName(this);
        if (config) {
            if (config.parentView)
                this.parentView = config.parentView;
        }
        this.debugTypeName();
    }
    /********************************************/
    debugTypeName() {
        const curName = this.constructor.name;
        const regName = this.constructor["@typeName"];
        if (!regName)
            console.warn("Type '" + curName + "' is not registered.");
    }
}
registerType(View_View, "View");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Operation.js










/****************************************/
class Operation_OperationView extends View_View {
    /****************************************/
    constructor(config) {
        super(config);
        /****************************************/
        this.subOperations = ObservableList_listOf();
        this.message = null;
        this.parentOperation = null;
        this.bindConfig("message", config);
        if (!config.type)
            this._type = IOperation_OperationType.Global;
        else
            this._type = config.type;
        this.parentOperation = config.parentOperation;
    }
    /****************************************/
    end() {
        Global/* Services.operation.end */.K9.operation.end(this);
    }
    /****************************************/
    get type() {
        return this._type;
    }
    /****************************************/
    get progress() {
        return this._progress;
    }
    /****************************************/
    set progress(value) {
        this._progress = value;
        if (this._progress) {
            console.log(this.getProgressDescription(this._progress));
            if (this._progress.message)
                this.message = Helpers_Format/* Format.text */.E.text(this._progress.message);
        }
        else
            this.message = undefined;
    }
    /****************************************/
    addSubOperation(operation) {
        this.subOperations.add(operation);
    }
    /****************************************/
    removeSubOperation(operation) {
        this.subOperations.remove(operation);
    }
    /****************************************/
    getProgressDescription(value) {
        let msg = "Progress: ";
        if (value.message)
            msg += "'" + value.message + "'";
        if (value.current != null && value.totCount != null)
            msg += " - " + value.current + "/" + value.totCount + " (" + round(100 / value.totCount * value.current, 1) + "%)";
        return msg;
    }
}
/****************************************/
class Operation_ViewOperationManager {
    constructor() {
        /****************************************/
        this.operations = ObservableList_listOf();
        this.onBegin = Event_event();
        this.onEnd = Event_event();
        this.onProgress = Event_event();
    }
    progress(progress) {
        if ((0,TypeCheck/* isString */.HD)(progress))
            progress = { message: progress };
        if (this.current) {
            this.current.progress = progress;
            this.onProgress.raise(this, {
                operation: this.current,
                progress: progress
            });
        }
    }
    /****************************************/
    begin(configOrMessge) {
        if (!(0,TypeCheck/* isObject */.Kn)(configOrMessge))
            configOrMessge = { message: configOrMessge };
        const operation = new Operation_OperationView(configOrMessge);
        console.group("Begin operation: ", operation.message);
        operation.progress = configOrMessge;
        if (operation.parentOperation === undefined)
            operation.parentOperation = this.current;
        this.operations.add(operation);
        if (operation.parentOperation)
            operation.parentOperation.addSubOperation(operation);
        if (operation.type != IOperation_OperationType.Local) {
            const view = configOrMessge.showProgress ? new View_View({
                template: t => t.template("OperationView", operation)
            }) : undefined;
            Global/* App.block */.gV.block(view);
        }
        return operation;
    }
    /****************************************/
    end(operation) {
        console.groupEnd();
        console.log("End operation: ", operation.message);
        this.operations.remove(operation);
        if (operation.parentOperation)
            operation.parentOperation.removeSubOperation(operation);
        if (operation.type != IOperation_OperationType.Local)
            Global/* App.unblock */.gV.unblock();
    }
    /****************************************/
    get current() {
        return this.operations.count > 0 ? this.operations.get(this.operations.count - 1) : null;
    }
}
/****************************************/
registerType(Operation_OperationView, "OperationView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/ViewUtils.js



async function loadAllAsync(items) {
    const loaders = (0,Linq/* linq */.k)(items).ofType(a => isAsyncLoad(a)).select(a => a.loadAsync()).toArray();
    return await Promise.all(loaders);
}
/****************************************/
function ViewUtils_formatForCss(name) {
    let s = 0;
    let result = "";
    for (let i = 0; i < name.length; i++) {
        const c = name.charAt(i);
        switch (s) {
            //upper mode or begin 
            case 0:
                result += c.toLowerCase();
                if (!isUpperCase(c) || c == "-")
                    s = 1;
                break;
            //first-mode
            case 1:
                if (isUpperCase(c) && c != "-") {
                    result += "-";
                    s = 0;
                }
                result += c.toLowerCase();
                break;
        }
    }
    return result;
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ViewComponent.js



/****************************************/
class ViewComponent extends View_View {
    constructor(config) {
        super(config);
        /****************************************/
        this.enabled = true;
        this.visible = true;
        this.styles = [];
        this.name = null;
        this.nodes = null;
        this.isCacheEnabled = false;
        this.status = "";
        this.bindConfig("enabled", config);
        this.bindConfig("visible", config);
        if (config) {
            if (config.styles)
                this.styles = config.styles;
            if (config.name)
                this.name = config.name;
        }
        this.prop("styles").subscribe(() => this.buildStyles());
        this.buildStyles();
    }
    /****************************************/
    addStyle(value) {
        if (this.styles.indexOf(value) != -1)
            return;
        this.styles.push(value);
        this.buildStyles();
    }
    /****************************************/
    removeStyle(value) {
        const index = this.styles.indexOf(value);
        if (index == -1)
            return;
        this.styles.splice(index, 1);
        this.buildStyles();
    }
    /****************************************/
    buildStyles() {
        let result = "";
        let curType = getType(this);
        while (curType != ViewComponent) {
            const typeName = getTypeName(curType);
            result += ViewUtils_formatForCss(typeName) + " ";
            curType = getBaseType(curType);
        }
        if (this.name)
            result += ViewUtils_formatForCss(this.name) + " ";
        if (this.styles)
            result += this.styles.join(" ");
        this.className = result.trim();
    }
    /****************************************/
    get debugName() {
        return getTypeName(this) + ": " + this.name;
    }
}
registerType(ViewComponent, "ViewComponent");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ContentView.js



/********************************************/
class ContentView extends ViewComponent {
    constructor(config) {
        super(config);
        /********************************************/
        this.content = null;
        this.contentTemplate = null;
        this.bindConfig("content", config, null, () => this.onContentChanged());
        this.bindConfig("contentTemplate", config);
        if (this.contentTemplate)
            this.template = t => t.template(t.model.contentTemplate, t.model.content);
    }
    /********************************************/
    onContentChanged() {
        if (isView(this.content))
            this.content.parentView = this;
    }
}
registerType(ContentView, "ContentView");

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ContextMenu.html
var ContextMenu = __webpack_require__(926);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ContextMenu.js







/****************************************/
class ContextMenu_ContextMenu extends BindableObject_BindableObject {
    /****************************************/
    constructor(config) {
        super();
        /****************************************/
        this.actions = ObservableList_observableListOf();
        this.className = "context-menu";
        if (config) {
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
        }
        this._menuContainer = document.createElement("DIV");
        this._menuContainer.className = "popup-container";
        this._clickHandler = this.onClick.bind(this);
    }
    /****************************************/
    addAction(action) {
        this.actions.add(ActionView_ActionView.fromAction(action));
    }
    /****************************************/
    async showAsync(element, event) {
        const curOfs = { x: 0, y: 0 };
        if (!element && event) {
            if (event instanceof MouseEvent) {
                element = event.srcElement;
                curOfs.x = event.offsetX;
                curOfs.y = event.offsetY;
            }
            else {
                curOfs.x = event.touches[0].clientX;
                curOfs.y = event.touches[0].clientY;
            }
        }
        const builder = new TemplateBuilder_TemplateBuilder(this, this._menuContainer);
        builder.template("ContextMenu", a => a);
        document.body.appendChild(this._menuContainer);
        await (0,PromiseUtils/* delayAsync */.$)(0);
        window.addEventListener("pointerdown", this._clickHandler);
        if (element) {
            let curEl = element;
            let offsetEl = element;
            while (curEl) {
                if (curEl == offsetEl) {
                    curOfs.y += curEl.offsetTop;
                    curOfs.x += curEl.offsetLeft;
                    offsetEl = curEl.offsetParent;
                }
                curOfs.y -= curEl.scrollTop;
                curOfs.x -= curEl.scrollLeft;
                curEl = curEl.parentElement;
            }
        }
        let xTrans = "";
        let yTrans = "";
        if (curOfs.x + this._menuContainer.clientWidth > document.body.clientWidth) {
            curOfs.x -= this._menuContainer.clientWidth;
            xTrans = "right";
        }
        else
            xTrans = "left";
        if (curOfs.y + this._menuContainer.clientHeight > document.body.clientHeight) {
            curOfs.y -= this._menuContainer.clientHeight;
            yTrans = "bottom";
        }
        else
            yTrans = "top";
        this._menuContainer.style.top = curOfs.y + "px";
        this._menuContainer.style.left = curOfs.x + "px";
        this._menuContainer.style.transformOrigin = xTrans + " " + yTrans;
        await (0,PromiseUtils/* delayAsync */.$)(0);
        this._menuContainer.classList.add("visible");
    }
    /****************************************/
    hide() {
        this._menuContainer.classList.remove("visible");
        window.removeEventListener("pointerdown", this._clickHandler);
        setTimeout(() => document.body.removeChild(this._menuContainer), 500);
    }
    /****************************************/
    onClick(e) {
        setTimeout(() => this.hide(), 200);
    }
}
registerType(ContextMenu_ContextMenu, "ContextMenu");

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/IconTextView.html
var Templates_IconTextView = __webpack_require__(5700);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/Icon.html
var Icon = __webpack_require__(3123);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/IconTextView.js




/****************************************/
class IconTextView_IconTextView extends ViewComponent {
    constructor(config) {
        super(config);
        /****************************************/
        this.icon = null;
        this.text = null;
        this.badge = null;
        this.bindConfig("icon", config);
        this.bindConfigString("text", config);
        this.bindConfigString("badge", config);
    }
}
registerType(IconTextView_IconTextView, "IconTextView");

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ActionView.html
var ActionView = __webpack_require__(1179);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ActionView.js












/****************************************/
var AggregationMode;
(function (AggregationMode) {
    AggregationMode[AggregationMode["None"] = 0] = "None";
    AggregationMode[AggregationMode["Parallel"] = 1] = "Parallel";
    AggregationMode[AggregationMode["Serial"] = 2] = "Serial";
})(AggregationMode || (AggregationMode = {}));
/****************************************/
class ActionView_ActionView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "ActionLink" }, config));
        /****************************************/
        this.tooltip = null;
        this.operation = IOperation_OperationType.Global;
        this.canAggregate = AggregationMode.None;
        this.subActions = ObservableList_observableListOf();
        this.bindConfigString("tooltip", config, DynamicString/* StringUsage.Tooltip */.Fq.Tooltip);
        this.bindConfig("operation", config);
        this.bindConfig("canAggregate", config);
        if (config) {
            if (config.executeAsync)
                this.executeWorkAsync = () => config.executeAsync(this);
            if (config.subActions)
                config.subActions.forEach(sub => this.subActions.add(new ActionView_ActionView(sub)));
        }
    }
    /****************************************/
    async executeAsync() {
        if (window.event)
            window.event.stopPropagation();
        if (Global/* Services.analytics */.K9.analytics)
            Global/* Services.analytics.action */.K9.analytics.action(this.name);
        const op = Global/* Services.operation.begin */.K9.operation.begin({ message: "Executing " + this.name, type: this.operation });
        this.status = "executing";
        try {
            await this.executeWorkAsync();
            if (this.subActions.count > 0) {
                const menu = new ContextMenu_ContextMenu();
                this.subActions.forEach(a => menu.actions.add(a));
                menu.showAsync(window.event.srcElement);
            }
        }
        catch (ex) {
            Global/* App.handleError */.gV.handleError(this, ex);
            throw ex;
        }
        finally {
            this.status = "";
            op.end();
        }
    }
    /****************************************/
    executeWorkAsync() {
        return Promise.resolve();
    }
    /****************************************/
    static fromAction(action, config) {
        const actionViewConfig = (a) => {
            var _a;
            return (Object.assign({ name: a.name, operation: a.operation, styles: a.styles, template: "ActionLink", subActions: a.subActions ? (0,Linq/* linq */.k)(a.subActions).select(b => actionViewConfig(b)).toArray() : undefined, content: new IconTextView_IconTextView({
                    template: "IconTextViewInline",
                    text: Helpers_Format/* Format.action */.E.action((_a = a.displayName) !== null && _a !== void 0 ? _a : a.name),
                    icon: a.icon,
                    badge: a.badge
                }), executeAsync: a.executeAsync }, config));
        };
        const result = new ActionView_ActionView(actionViewConfig(action));
        if (action.canExecute)
            Properties_Properties.converter(result, "visible", () => action.canExecute());
        return result;
    }
    /****************************************/
    static fromItemAction(action, getItem, config) {
        var _a;
        const result = new ActionView_ActionView(Object.assign({ name: action.name, operation: action.operation, styles: action.styles, content: new IconTextView_IconTextView({
                template: "IconTextViewInline",
                text: Helpers_Format/* Format.action */.E.action((_a = action.displayName) !== null && _a !== void 0 ? _a : action.name),
                icon: action.icon,
                badge: action.badge
            }), executeAsync: () => action.executeAsync(getItem()) }, config));
        if (action.canExecute)
            result.bind("visible", result.createComputed(() => action.canExecute(getItem())));
        return result;
    }
    /****************************************/
    static fromActionIcon(action, config) {
        var _a;
        const result = new ActionView_ActionView(Object.assign({ name: action.name, styles: action.styles, operation: action.operation, template: "ActionIcon", content: action.icon, tooltip: (_a = action.displayName) !== null && _a !== void 0 ? _a : action.name, executeAsync: action.executeAsync }, config));
        if (action.canExecute)
            result.bind("visible", result.createComputed(() => action.canExecute()));
        return result;
    }
}
registerType(ActionView_ActionView, "ActionView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/SelectionManager.js




class SelectionManager extends BindableObject_BindableObject {
    constructor() {
        super();
        /****************************************/
        this.selectedItems = ObservableList_observableListOf();
        this.actions = ObservableList_observableListOf();
        this.selectionText = null;
        this.isActive = false;
        this.selectedItems.subscribe({
            onChanged: () => {
                this.updateView();
                if (this.selectedItems.count == 0)
                    this.close();
            }
        });
    }
    /****************************************/
    close() {
        this.isActive = false;
        for (var i = this.selectedItems.count - 1; i >= 0; i--)
            this.selectedItems.get(i).isSelected = false;
        this.selectedItems.clear();
        this.actions.clear();
        this.updateView();
    }
    /****************************************/
    open() {
        this.isActive = true;
    }
    /****************************************/
    addAction(action) {
        const result = ActionView_ActionView.fromItemAction(action, () => this.selectedItems.toArray());
        this.actions.add(result);
        return result;
    }
    /****************************************/
    updateView() {
        this.selectionText = DynamicString/* DynamicString.getValue */.wI.getValue("selection-count", { params: [this.selectedItems.count.toString()], cardinality: this.selectedItems.count });
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Behavoirs/AttachBehavoir.js
class AttachBehavoir_AttachBehavoir {
    attach(element, viewModel) {
        if ("attach" in viewModel) {
            setTimeout(() => viewModel.attach(element));
        }
    }
    /****************************************/
    detach(element, viewModel) {
    }
}
/****************************************/
AttachBehavoir_AttachBehavoir.instance = new AttachBehavoir_AttachBehavoir();

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Behavoirs/LongPresssBehavoir.js
/****************************************/
class LongPresssBehavoir_LongPressBehavoir {
    constructor() {
        this._isLongPress = false;
    }
    attach(element, viewModel) {
        this._handler = viewModel;
        this._element = element;
        this._cancelHandler = (ev) => this.cancelTimer(ev);
        element.addEventListener("touchstart", ev => this.startTimer(ev), { passive: true });
        element.addEventListener("mousedown", ev => this.startTimer(ev), { passive: true });
        element.addEventListener("selectstart", () => false);
    }
    /****************************************/
    detach(element) {
    }
    /****************************************/
    startTimer(ev) {
        this._isLongPress = false;
        this._element.addEventListener("touchmove", this._cancelHandler, { passive: true });
        this._element.addEventListener("touchend", this._cancelHandler, { passive: true });
        this._element.addEventListener("mousemove", this._cancelHandler, { passive: true });
        this._element.addEventListener("mouseup", this._cancelHandler, { passive: true });
        this._timer = window.setTimeout(() => {
            this._isLongPress = true;
            if ("vibrate" in navigator)
                navigator.vibrate(50);
            this._handler.onLongPress(ev);
            this._timer = null;
        }, 490);
    }
    /****************************************/
    cancelTimer(ev) {
        //alert('cancel');
        if (this._isLongPress)
            ev.stopPropagation();
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = null;
        }
        this._element.removeEventListener("touchmove", this._cancelHandler);
        this._element.removeEventListener("touchend", this._cancelHandler);
        this._element.removeEventListener("mousemove", this._cancelHandler);
        this._element.removeEventListener("mouseup", this._cancelHandler);
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Behavoirs/RippleClickBehavoir.js

class RippleClickBehavoir_RippleClickBehavoir {
    attach(element) {
        element.addEventListener("pointerdown", this.onClick, { passive: true });
        element.classList.add("ripple");
    }
    /****************************************/
    detach(element) {
        element.removeEventListener("pointerdown", this.onClick);
    }
    /****************************************/
    async onClick(e) {
        const curTarget = e.currentTarget;
        curTarget.classList.remove("activated");
        await (0,PromiseUtils/* delayAsync */.$)(0);
        curTarget.classList.add("activated");
        await (0,PromiseUtils/* delayAsync */.$)(500);
        if (curTarget.classList.contains("activated"))
            curTarget.classList.remove("activated");
    }
}
/****************************************/
RippleClickBehavoir_RippleClickBehavoir.instance = new RippleClickBehavoir_RippleClickBehavoir();

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Behavoirs/ScrollCheckBehavoir.js


class ScrollCheckBehavoir_ScrollCheckBehavoir {
    async attach(element, viewModel) {
        await (0,PromiseUtils/* delayAsync */.$)(0);
        const scrollParent = element.classList.contains("scroll") || element.classList.contains("scroll-v") ? element : parentOfClass(element, "scroll");
        let isRequested = false;
        function computeScroll() {
            if (!viewModel.isScrollCheckActive || isRequested)
                return;
            isRequested = true;
            requestAnimationFrame(() => {
                let found = false;
                if (scrollParent != document.scrollingElement) {
                    let curItem = element;
                    found = false;
                    while (curItem != null) {
                        if (curItem == scrollParent) {
                            found = true;
                            break;
                        }
                        curItem = curItem.parentNode;
                    }
                }
                else
                    found = true;
                if (!found)
                    scrollParent.removeEventListener("scroll", computeScroll);
                else {
                    viewModel.onScroll({
                        offsetTop: scrollParent.scrollTop,
                        offsetBottom: scrollParent.scrollHeight - (scrollParent.scrollTop + scrollParent.clientHeight),
                        pageBottom: (scrollParent.scrollHeight - (scrollParent.scrollTop + scrollParent.clientHeight)) / scrollParent.clientHeight,
                        pageTop: scrollParent.scrollTop / scrollParent.clientHeight,
                        totPages: scrollParent.scrollHeight / scrollParent.clientHeight
                    });
                }
                isRequested = false;
            });
        }
        if (scrollParent != null) {
            if (scrollParent == document.scrollingElement)
                window.addEventListener("scroll", computeScroll, { passive: true });
            else
                scrollParent.addEventListener("scroll", computeScroll, { passive: true });
        }
    }
    /****************************************/
    detach(element, viewModel) {
    }
}
/****************************************/
ScrollCheckBehavoir_ScrollCheckBehavoir.instance = new ScrollCheckBehavoir_ScrollCheckBehavoir();

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Behavoirs/VibrateClickBehavoir.js
class VibrateClickBehavoir_VibrateClickBehavoir {
    attach(element) {
        element.addEventListener("click", this.onClick);
    }
    /****************************************/
    detach(element) {
        element.removeEventListener("click", this.onClick);
    }
    /****************************************/
    onClick(e) {
        if ("vibrate" in navigator)
            navigator.vibrate(50);
    }
}
/****************************************/
VibrateClickBehavoir_VibrateClickBehavoir.instance = new VibrateClickBehavoir_VibrateClickBehavoir();

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/Spinner.html
var Spinner = __webpack_require__(5395);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/Blocker.js






class Blocker_Blocker extends ContentView {
    constructor() {
        super({
            template: "ContentViewNested",
            content: new View_View({ template: "Spinner" }),
        });
        this.status = "hide";
        const builder = new TemplateBuilder_TemplateBuilder(this, document.body);
        builder.content(this);
    }
    /****************************************/
    attach(element) {
        this.element = element;
        element.addEventListener("mousedown", e => e.preventDefault(), { passive: true });
        element.addEventListener("touchstart", e => e.preventDefault(), { passive: true });
        if (this.status == "hide")
            this.element.style.display = "none";
    }
    /****************************************/
    async showAsync(content) {
        if (this.element)
            this.element.style.removeProperty("display");
        this.status = "showing";
        if (content)
            this.content = content;
        await (0,PromiseUtils/* delayAsync */.$)(0);
        if (this.status == "showing")
            this.status = "show";
    }
    /****************************************/
    async hideAsync() {
        this.content = new View_View({ template: "Spinner" }),
            this.status = "hiding";
        await (0,PromiseUtils/* delayAsync */.$)(500);
        if (this.status == "hiding") {
            this.status = "hide";
            if (this.element)
                this.element.style.display = "none";
        }
    }
}
registerType(Blocker_Blocker, "Blocker");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/SelfHostedPageHost.js



/****************************************/
class SelfHostedPageHost_SelfHostedPageHost extends View_View {
    /****************************************/
    constructor(config) {
        super(Object.assign({ template: "SinglePageHost" }, config));
        this._parentHost = window.parent["WebApp"]["app"]["pageHost"];
    }
    /****************************************/
    get(index) {
        return this._parentHost.get(index);
    }
    /****************************************/
    clearAsync() {
        this.current = null;
        return Promise.resolve();
    }
    /****************************************/
    goBackAsync() {
        return this._parentHost.goBackAsync();
    }
    /****************************************/
    goForwardAsync() {
        return this._parentHost.goForwardAsync();
    }
    /****************************************/
    bringFrontAsync(page) {
        if (page == this.current)
            return Promise.resolve();
        return this._parentHost.bringFrontAsync(page);
    }
    /****************************************/
    loadAsync(page, options) {
        if (!this.current) {
            page.host = this;
            this.current = page;
            page.loadAsync();
            page.status = "active";
            return Promise.resolve(page);
        }
        return this._parentHost.loadAsync(page, options);
    }
    /****************************************/
    find(nameOrType) {
        if (this.current) {
            if ((0,TypeCheck/* isString */.HD)(nameOrType) && nameOrType == getTypeName(this.current))
                return this.current;
            if (getType(this.current) == nameOrType)
                return this.current;
        }
        return this._parentHost.find(nameOrType);
    }
    /****************************************/
    async goToAsync(index) {
        this._parentHost.currentIndex = index;
        return Promise.resolve();
    }
    /****************************************/
    get canGoBack() {
        return this._parentHost.canGoBack;
    }
    /****************************************/
    get currentIndex() {
        return this._parentHost.currentIndex;
    }
    set currentIndex(value) {
        this._parentHost.currentIndex = value;
    }
    /****************************************/
    get pageCount() {
        return this._parentHost.pageCount;
    }
}
registerType(SelfHostedPageHost_SelfHostedPageHost, "SelfHostedPageHost");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/Page.js



/****************************************/
class Page extends BindableObject_BindableObject {
    constructor(config) {
        super();
        /****************************************/
        this.url = null;
        this.host = null;
        this.view = null;
        this.title = null;
        this.subTitle = null;
        this.name = null;
        this.status = "notloaded";
        this.args = null;
        this.bindConfig("url", config);
        this.bindConfigString("title", config);
        this.bindConfigString("subTitle", config);
        this.bindConfig("view", config);
        if (config) {
            if (config.name)
                this.name = config.name;
        }
    }
    /****************************************/
    getState() {
        return {};
    }
    /****************************************/
    setState(state) {
    }
    /****************************************/
    handleError(source, error) {
        Global/* App.handleError */.gV.handleError(source, error);
    }
    /****************************************/
    async loadAsync() {
        if (this.status == "notloaded" || this.status == "error") {
            const op = Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading page: " + (this.title ? this.title : (this.url ? this.url : getTypeName(this))) });
            this.status = "loading";
            try {
                await this.loadWorkAsync();
            }
            catch (e) {
                this.status = "error";
                Global/* App.handleError */.gV.handleError(this, e);
            }
            finally {
                op.end();
                this.status = "loaded";
            }
        }
    }
    /****************************************/
    loadWorkAsync() {
        return Promise.resolve();
    }
    /****************************************/
    refreshAsync() {
        return Promise.resolve();
    }
    /****************************************/
    async closeAsync(result) {
        if ("goBackAsync" in this.host)
            await this.host.goBackAsync();
        this.status = "closed";
        return true;
    }
}
registerType(Page, "Page");

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ItemsView.html
var ItemsView = __webpack_require__(6506);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ItemsView.js




/********************************************/
class ItemsView_ItemsView extends ContentView {
    constructor(config) {
        super(Object.assign({ content: ObservableList_observableListOf() }, config));
        this._updateCount = 0;
        this.emptyView = null;
        this.content.subscribe({
            onItemAdded: (item) => {
                if (this._updateCount == 0)
                    this.onItemAdded(item);
            },
            onItemRemoved: (item) => {
                if (this._updateCount == 0)
                    this.onItemRemoved(item);
            }
        });
        this.bindConfig("emptyView", config);
    }
    /********************************************/
    initItems() {
        if (this.content)
            this.content.toArray().forEach(a => this.onItemAdded(a));
    }
    /********************************************/
    beginUpdate() {
        this._updateCount++;
    }
    /********************************************/
    endUpdate() {
        this._updateCount--;
    }
    /********************************************/
    onItemAdded(item) {
    }
    /********************************************/
    onItemRemoved(item) {
    }
}
registerType(ItemsView_ItemsView, "ItemsView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/Panel.js





/********************************************/
class Panel_Panel extends ItemsView_ItemsView {
    constructor(config) {
        super(Object.assign({ template: "ItemsView" }, config));
        if (config === null || config === void 0 ? void 0 : config.viewContent) {
            if (Array.isArray(config.viewContent))
                config.viewContent.forEach(a => this.addView(a));
            else
                this.addView(config.viewContent);
        }
    }
    /********************************************/
    loadAsync() {
        return loadAllAsync(this.content);
    }
    /********************************************/
    clear() {
        this.content.clear();
    }
    /********************************************/
    addView(view) {
        this.content.add(view);
        return view;
    }
    /********************************************/
    removeView(view) {
        this.content.remove(view);
    }
    replaceView(oldView, newView) {
        let index;
        if ((0,TypeCheck/* isString */.HD)(oldView))
            index = (0,Linq/* linq */.k)(this.content).indexOf(a => "name" in a && a.name == oldView);
        else
            index = this.content.indexOf(oldView);
        if (index != -1)
            this.content.set(index, newView);
    }
    /********************************************/
    onItemAdded(item) {
        if (item)
            item.parentView = this;
    }
    /********************************************/
    onItemRemoved(item) {
        if (item && item.parentView == this)
            item.parentView = null;
    }
}
registerType(Panel_Panel, "Panel");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Activities/Activity.js




/****************************************/
class Activity extends Page {
    constructor(config) {
        super(config);
        this._viewItems = [];
        this.view = new Panel_Panel({ name: ViewUtils_formatForCss(getTypeName(this)), styles: ["vertical", "activity", "page", "relative"] });
        //this.view.isCacheEnabled = true;
        if (this.name)
            this.view.styles.push(this.name);
    }
    /****************************************/
    get result() {
        return new Promise(res => this._resultResolve = res);
    }
    /****************************************/
    activateAsync() {
        return Promise.resolve();
    }
    /****************************************/
    deactivateAsync(reason) {
        return Promise.resolve();
    }
    /****************************************/
    async closeAsync(result) {
        const closeResult = await super.closeAsync(result);
        if (this._resultResolve)
            this._resultResolve(result);
        return closeResult;
    }
    /****************************************/
    loadWorkAsync() {
        return this.createAsync();
    }
    /****************************************/
    createAsync() {
        return Promise.resolve();
    }
    /****************************************/
    static isActivity(obj) {
        return isInstanceOf(obj, Activity);
    }
}
registerType(Activity, "Activity");

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/PageHost.html
var PageHost = __webpack_require__(5471);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/SlidePageHost.js







/****************************************/
class SlidePageHost_SlidePageHost extends View_View {
    /****************************************/
    constructor(config) {
        super(config);
        this._activeViewIndex = 0;
        /****************************************/
        this.defaultTransaction = "pop-up-down";
        this.activeTransaction = "none";
        this.pageViews = [{ content: null, className: null },
            { content: null, className: null }];
        this.clearAsync();
        if (config) {
            if (config.defaultTransaction)
                this.defaultTransaction = config.defaultTransaction;
        }
    }
    /****************************************/
    clearAsync() {
        this._pageStack = [];
        this._currentIndex = -1;
        this._activeViewIndex = 0;
        this.pageViews[0].content = null;
        this.pageViews[0].className = "immediate next";
        this.pageViews[1].content = null;
        this.pageViews[1].className = "immediate prev";
    }
    /****************************************/
    async goBackAsync() {
        if (this._currentIndex > 0)
            await this.goToAsync(this._currentIndex - 1);
    }
    /****************************************/
    async goForwardAsync() {
        if (this._currentIndex > 0)
            await this.goToAsync(this._currentIndex + 1);
    }
    /****************************************/
    async bringFrontAsync(page) {
        const pageIndex = (0,Linq/* linq */.k)(this._pageStack).indexOf(a => a.page == page);
        if (pageIndex != -1)
            await page.host.goToAsync(pageIndex);
    }
    /****************************************/
    async loadAsync(page, options) {
        if (this.current == page) {
            await page.refreshAsync();
            return page;
        }
        this.cancelHidePrev();
        const op = Global/* Services.operation.begin */.K9.operation.begin("Hosting new page");
        try {
            if (this.current && Activity.isActivity(this.current))
                await this.current.deactivateAsync("replace");
            if ((options === null || options === void 0 ? void 0 : options.loadMode) == "clear")
                this._currentIndex = -1;
            if ((options === null || options === void 0 ? void 0 : options.loadMode) == "replace" && this.currentIndex >= 0)
                this._currentIndex--;
            while (this._pageStack.length > this._currentIndex + 1)
                this._pageStack.splice(this._pageStack.length - 1, 1);
            this._pageStack.push({ page: page, options: options });
            if (options && options.transaction)
                this.activeTransaction = options.transaction;
            else
                this.activeTransaction = this.defaultTransaction;
            this._currentIndex++;
            page.host = this;
            page.view.parentView = this;
            this.pageViews[this.backIndex].className = "immediate next";
            await (0,PromiseUtils/* delayAsync */.$)(0);
            await page.loadAsync();
            if (this._currentIndex > 0) {
                this.pageViews[this.backIndex].content = page.view;
                await (0,PromiseUtils/* delayAsync */.$)(0);
                this.pageViews[this.frontIndex].className = "animate prev";
                this.pageViews[this.backIndex].className = "animate active";
                this._activeViewIndex = this.backIndex;
                this.hidePrev();
            }
            else {
                this.pageViews[this.frontIndex].content = page.view;
                this.pageViews[this.frontIndex].className = "active";
            }
            page.status = "active";
            if (Activity.isActivity(this.current))
                await this.current.activateAsync();
        }
        catch (e) {
            Global/* App.handleError */.gV.handleError(this, e);
        }
        finally {
            op.end();
        }
        return page;
    }
    /****************************************/
    get(index) {
        return this._pageStack[index].page;
    }
    /****************************************/
    async goToAsync(index) {
        if (index < 0 || index >= this._pageStack.length || index == this._currentIndex)
            return;
        this.cancelHidePrev();
        const op = Global/* Services.operation.begin */.K9.operation.begin("Going to " + index);
        try {
            if (Activity.isActivity(this.current))
                await this.current.deactivateAsync("replace");
            this.current.status = "hidden";
            const options = this._pageStack[this._currentIndex].options;
            if (options && options.transaction)
                this.activeTransaction = options.transaction;
            else
                this.activeTransaction = this.defaultTransaction;
            this._currentIndex = index;
            if (this.current.view.parentView == this)
                this.current.view.parentView = null;
            this.pageViews[this.backIndex].content = this._pageStack[this._currentIndex].page.view;
            this.pageViews[this.backIndex].className = "immmediate prev";
            await (0,PromiseUtils/* delayAsync */.$)(0);
            this.pageViews[this.frontIndex].className = "animate next";
            this.pageViews[this.backIndex].className = "animate active";
            this._activeViewIndex = this.backIndex;
            this.current.status = "active";
            if (Activity.isActivity(this.current))
                await this.current.activateAsync();
            this.hidePrev();
        }
        catch (e) {
            Global/* App.handleError */.gV.handleError(this, e);
        }
        finally {
            op.end();
        }
    }
    /****************************************/
    cancelHidePrev() {
        if (this._hideTimerId) {
            clearTimeout(this._hideTimerId);
            this._hideTimerId = null;
        }
    }
    /****************************************/
    hidePrev() {
        this._hideTimerId = window.setTimeout(() => {
            if (!this._hideTimerId)
                return;
            this.pageViews[this.backIndex].className = "prev hide";
        }, 4000);
    }
    /****************************************/
    onActivePageChanged() {
    }
    /****************************************/
    onTransactionEnd() {
    }
    find(nameOrType) {
        let curPage;
        if (typeof nameOrType == "string")
            curPage = (0,Linq/* linq */.k)(this._pageStack).first(a => a.page.name == nameOrType);
        else
            curPage = (0,Linq/* linq */.k)(this._pageStack).first(a => Object.getPrototypeOf(a.page).constructor == nameOrType);
        if (curPage)
            return curPage.page;
    }
    /****************************************/
    get current() {
        return this._currentIndex == -1 ? undefined : this._pageStack[this._currentIndex].page;
    }
    /****************************************/
    get canGoBack() {
        return this._currentIndex > 0;
    }
    /****************************************/
    get frontIndex() {
        return this._activeViewIndex;
    }
    /****************************************/
    get backIndex() {
        return (this._activeViewIndex + 1) % 2;
    }
    /****************************************/
    get currentIndex() {
        return this._currentIndex;
    }
    set currentIndex(value) {
        if (this._currentIndex == value)
            return;
        this.goToAsync(value);
    }
    /****************************************/
    get pageCount() {
        return this._pageStack.length;
    }
}
registerType(SlidePageHost_SlidePageHost, "SlidePageHost");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Items/ItemsObserver.js
/****************************************/
class ItemsObserver_ItemsObserver {
    constructor() {
        this._listener = {};
    }
    /****************************************/
    unregister(itemType, listener) {
        if (itemType in this._listener) {
            const listeners = this._listener[itemType];
            const index = listeners.indexOf(listener);
            if (index - 1)
                listeners.splice(index, 1);
        }
    }
    /****************************************/
    register(itemType, listener) {
        if (!(itemType in this._listener))
            this._listener[itemType] = [listener];
        else {
            if (this._listener[itemType].indexOf(listener) == -1)
                this._listener[itemType].push(listener);
        }
    }
    /****************************************/
    clear() {
        this._listener = {};
    }
    /****************************************/
    notifyAdded(args) {
        if (args.itemType in this._listener)
            this._listener[args.itemType].forEach(a => a.onItemAdded ? a.onItemAdded(args) : undefined);
    }
    /****************************************/
    notifyRemoved(args) {
        if (args.itemType in this._listener)
            this._listener[args.itemType].forEach(a => a.onItemRemoved ? a.onItemRemoved(args) : undefined);
    }
    /****************************************/
    notifyChanged(args) {
        if (args.itemType in this._listener)
            this._listener[args.itemType].forEach(a => a.onItemChanged ? a.onItemChanged(args) : undefined);
    }
}

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Services/DynamicPageManager.js
var Services_DynamicPageManager = __webpack_require__(3894);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ActionBar.html
var ActionBar = __webpack_require__(554);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/Attach.html
var Attach = __webpack_require__(6574);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/BooleanEditor.html
var BooleanEditor = __webpack_require__(245);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/BottomSheet.html
var BottomSheet = __webpack_require__(1066);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ConsoleView.html
var ConsoleView = __webpack_require__(4117);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/Container.html
var Container = __webpack_require__(1906);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ContentView.html
var Templates_ContentView = __webpack_require__(751);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/CounterView.html
var CounterView = __webpack_require__(939);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/DateEditor.html
var DateEditor = __webpack_require__(3325);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/DateEditorCombo.html
var DateEditorCombo = __webpack_require__(7501);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/Drawer.html
var Drawer = __webpack_require__(4212);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/FileUploadView.html
var FileUploadView = __webpack_require__(3006);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/HtmlView.html
var HtmlView = __webpack_require__(8679);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ImageView.html
var ImageView = __webpack_require__(7598);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ItemsEditor.html
var ItemsEditor = __webpack_require__(4581);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ItemView.html
var ItemView = __webpack_require__(7641);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ListView.html
var Templates_ListView = __webpack_require__(6228);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/LocationView.html
var LocationView = __webpack_require__(4726);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/MediaEditor.html
var MediaEditor = __webpack_require__(1368);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/MediaView.html
var MediaView = __webpack_require__(163);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/MessageBox.html
var MessageBox = __webpack_require__(6932);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/MultiItemPicker.html
var MultiItemPicker = __webpack_require__(3356);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/NavBar.html
var Templates_NavBar = __webpack_require__(8958);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/PermissionRequestItemView.html
var PermissionRequestItemView = __webpack_require__(5142);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/PopUpContent.html
var PopUpContent = __webpack_require__(1556);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ProgressView.html
var Templates_ProgressView = __webpack_require__(7760);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/PropertyView.html
var PropertyView = __webpack_require__(8777);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/RemovableItemView.html
var RemovableItemView = __webpack_require__(7183);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/SearchView.html
var SearchView = __webpack_require__(9857);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/SectionEditor.html
var SectionEditor = __webpack_require__(3818);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/SectionsView.html
var SectionsView = __webpack_require__(7575);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/SelectableItemView.html
var SelectableItemView = __webpack_require__(4182);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/SimpleItemView.html
var SimpleItemView = __webpack_require__(6948);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/SingleItemPicker.html
var SingleItemPicker = __webpack_require__(940);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/SingleItemSelector.html
var SingleItemSelector = __webpack_require__(9307);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/SnackBar.html
var SnackBar = __webpack_require__(1977);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/TextEditor.html
var TextEditor = __webpack_require__(8350);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/TextView.html
var TextView = __webpack_require__(1814);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/Toast.html
var Toast = __webpack_require__(5972);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/VideoView.html
var VideoView = __webpack_require__(8164);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/WebView.html
var WebView = __webpack_require__(5996);
// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/WizardView.html
var WizardView = __webpack_require__(9095);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/AllTemplates.js



















































;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Abstraction/IGestureListener.js
var IGestureListener_GestureType;
(function (GestureType) {
    GestureType[GestureType["SwipeLeft"] = 0] = "SwipeLeft";
})(IGestureListener_GestureType || (IGestureListener_GestureType = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Behavoirs/GestureBehavoir.js

class GestureBehavoir_GesturekBehavoir {
    constructor() {
        this._onPointerUpBind = this.onPointerUp.bind(this);
        this._onPointerDownBind = this.onPointerDown.bind(this);
        this._onPointerMoveBind = this.onPointerMove.bind(this);
    }
    attach(element, viewModel) {
        this._element = element;
        this._listener = viewModel;
        this._element.addEventListener("pointerdown", this._onPointerDownBind, { passive: true });
    }
    /****************************************/
    onPointerUp(ev) {
        this.endGesture(ev);
    }
    /****************************************/
    onPointerDown(ev) {
        this._downPoint = this.getPoint(ev);
        this._element.addEventListener("pointerup", this._onPointerUpBind, { passive: true });
        this._element.addEventListener("pointermove", this._onPointerMoveBind, { passive: true });
        //this._element.setPointerCapture(ev.pointerId);
    }
    /****************************************/
    onPointerMove(ev) {
        const point = this.getPoint(ev);
        const angle = ((Math.atan2(point.y - this._downPoint.y, point.x - this._downPoint.x) * 180 / Math.PI) + 360) % 360;
        const distance = Math.sqrt(Math.pow(point.y - this._downPoint.y, 2) + Math.pow(point.x - this._downPoint.x, 2));
        //console.log(point, ev.button, angle, distance);
        if (distance > 70) {
            if (angle > 150 && angle < 220)
                this._listener.onGesture({ type: IGestureListener_GestureType.SwipeLeft });
            this.endGesture(ev);
        }
    }
    /****************************************/
    getPoint(ev) {
        return {
            x: ev.screenX,
            y: ev.screenY
        };
    }
    /****************************************/
    endGesture(ev) {
        //this._element.releasePointerCapture(ev.pointerId);
        this._element.removeEventListener("pointerup", this._onPointerUpBind);
        this._element.removeEventListener("pointermove", this._onPointerMoveBind);
    }
    /****************************************/
    detach(element, viewModel) {
        element.removeEventListener("pointerdown", this._onPointerDownBind);
        element.removeEventListener("pointermove", this._onPointerMoveBind);
        element.removeEventListener("pointerup", this._onPointerUpBind);
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Behavoirs/ContextMenuBehavoir.js


/****************************************/
class ContextMenuBehavoir_ContextMenuBehavoir {
    attach(element, viewModel) {
        const showMenu = (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            ev.stopImmediatePropagation();
            const items = viewModel.getContextActions();
            if (items) {
                const menu = new ContextMenu_ContextMenu({ actions: items });
                menu.showAsync(null, ev);
            }
        };
        if (isTouchDevice())
            element.addEventListener("selectstart", ev => {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                return false;
            });
        element.addEventListener("contextmenu", ev => showMenu(ev));
    }
    /****************************************/
    detach(element) {
    }
}
ContextMenuBehavoir_ContextMenuBehavoir.instance = new ContextMenuBehavoir_ContextMenuBehavoir();

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/ViewApplication.js
;
























class ViewApplication extends BindableObject_BindableObject {
    constructor() {
        super();
        this._blockCount = 0;
        this.pageHost = null;
        this.appName = null;
        this.view = null;
        this.language = null;
        this.prop("language").subscribe(() => this.updateLanguage());
    }
    /****************************************/
    async runAsync(args) {
        this.language = (window.navigator.language).split("-")[0].toUpperCase();
        window.addEventListener("error", ev => this.handleError(ev.srcElement, ev.error, ev.message));
        this._startupArgs = Object.assign({ baseUrl: "" }, args);
        if (this.baseUrl.length == 0 || this.baseUrl[this.baseUrl.length - 1] != "/")
            this.baseUrl += "/";
        this.initServices();
        await this.configureServicesAsync();
        if (this.isSelfHosted) {
            this.pageHost = new SelfHostedPageHost_SelfHostedPageHost();
            this.view = this.pageHost;
            //window["WebApp"]["Actions"] = window.parent["WebApp"]["Actions"];
        }
        else {
            this.pageHost = new HIstoryPageHost_HistoryPageHost(this.createPageHost());
            this.view = this.pageHost.innerHost;
        }
        Global/* Services.pageHost */.K9.pageHost = this.pageHost;
        document.title = this.appName;
        Functions_template(document.body, this.view.template, this.view);
        this.onStarted();
    }
    /****************************************/
    updateLanguage() {
        document.documentElement.lang = this.language;
        Core_StringTable/* StringTable.currentConfig */.M.currentConfig = {
            language: this.language
        };
    }
    /****************************************/
    onStarted() {
    }
    /****************************************/
    handleError(source, error, message) {
        console.error("Source: ", source, "Error: ", error, "Message: ", message);
    }
    /****************************************/
    formatTitle(title) {
        if (this.appName && title)
            return this.appName + " - " + title;
        if (title)
            return title;
        return this.appName;
    }
    /****************************************/
    createPageHost() {
        return new SlidePageHost_SlidePageHost();
    }
    /****************************************/
    initServices() {
        Global/* Services.application */.K9.application = this;
        Global/* Services.pageManager */.K9.pageManager = new Services_DynamicPageManager/* DynamicPageManager */.I();
        Global/* Services.itemsObserver */.K9.itemsObserver = new ItemsObserver_ItemsObserver();
        Global/* Services.httpClient */.K9.httpClient = new XHRHttpClient_XHRHttpClient();
        Global/* Services.cache */.K9.cache = new LocalStorageCache_LocalStorageCache();
        Global/* Services.dbStorage */.K9.dbStorage = new DbStorage_DbStorage();
        Global/* Services.operation */.K9.operation = new Operation_ViewOperationManager();
        if (this.startupArgs.gaId)
            Global/* Services.analytics */.K9.analytics = new GoogleAnalytics_GoogleAnalytics(this.startupArgs.gaId);
        IBehavoir_behavoirCatalog.attach = () => AttachBehavoir_AttachBehavoir.instance;
        IBehavoir_behavoirCatalog.ripple = () => RippleClickBehavoir_RippleClickBehavoir.instance;
        IBehavoir_behavoirCatalog.vibrate = () => VibrateClickBehavoir_VibrateClickBehavoir.instance;
        IBehavoir_behavoirCatalog["scroll-check"] = () => ScrollCheckBehavoir_ScrollCheckBehavoir.instance;
        IBehavoir_behavoirCatalog["long-press"] = () => new LongPresssBehavoir_LongPressBehavoir();
        IBehavoir_behavoirCatalog.gesture = () => new GestureBehavoir_GesturekBehavoir();
        IBehavoir_behavoirCatalog["context-menu"] = () => ContextMenuBehavoir_ContextMenuBehavoir.instance;
    }
    /****************************************/
    configureServicesAsync() {
        return Promise.resolve();
    }
    /****************************************/
    block(content) {
        this._blockCount++;
        if (!this._blocker) {
            this._blocker = new Blocker_Blocker();
            setTimeout(() => this.restoreBlock(content));
        }
        else
            this.restoreBlock(content);
    }
    /****************************************/
    restoreBlock(content) {
        if (this._blockCount > 0 && this._blocker.status != "show" && this._blocker.status != "showing")
            this._blocker.showAsync(content);
        else if (content)
            this._blocker.content = content;
    }
    /****************************************/
    unblock(force = false) {
        if (!this._blocker)
            return;
        if (force) {
            if (this._blocker.status == "show" || this._blocker.status == "showing")
                this._blocker.hideAsync();
        }
        else {
            if (--this._blockCount <= 0)
                this._blocker.hideAsync();
        }
    }
    /****************************************/
    mainAsync() {
        return Promise.resolve(null);
    }
    /****************************************/
    get baseUrl() {
        return this._startupArgs.baseUrl;
    }
    get isDev() {
        return this._startupArgs["env"] == "Development";
    }
    set baseUrl(value) {
        this._startupArgs.baseUrl = value;
    }
    get startupArgs() {
        return this._startupArgs;
    }
    get isSelfHosted() {
        try {
            return window.parent != window && window.parent["WebApp"] && window.parent["WebApp"]["App"];
        }
        catch (e) {
            return false;
        }
    }
    get hasMain() {
        return false;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Abstraction/IAction.js
var IAction_ActionPriority;
(function (ActionPriority) {
    ActionPriority[ActionPriority["Primary"] = 0] = "Primary";
    ActionPriority[ActionPriority["Secondary"] = 1] = "Secondary";
    ActionPriority[ActionPriority["Evidence"] = 2] = "Evidence";
})(IAction_ActionPriority || (IAction_ActionPriority = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Abstraction/IPageHost.js
var PageHostMode;
(function (PageHostMode) {
    PageHostMode[PageHostMode["Default"] = 0] = "Default";
    PageHostMode[PageHostMode["WebView"] = 1] = "WebView";
})(PageHostMode || (PageHostMode = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ActionBar.js







/****************************************/
class ActionBar_ActionBar extends ViewComponent {
    constructor(config) {
        super(config);
        /****************************************/
        this.actions = ObservableList_observableListOf();
        this.mainAction = "none";
        this.navigationMenu = null;
        this.title = null;
        this.icon = null;
        this.content = null;
        this.selectionManager = null;
        this.bindConfig("mainAction", config);
        this.bindConfig("navigationMenu", config);
        this.bindConfigString("title", config, DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfig("icon", config);
        this.actions.subscribe({
            onItemAdded: this.onActionAdded.bind(this),
            onItemRemoved: this.onActionRemoved.bind(this)
        });
        if (config) {
            if (config.content)
                this.content = config.content;
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
            if (config.onBack)
                this.back = config.onBack;
        }
    }
    /****************************************/
    onActionRemoved(action) {
        if (action && action.parentView == this)
            action.parentView = null;
    }
    /****************************************/
    onActionAdded(action) {
        if (action)
            action.parentView = this;
    }
    /****************************************/
    async showNavigationMenu() {
        if (this.navigationMenu)
            this.navigationMenu.showAsync();
    }
    /****************************************/
    addAction(action) {
        this.actions.add(ActionView_ActionView.fromActionIcon(action));
    }
    /****************************************/
    back() {
    }
    /****************************************/
    startSelection() {
        if (!this.selectionManager)
            this.selectionManager = new SelectionManager();
        this.selectionManager.isActive = true;
        return this.selectionManager;
    }
}
registerType(ActionBar_ActionBar, "ActionBar");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/NavBar.js





/****************************************/
class NavBarItem extends IconTextView_IconTextView {
    constructor(config) {
        super(config);
        /****************************************/
        this.name = null;
        this.status = "";
        this.badge = null;
        this.behavoirs = [];
        this.content = null;
        this.prop("status");
        this.bindConfig("badge", config);
        this.bindConfig("behavoirs", config);
        this.bindConfig("content", config);
        if (config)
            this.name = config.name;
    }
    /****************************************/
    select() {
        throw "Not implemented";
    }
}
/****************************************/
class NavBar_NavBar extends ItemsView_ItemsView {
    constructor(config) {
        super(config);
        /****************************************/
        this.selectedItem = null;
        this.itemTemplate = "IconTextView";
        this.itemBehavoirs = [];
        this.bindConfig("itemTemplate", config);
        this.bindConfig("itemBehavoirs", config);
        if (config) {
            if (config.items)
                config.items.forEach(a => this.addItem(a));
            if (config.onItemSelected) {
                this.onSelectedItemChanged = (a, b) => {
                    NavBar_NavBar.prototype.onSelectedItemChanged.bind(this)(a, b);
                    config.onItemSelected(a);
                };
            }
        }
        this.bindConfig("selectedItem", config, {
            convertTo: a => this.getItem(a),
            convertFrom: a => a ? a.name : undefined
        }, this.onSelectedItemChanged);
    }
    /****************************************/
    getItem(name) {
        return (0,Linq/* linq */.k)(this.content).first(a => a.name == name);
    }
    /****************************************/
    selectItem(name) {
        this.selectedItem = this.getItem(name);
    }
    /****************************************/
    addItem(config) {
        const item = this.createItem(config);
        this.content.add(item);
        return item;
    }
    /****************************************/
    createItem(config) {
        const item = new NavBarItem(Object.assign({ template: this.prop("itemTemplate"), behavoirs: this.prop("itemBehavoirs") }, config));
        item.parentView = this;
        item.select = () => this.selectedItem = item;
        return item;
    }
    /****************************************/
    onSelectedItemChanged(newItem, oldItem) {
        if (oldItem)
            oldItem.status = "";
        if (newItem)
            newItem.status = "active";
    }
}
registerType(NavBarItem, "NavBarItem");
registerType(NavBar_NavBar, "NavBar");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/SearchView.js



/****************************************/
class SearchView_SearchView extends ActionView_ActionView {
    /****************************************/
    constructor(config) {
        super(Object.assign({ name: "search", template: "SearchView", content: "fas fa-search", tooltip: "Ricerca" }, config));
        this._lastSearchText = null;
        /****************************************/
        this.searchText = null;
        this.isExpanded = false;
        this.hasFocus = false;
        this.poolInterval = 200;
        this.bindConfig("isExpanded", config);
        this.bindConfig("searchText", config);
        this.prop("hasFocus").subscribe(value => this.onFocusChanged(value));
        if (config) {
            if (config.poolInterval)
                this.poolInterval = config.poolInterval;
            if (config.searchAsync)
                this.doSearchAsync = config.searchAsync;
        }
    }
    /****************************************/
    onFocusChanged(value) {
        if (value) {
            this._lastSearchText = this.searchText;
            this.poolSearchTextAsync();
        }
    }
    /****************************************/
    async poolSearchTextAsync() {
        while (this.hasFocus) {
            if (this.searchText != this._lastSearchText) {
                this._lastSearchText = this.searchText;
                await this.searchAsync(this._lastSearchText);
            }
            await (0,PromiseUtils/* delayAsync */.$)(this.poolInterval);
        }
    }
    /****************************************/
    executeWorkAsync() {
        if (!this.isExpanded) {
            this.isExpanded = true;
            this.hasFocus = true;
        }
        return Promise.resolve();
    }
    /****************************************/
    async searchAsync(text) {
        this.status = "searching";
        await (0,PromiseUtils/* delayAsync */.$)(0);
        try {
            await this.doSearchAsync(text);
        }
        finally {
            this.status = "loaded";
        }
    }
    /****************************************/
    doSearchAsync(text) {
        return Promise.resolve();
    }
    /****************************************/
    clear() {
        this.searchText = "";
    }
    /****************************************/
    close() {
        this.isExpanded = false;
    }
}
registerType(SearchView_SearchView, "SearchView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Activities/ContentActivity.js












var ContentSelector;
(function (ContentSelector) {
    ContentSelector[ContentSelector["Manual"] = 1] = "Manual";
    ContentSelector[ContentSelector["Tabs"] = 2] = "Tabs";
    ContentSelector[ContentSelector["BottomNav"] = 3] = "BottomNav";
})(ContentSelector || (ContentSelector = {}));
var PrimaryActionMode;
(function (PrimaryActionMode) {
    PrimaryActionMode[PrimaryActionMode["Floating"] = 1] = "Floating";
    PrimaryActionMode[PrimaryActionMode["Button"] = 2] = "Button";
    PrimaryActionMode[PrimaryActionMode["FloatingFull"] = 3] = "FloatingFull";
})(PrimaryActionMode || (PrimaryActionMode = {}));
/****************************************/
class ContentActivity_ContentActivity extends Activity {
    /****************************************/
    constructor(config) {
        super(Object.assign({}, config));
        this._isContentLoaded = false;
        this._selector = ContentSelector.Tabs;
        this._isDeactivating = false;
        this.activeContent = null;
        this.activeContentProvider = null;
        this.providers = [];
        this.menu = null;
        this.actions = [];
        this.floatingStyle = ["vertical", "item-absolute", "bottom", "fill-h", "center-items-h"];
        this.contentStyle = ["vertical", "scroll"];
        this.bindConfig("activeContent", config);
        if (config.providers)
            this.providers = config.providers;
        if (config.menu)
            this.menu = config.menu;
        if (config.selector)
            this._selector = config.selector;
        if (config.actions)
            this.actions = config.actions;
        this.prop("host").subscribe(() => {
            var _a, _b;
            if (((_a = this._actionBar) === null || _a === void 0 ? void 0 : _a.mainAction) == "none" && ((_b = this.host) === null || _b === void 0 ? void 0 : _b.canGoBack))
                this._actionBar.mainAction = "back";
        });
    }
    /****************************************/
    async closeAsync(result) {
        await this.deactivateAsync("close");
        return await super.closeAsync(result);
    }
    /****************************************/
    activateAsync() {
        var _a, _b;
        if (!this._isContentLoaded)
            return this.refreshAsync();
        if ((_a = this.activeContentProvider) === null || _a === void 0 ? void 0 : _a.activateAsync)
            return (_b = this.activeContentProvider) === null || _b === void 0 ? void 0 : _b.activateAsync("refresh");
        return Promise.resolve();
    }
    /****************************************/
    async deactivateAsync(reason) {
        var _a;
        if (this._isDeactivating)
            return;
        try {
            this._isDeactivating = true;
            if ((_a = this.activeContentProvider) === null || _a === void 0 ? void 0 : _a.deactivateAsync)
                await this.activeContentProvider.deactivateAsync(reason);
        }
        finally {
            this._isDeactivating = false;
        }
    }
    /****************************************/
    refreshAsync() {
        if (this.activeContentProvider)
            return this.loadContentAsync(this.activeContentProvider, true);
        return this.loadActiveContentAsync(true);
    }
    /****************************************/
    notifyContentChanged(provider) {
        this.loadContentAsync(provider, true);
    }
    /****************************************/
    startSelection() {
        return this._actionBar.startSelection();
    }
    /****************************************/
    loadActiveContentAsync(force) {
        const provider = (0,Linq/* linq */.k)(this.providers).first(a => a.info.name == this.activeContent);
        return this.loadContentAsync(provider, force);
    }
    /****************************************/
    async loadWorkAsync() {
        await this.createAsync();
        if (this.activeContentProvider)
            this.activeContent = this.activeContentProvider.info.name;
    }
    /****************************************/
    async loadContentAsync(provider, force) {
        var _a, _b, _c;
        const isContentChanged = this.activeContentProvider != provider;
        if (!isContentChanged && !force)
            return;
        if (isContentChanged && ((_a = this.activeContentProvider) === null || _a === void 0 ? void 0 : _a.deactivateAsync))
            (_b = this.activeContentProvider) === null || _b === void 0 ? void 0 : _b.deactivateAsync("replace");
        this.activeContentProvider = provider;
        if (!force && (this.status == "notloaded" || this.status == "loading" || this.status == "closed")) {
            console.debug("Skip loading content: " + provider.info.name);
            return;
        }
        const op = Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading content: " + provider.info.name });
        try {
            const content = await provider.getContentAsync(this);
            this.title = this.formatTitle(Helpers_Format/* Format.title */.E.title(content.title));
            if (content.url)
                this.url = content.url;
            this._contentView.clear();
            this._contentView.styles = mergeArrays((_c = content.styles) !== null && _c !== void 0 ? _c : this.contentStyle, ["activity-content"]);
            this._contentView.name = provider.info.name;
            this._contentView.buildStyles();
            if (content.views)
                content.views.forEach(a => this._contentView.addView(a));
            this._actionBar.actions.clear();
            if (this._floatingView)
                this._floatingView.clear();
            let actionPanel;
            if (content.actions) {
                content.actions.forEach(action => {
                    var _a;
                    if (action.priority == null || action.priority == IAction_ActionPriority.Secondary)
                        this._actionBar.actions.add(this.createActionView(action));
                    else if (action.priority == IAction_ActionPriority.Primary) {
                        if (content.actionMode === undefined || content.actionMode != PrimaryActionMode.Button) {
                            this._floatingView.visible = true;
                            this._floatingView.addView(this.createActionView(action, { styles: ["floating", ...(_a = action.styles) !== null && _a !== void 0 ? _a : []] }));
                            if (content.actionMode == PrimaryActionMode.FloatingFull)
                                this._floatingView.addStyle("full");
                            else
                                this._floatingView.removeStyle("full");
                        }
                        else {
                            this._floatingView.visible = false;
                            const actionView = ActionView_ActionView.fromAction(action, { template: "ActionButton" });
                            if (!actionPanel) {
                                actionPanel = new Panel_Panel({
                                    name: "actions",
                                    styles: ["vertical", "margin-items-v"],
                                });
                                this._contentView.addView(actionPanel);
                            }
                            actionPanel.addView(actionView);
                        }
                    }
                });
            }
            if (content.searchAsync) {
                const searchView = new SearchView_SearchView({
                    name: "search-expanded",
                    isExpanded: true,
                    searchAsync: content.searchAsync
                });
                this._actionBar.actions.add(searchView);
            }
            this._floatingView.visible = this._floatingView.content.count > 0;
            this.actions.forEach(a => this._actionBar.actions.add(a));
            await this._contentView.loadAsync();
            if (provider === null || provider === void 0 ? void 0 : provider.activateAsync)
                await provider.activateAsync("loading");
            this.onContentChanged(provider);
            this._isContentLoaded = true;
        }
        catch (e) {
            this.handleError(this, e);
        }
        finally {
            op.end();
        }
    }
    /****************************************/
    getAction(name) {
        return (0,Linq/* linq */.k)(this._floatingView.content).first(a => a instanceof ActionView_ActionView && a.name == name);
    }
    /****************************************/
    formatTitle(value) {
        return value;
    }
    /****************************************/
    createAsync() {
        if (this.menu) {
            this._actionBar = this.view.addView(new ActionBar_ActionBar({
                title: this.prop("title"),
                mainAction: "menu",
                navigationMenu: this.menu
            }));
        }
        else {
            this._actionBar = this.view.addView(new ActionBar_ActionBar({
                onBack: () => this.closeAsync(),
                title: this.prop("title"),
                mainAction: this.host.canGoBack ? "back" : "none"
            }));
        }
        if (this.providers.length > 1) {
            if (this._selector == ContentSelector.Manual) {
                this.prop("activeContent").subscribe(() => this.loadActiveContentAsync(false));
            }
            else {
                let navStyle;
                let itemTemplate;
                let itemBehavoirs;
                switch (this._selector) {
                    case ContentSelector.Tabs:
                        navStyle = "tab-view";
                        itemTemplate = "TextView";
                        itemBehavoirs = ["ripple"];
                        break;
                    case ContentSelector.BottomNav:
                        navStyle = "bottom-nav";
                        itemTemplate = "IconTextView";
                        itemBehavoirs = ["ripple"];
                        break;
                }
                this._navBar = new NavBar_NavBar({
                    styles: [navStyle],
                    itemTemplate: itemTemplate,
                    onItemSelected: a => this.loadContentAsync(a.content, false),
                    selectedItem: this.prop("activeContent"),
                    itemBehavoirs: itemBehavoirs,
                    items: (0,Linq/* linq */.k)(this.providers).select(a => ({
                        name: a.info.name,
                        icon: a.info.icon,
                        text: a.info.displayName,
                        content: a
                    })).toArray()
                });
            }
        }
        if (this._navBar && this._selector == ContentSelector.Tabs)
            this.view.addView(this._navBar);
        this._contentView = this.view.addView(new Panel_Panel({ styles: this.contentStyle }));
        if (this._navBar && this._selector == ContentSelector.BottomNav)
            this.view.addView(this._navBar);
        this._floatingView = this.view.addView(new Panel_Panel({ name: "floating-container", template: "ItemsViewWrapped", visible: false, styles: this.floatingStyle }));
        if (this.providers.length == 1)
            this.activeContentProvider = this.providers[0];
        this.status = "created";
        return Promise.resolve();
    }
    /****************************************/
    createActionView(action, config) {
        return ActionView_ActionView.fromAction(action, config);
    }
    /****************************************/
    onContentChanged(newContent) {
    }
    /****************************************/
    get actionBar() { return this._actionBar; }
}
registerType(ContentActivity_ContentActivity, "ContentActivity");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Items/FulltemsLoader.js



class FullItemsLoader {
    async loadItemsAsync(container, chunkSize) {
        container.status = "loading";
        const operation = Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading items", type: IOperation_OperationType.Local });
        try {
            const items = await container.itemsSource.getItemsAsync(container.filter);
            container.clear();
            if (items)
                await forEachAsync(items, chunkSize, a => container.addItem(a));
        }
        finally {
            operation.end();
            container.status = "loaded";
        }
    }
}
FullItemsLoader.instance = new FullItemsLoader();

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/TextView.js



/********************************************/
class TextView_TextView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "TextContent" }, config));
    }
}
registerType(TextView_TextView, "TextView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ListView.js









/****************************************/
class ListView_ListView extends ItemsView_ItemsView {
    constructor(config) {
        super(Object.assign({ template: "ListView", styles: ["default"] }, config));
        this._isLoaded = false;
        this._itemViewMap = new Map();
        this.header = ObservableList_observableListOf();
        this.footer = ObservableList_observableListOf();
        this.itemsSource = null;
        this.itemsLoader = null;
        this.items = null;
        this.selectedItem = null;
        this.status = "";
        this.selectionMode = "none";
        this.showSeparator = false;
        this.filter = null;
        this.bindConfig("itemsSource", config);
        this.bindConfig("items", config);
        this.bindConfig("filter", config);
        this.bindConfig("selectionMode", config);
        if (config) {
            if (config.itemsLoader)
                this.itemsLoader = config.itemsLoader;
            if (config.showSeparator !== undefined)
                this.showSeparator = config.showSeparator;
            if (config.createItemView)
                this.createItemViewWork = config.createItemView;
            if (config.header)
                this.header.addRange(config.header);
            if (config.footer)
                this.footer.addRange(config.footer);
        }
        if (!(config === null || config === void 0 ? void 0 : config.items))
            this.items = ObservableList_observableListOf();
        if (!this.itemsLoader && this.itemsSource)
            this.itemsLoader = FullItemsLoader.instance;
        if (config && config.isAutoLoad)
            this.loadAsync();
        const itemsHandler = {
            onClear: () => {
                this.selectedItem = null;
                this._itemViewMap.clear();
                this.content.clear();
            },
            onItemAdded: (item, index, reason) => {
                if (reason != "replace")
                    this.content.insert(index, this.createItemView(item));
            },
            onItemRemoved: (item, index, reason) => {
                if (reason == "remove")
                    this.content.removeAt(index);
            },
            onItemReplaced: (newItem, oldItem, index) => this.content.set(index, this.createItemView(newItem)),
            onItemSwap: (index, newIndex) => this.content.swap(index, newIndex),
        };
        this.prop("items").subscribe((value, oldValueX) => {
            if (oldValueX != null)
                oldValueX.unsubscribe(itemsHandler);
            this.content.clear();
            if (value) {
                value.subscribe(itemsHandler);
                for (const item of value)
                    this.content.add(this.createItemView(item));
                this.status = "loaded";
            }
        });
        this.prop("items").notifyChanged();
        this.prop("selectedItem").subscribe((value, oldValue) => {
            if (this.selectionMode == "single")
                this.updateItemSelection(oldValue, false);
            if (this.selectionMode != "none") {
                this.updateItemSelection(value, true);
                if (config === null || config === void 0 ? void 0 : config.onSelectdItemChanged)
                    config.onSelectdItemChanged(value);
            }
        });
        if (config === null || config === void 0 ? void 0 : config.isListenerActive)
            this.activateListener();
    }
    /****************************************/
    activateListener() {
        var _a;
        if (!((_a = this.itemsSource) === null || _a === void 0 ? void 0 : _a.typeName))
            return;
        if (!this._listener)
            this._listener = {
                onItemAdded: args => this.refreshAsync(),
                onItemRemoved: args => {
                    if (args.value)
                        this.items.removeWhen(a => this.itemsSource.equals(this.itemsSource.getItemValue(a), args.value));
                },
                onItemChanged: async (args) => {
                    const index = (0,Linq/* linq */.k)(this.items).indexOf(a => this.itemsSource.equals(this.itemsSource.getItemValue(a), args.value));
                    if (index != -1) {
                        const newItem = await this.itemsSource.getItemByValueAsync(args.value);
                        if (newItem)
                            this.items.set(index, newItem);
                    }
                }
            };
        Global/* Services.itemsObserver.register */.K9.itemsObserver.register(this.itemsSource.typeName, this._listener);
    }
    /****************************************/
    deactivateListener() {
        if (this._listener)
            Global/* Services.itemsObserver.unregister */.K9.itemsObserver.unregister(this.itemsSource.typeName, this._listener);
    }
    /****************************************/
    updateItemSelection(item, isSelected) {
        const view = this.findItemView(item);
        if (isSelectable(view))
            view.isSelected = isSelected;
    }
    /****************************************/
    findItemView(item) {
        if (!item)
            return null;
        return (0,Linq/* linq */.k)(this._itemViewMap.entries()).where(a => a[1] == item).select(a => a[0]).first();
    }
    /****************************************/
    removeItem(item) {
        this.items.remove(item);
    }
    /****************************************/
    addItem(item, index) {
        if (index !== undefined) {
            this.items.insert(index, item);
            return this.content.get(index);
        }
        else {
            this.items.add(item);
            return this.content.last;
        }
    }
    /****************************************/
    clear() {
        this.items.clear();
    }
    /****************************************/
    async loadAsync() {
        if (this._isLoaded)
            return;
        await this.refreshAsync(); //TODO await added on 28/09/2021
    }
    /****************************************/
    async refreshAsync() {
        let oldSelection = this.selectedItem;
        if (this.itemsLoader) {
            this.beginUpdate();
            await this.itemsLoader.loadItemsAsync(this, 25);
            if (!oldSelection && this.selectedItem)
                oldSelection = this.selectedItem;
            this.endUpdate();
        }
        this._isLoaded = true;
        if (oldSelection && this.itemsSource)
            this.selectedItem = (0,Linq/* linq */.k)(this.items).first(a => this.itemsSource.itemComparer(a, oldSelection));
        else
            this.selectedItem = null;
    }
    /********************************************/
    onItemRemoved(itemView) {
        if (itemView) {
            if (itemView.parentView == this)
                itemView.parentView = null;
            const item = this._itemViewMap.get(itemView);
            if (item == this.selectedItem)
                this.selectedItem = null;
            this._itemViewMap.delete(itemView);
            //TODO remove selection
            /*
            if (ViewUtils.isSelectable(itemView))
                itemView.prop("isSelected").unsubscribe(this.selectionHandler);*/
        }
    }
    /****************************************/
    createItemView(item) {
        const itemView = this.createItemViewWork(item);
        if ((this.status == "loading" || this.status == "loaded") && isAsyncLoad(itemView)) {
            itemView.loadAsync(); //Not awaited
        }
        if (itemView) {
            itemView.parentView = this;
            this._itemViewMap.set(itemView, item);
            if (isSelectable(itemView))
                itemView.prop("isSelected").subscribe(value => {
                    if (value)
                        this.selectedItem = item;
                });
        }
        return itemView;
    }
    /****************************************/
    createItemViewWork(item) {
        const factory = Global/* Services.views */.K9.views[getTypeName(item)];
        if (factory)
            return factory(item);
        return new TextView_TextView({ content: this.itemsSource ? this.itemsSource.getItemText(item) : item.toString() });
    }
    /****************************************/
    onScroll(data) {
        if (this.itemsLoader && "onScroll" in this.itemsLoader)
            this.itemsLoader.onScroll(data);
    }
    /****************************************/
    get itemsCount() { return this.content.count; }
    get isScrollCheckActive() { return this.itemsLoader && "onScroll" in this.itemsLoader; }
}
registerType(ListView_ListView, "ListView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Items/Item.js

/****************************************/
class Item {
    static create(options) {
        let newValue = options.value;
        if (typeof newValue == "string")
            newValue = new String(newValue);
        else if (typeof newValue == "number")
            newValue = new Number(newValue);
        else if (typeof newValue == "boolean")
            newValue = new Boolean(newValue);
        else if (newValue instanceof Date)
            newValue = new Date(newValue.getTime());
        if (options.item) {
            options.item.valueOf = () => options.value;
            if (options.value)
                options.item["toJSON"] = () => options.value;
            if (options.text)
                options.item.toString = () => options.text;
            if (options.type)
                options.item["$type"] = () => options.type;
        }
        if (newValue) {
            if (options.text)
                newValue.toString = () => options.text;
            if (options.type)
                setTypeName(newValue, options.type);
            if (options.item !== undefined)
                set(newValue, "@item", options.item);
            newValue["toJSON"] = () => {
                var _a;
                if ((_a = options.value) === null || _a === void 0 ? void 0 : _a.toJSON)
                    return options.value.toJSON();
                return options.value;
            };
        }
        if (newValue)
            return newValue;
        return options.item;
    }
    /****************************************/
    static getText(value) {
        if (value == null || value == undefined)
            return "";
        const item = this.getItem(value);
        if (item !== value)
            return item.toString();
        return value.toString();
    }
    /****************************************/
    static getType(value) {
        return getTypeName(value);
    }
    /****************************************/
    static getValue(value) {
        if (!value)
            return;
        if (value.valueOf)
            return value.valueOf();
        return value;
    }
    /****************************************/
    static getItem(value) {
        if (!value)
            return;
        const item = get(value, "@item");
        if (item)
            return item;
        return undefined;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Items/ItemsSource.js

/****************************************/
class ItemsSource_ItemsSource {
    constructor(config) {
        if (config) {
            if (config.getItemsAsync)
                this.getItemsAsync = config.getItemsAsync;
            if (config.allowZero !== undefined)
                this._allowZero = config.allowZero;
            if (config.getItemValue)
                this.getItemValue = (a, bindItem) => {
                    if (bindItem === false)
                        return config.getItemValue(a);
                    if (!a && (a !== 0 || !config.allowZero))
                        return undefined;
                    const value = config.getItemValue(a);
                    if (value === null)
                        return null;
                    return Item.create({ type: this.typeName, value: value, text: this.getItemText(a), item: a });
                };
            if (config.getItemText)
                this.getItemText = config.getItemText;
            if (config.getFilter)
                this.getFilter = config.getFilter;
            if (config.getItemByValueAsync) {
                this.getItemByValueAsync = value => {
                    const item = Item.getItem(value);
                    if (item)
                        return Promise.resolve(item);
                    return config.getItemByValueAsync(value);
                };
            }
            if (config.equals)
                this.equals = config.equals;
            this._typeName = config.typeName;
            this.displayName = config.displayName;
        }
    }
    /****************************************/
    getItemsAsync(filter) {
        return Promise.resolve([]);
    }
    /****************************************/
    getItemText(item) {
        if (item)
            return item.toString();
    }
    /****************************************/
    getItemValue(item, bindItem) {
        return item;
    }
    /****************************************/
    getFilter(text, offset, pageSize) {
        return {};
    }
    /****************************************/
    async countAsync(filter) {
        return (await this.getItemsAsync(filter)).length;
    }
    /****************************************/
    getItemByValueAsync(value) {
        const item = Item.getItem(value);
        if (item)
            return Promise.resolve(item);
        return Promise.resolve(value);
    }
    /****************************************/
    equals(a, b) {
        if (a == b)
            return true;
        if (a != undefined && a.valueOf && b != undefined && b.valueOf)
            return a.valueOf() == b.valueOf();
        return false;
    }
    /****************************************/
    get itemComparer() {
        return (a, b) => this.equals(this.getItemValue(a), this.getItemValue(b));
    }
    /****************************************/
    get typeName() {
        return this._typeName;
    }
    /****************************************/
    get allowZero() {
        return this._allowZero;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Items/PagedItemsLoader.js



/****************************************/
class PagedItemsLoader_PagedItemsLoader extends BindableObject_BindableObject {
    constructor(config) {
        super();
        this._hasMoreItems = true;
        /****************************************/
        this.pageSize = 20;
        this.isScrollCheckActive = true;
        this.bindConfig("pageSize", config);
        if (config) {
            if (config.getFilter)
                this.getFilter = config.getFilter;
        }
    }
    /****************************************/
    loadItemsAsync(container, chunkSize) {
        this._container = container;
        this._hasMoreItems = true;
        this._container.clear();
        return this.loadNextPageAsync();
    }
    /****************************************/
    async loadNextPageAsync() {
        if (!this.canLoadNextPage)
            return;
        if (this._container.itemsSource) {
            const filter = this.getFilter(this._container.itemsCount, this.pageSize);
            const operation = Global/* Services.operation.begin */.K9.operation.begin({ message: "Laoding items from " + this._container.itemsCount, type: IOperation_OperationType.Local });
            try {
                this._container.status = "loading";
                const newItems = await this._container.itemsSource.getItemsAsync(Object.assign(Object.assign({}, filter), this._container.filter));
                if (!newItems || newItems.length == 0)
                    this._hasMoreItems = false;
                else {
                    newItems.forEach(item => this._container.addItem(item));
                    this._hasMoreItems = newItems.length == this.pageSize;
                }
            }
            finally {
                operation.end();
                this._container.status = "loaded";
            }
        }
    }
    /****************************************/
    onScroll(data) {
        if (data.pageBottom < 1 && this.canLoadNextPage)
            this.loadNextPageAsync();
    }
    /****************************************/
    getFilter(offset, pageSize) {
        return Object.assign(Object.assign({}, this._container.filter), this._container.itemsSource.getFilter(undefined, offset, pageSize));
    }
    /****************************************/
    get canLoadNextPage() {
        return this._hasMoreItems && this._container.status != "loading";
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Activities/SearchActivity.js









/****************************************/
class SearchActivity extends Activity {
    constructor(config) {
        super(config);
        /****************************************/
        this.searchText = null;
        this.tooltip = null;
        this.pageSize = 0;
        this.listStyles = ["vertical", "scroll", "compact"];
        this.noMatchingText = null;
        this.bindConfigString("tooltip", config);
        this.bindConfig("pageSize", config);
        this.bindConfig("noMatchingText", config);
        if (config) {
            if (config.createItemView)
                this.createItemView = config.createItemView;
            if (config.searchAsync)
                this.searchWorkAsync = config.searchAsync;
            if (config.query)
                this.searchText = config.query;
            if (config.listStyles)
                config.listStyles.forEach(a => this.listStyles.push(a));
        }
    }
    /****************************************/
    refreshAsync() {
        return this._listView.refreshAsync();
    }
    /****************************************/
    async createAsync() {
        this._actionBar = this.view.addView(new ActionBar_ActionBar({
            onBack: () => this.closeAsync(),
            title: this.prop("title"),
            mainAction: "back"
        }));
        this._searchView = new SearchView_SearchView({
            name: "search-expanded",
            tooltip: this.prop("tooltip"),
            isExpanded: true,
            searchText: this.prop("searchText"),
            searchAsync: text => this._listView.refreshAsync()
        });
        this._actionBar.actions.add(this._searchView);
        this._emptyView = new IconTextView_IconTextView({
            styles: ["empty-view"],
            visible: false
        });
        this._listView = this.view.addView(new ListView_ListView(Object.assign({ name: "content", styles: this.listStyles, template: "ListViewInline", header: [this._emptyView], itemsSource: new ItemsSource_ItemsSource({
                getItemsAsync: async () => {
                    const searchText = this.searchText;
                    const items = await this.searchWorkAsync(searchText);
                    if (!searchText)
                        this._lastItems = items;
                    this.updateView((items === null || items === void 0 ? void 0 : items.length) > 0, searchText);
                    return items;
                }
            }), itemsLoader: this.pageSize ? new PagedItemsLoader_PagedItemsLoader({
                getFilter: (offset, pageSize) => this.getFilter(this.searchText, offset, pageSize),
                pageSize: this.pageSize
            }) : undefined, createItemView: item => this.createItemView(item) }, this.configureListView())));
        setTimeout(() => this._searchView.hasFocus = true, 500);
        await this.refreshAsync();
    }
    /****************************************/
    updateView(hasItems, searchText) {
        if (!hasItems) {
            this._emptyView.visible = true;
            if (!this.searchText) {
                this._emptyView.icon = "fas fa-microscope";
                this._emptyView.text = "";
            }
            else {
                this._emptyView.icon = "far fa-sad-cry";
                if (this.noMatchingText)
                    this._emptyView.text = Helpers_Format/* Format.text */.E.text(this.noMatchingText, searchText);
            }
        }
        else
            this._emptyView.visible = false;
    }
    /****************************************/
    configureListView() {
        return {};
    }
    /****************************************/
    createItemView(item) {
        throw "Not Implemented";
    }
    /****************************************/
    searchWorkAsync(query, offset, pageSize) {
        throw "Not Implemented";
    }
    /****************************************/
    getFilter(query, offset, pageSize) {
        return {};
    }
}
registerType(SearchActivity, "SearchActivity");

// EXTERNAL MODULE: external "Hammer"
var external_Hammer_ = __webpack_require__(4396);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/BottomSheet.js




/********************************************/
class BottomSheet_BottomSheet extends ContentView {
    /********************************************/
    constructor(config) {
        super(Object.assign({ template: "BottomSheet" }, config));
        this._margin = 20;
        this._isAnimating = 0;
        /********************************************/
        this.isShowOpener = false;
        this.headHeight = 100;
        this.headSelector = null;
        this.status = "close";
        this.bindConfig("headHeight", config);
        this.bindConfig("headSelector", config);
        this.bindConfig("isShowOpener", config);
    }
    /********************************************/
    attach(element) {
        this._element = element;
        const hammer = new external_Hammer_(element, {
            recognizers: [[external_Hammer_.Pan, { direction: external_Hammer_.DIRECTION_VERTICAL }]]
        });
        let startHeight = 0;
        let oldStatus = this.status;
        let startScrollTop = 0;
        hammer.on("panstart", ev => {
            oldStatus = this.status;
            this.status = "moving";
            startScrollTop = element.scrollTop;
            startHeight = element.clientHeight;
        });
        hammer.on("panend", ev => {
            if (element.clientHeight < this.headHeight - this._margin)
                this.close();
            else {
                if (oldStatus == "open") {
                    if (ev.deltaY > this._margin && this._element.scrollTop <= 0)
                        this.head();
                    else
                        this.open();
                }
                else {
                    if (element.clientHeight > this.headHeight + this._margin)
                        this.open();
                    else
                        this.head();
                }
            }
        });
        hammer.on("panmove", ev => {
            let deltaY = ev.deltaY;
            //Scroll when is opened
            if (oldStatus == "open") {
                const newScrollTop = startScrollTop - deltaY;
                if (deltaY < 0) {
                    this._element.scrollTop = newScrollTop;
                    return;
                }
                else {
                    if (newScrollTop >= 0) {
                        this._element.scrollTop = newScrollTop;
                        return;
                    }
                    this._element.scrollTop = 0;
                    deltaY = -newScrollTop;
                }
            }
            //Oopen, close, head
            let newHeight = startHeight - deltaY;
            const panHeight = newHeight;
            let enableScrolling = false;
            if (newHeight < this._margin)
                newHeight = 0;
            else if (newHeight > element.parentNode.clientHeight - this._margin && newHeight < this._element.scrollHeight) {
                newHeight = element.parentNode.clientHeight;
                enableScrolling = true;
            }
            else if (newHeight > this._element.scrollHeight)
                newHeight = this._element.scrollHeight;
            else if (newHeight > this.headHeight - this._margin && newHeight < this.headHeight + this._margin)
                newHeight = this.headHeight;
            element.style.height = newHeight + "px";
            //Scroll while opening
            if (panHeight - newHeight > 0 && enableScrolling)
                this._element.scrollTop = panHeight - newHeight;
            else
                this._element.scrollTop = 0;
        });
        switch (this.status) {
            case "head":
                this.head();
                break;
            case "open":
                this.open();
                break;
            case "close":
                this.close();
                break;
        }
    }
    /********************************************/
    async setHeightAsync(value) {
        this._isAnimating++;
        if (this._isAnimating == 1)
            this._element.classList.add("animate");
        await (0,PromiseUtils/* delayAsync */.$)(0);
        this._element.style.height = value.toString() + "px";
        await (0,PromiseUtils/* delayAsync */.$)(500);
        this._isAnimating--;
        if (this._isAnimating == 0)
            this._element.classList.remove("animate");
    }
    /********************************************/
    toggle() {
        if (this.status == "open" || this.status == "close")
            this.head();
        else
            this.open();
    }
    /********************************************/
    open() {
        this.status = "open";
        if (this._element)
            this.setHeightAsync(this._element.scrollHeight);
    }
    /********************************************/
    head() {
        this.status = "head";
        if (this._element) {
            if (this.headSelector) {
                const headEl = this._element.querySelector(this.headSelector);
                if (headEl) {
                    this.headHeight = headEl.clientHeight;
                    if (this.isShowOpener)
                        this.headHeight += this._element.querySelector(".opener").clientHeight;
                }
            }
            this.setHeightAsync(this.headHeight);
        }
    }
    /********************************************/
    close() {
        this.status = "close";
        if (this._element)
            this.setHeightAsync(0);
    }
}
registerType(BottomSheet_BottomSheet, "BottomSheet");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/RemovableItemView.js




/****************************************/
class RemovableItemView_RemovableItemView extends ContentView {
    constructor(config) {
        super(config);
        /****************************************/
        this.item = null;
        this.bindConfig("item", config);
        if (config) {
            if (config.removeAsync)
                this.removeWorkAsync = config.removeAsync;
        }
    }
    /****************************************/
    async removeAsync() {
        this.status = "removed";
        await (0,PromiseUtils/* delayAsync */.$)(150);
        await this.removeWorkAsync();
    }
    /****************************************/
    removeWorkAsync() {
        throw "Not supported";
    }
}
registerType(RemovableItemView_RemovableItemView, "RemovableItemView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/SelectableItemView.js



/****************************************/
class SelectableItemView_SelectableItemView extends ContentView {
    constructor(config) {
        super(config);
        /****************************************/
        this.isSelected = false;
        this.item = null;
        this.bindConfig("isSelected", config);
        this.bindConfig("item", config);
    }
    /****************************************/
    select() {
        this.isSelected = true;
    }
    /****************************************/
    toggle() {
        this.isSelected = !this.isSelected;
    }
}
registerType(SelectableItemView_SelectableItemView, "SelectableItemView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/Container.js




/********************************************/
class Container_Container extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "Container" }, config));
        /********************************************/
        this.title = "";
        this.isOverflow = true;
        this.canExpand = false;
        this.isExpanded = true;
        this.bindConfigString("title", config, DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfig("isExpanded", config);
        this.bindConfig("canExpand", config);
        this.prop("content").subscribe(() => this.checkOverflow());
    }
    /********************************************/
    attach(element) {
        this._element = element;
        if (this.canExpand) {
            this._element.addEventListener("resize", () => this.checkOverflow());
            this.checkOverflow();
        }
    }
    /********************************************/
    checkOverflow() {
        if (this._element != null) {
            const wrapper = this._element.querySelector(".content-wrapper");
            if (wrapper != null) {
                this.isOverflow = wrapper.scrollHeight > wrapper.clientHeight;
                if (!this.isOverflow)
                    this.isExpanded = true;
            }
        }
    }
    /********************************************/
    onContentChanged() {
    }
    /********************************************/
    toggleExpand() {
        this.isExpanded = !this.isExpanded;
    }
}
registerType(Container_Container, "Container");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Content/ItemEditContent.js





/****************************************/
class ItemEditContent extends BindableObject_BindableObject {
    constructor(config) {
        super();
        /****************************************/
        this.editor = null;
        this.title = null;
        this.url = null;
        this.value = null;
        this.saveLabel = "Save";
        this.saveOnCommit = false;
        this.savePriority = null;
        this.actions = [];
        this.styles = ["vertical", "scroll", "fill-h", "fit-items-h"];
        this.info = {
            name: "item-edit",
            icon: "fas fa-edit",
            displayName: "Edit",
        };
        this.bindConfig("editor", config);
        this.bindConfig("value", config);
        this.bindConfig("styles", config);
        this.bindConfig("url", config);
        this.bindConfig("actions", config);
        this.bindConfig("savePriority", config);
        this.bindConfig("saveOnCommit", config);
        this.bindConfigString("title", config, DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfigString("saveLabel", config, DynamicString/* StringUsage.Action */.Fq.Action);
        if (config) {
            if (config.saveItemAsync)
                this.saveItemAsync = config.saveItemAsync;
        }
    }
    /****************************************/
    async getContentAsync(host) {
        this._host = host;
        await this.editor.beginEditAsync(this.value);
        const container = new Container_Container({
            name: "editor-container",
            title: this.title,
            content: this.editor.view
        });
        if (isActivable(this.editor))
            setTimeout(() => this.editor.activateAsync(), 200);
        const actions = [];
        if (this.saveOnCommit) {
            this.editor.prop("value").subscribe(value => this.saveAsync());
        }
        else {
            actions.push({
                name: "save",
                icon: "fas fa-save",
                displayName: this.saveLabel,
                operation: IOperation_OperationType.Global,
                priority: this.savePriority,
                executeAsync: () => this.saveAsync()
            });
        }
        return {
            views: [container],
            actions: [...this.actions, ...actions],
            styles: this.styles,
            title: this.title,
            url: this.url
        };
    }
    /****************************************/
    async saveItemAsync(item) {
        return item;
    }
    /****************************************/
    async saveAsync() {
        //TODO check why it was needed before
        //(App as IViewApplication).unblock(true);
        if (this.saveOnCommit) {
            if (!this.editor.isValid)
                return;
        }
        else {
            if (!await this.editor.commitAsync(true))
                return;
        }
        const result = await this.saveItemAsync(this.editor.value);
        if (result == null)
            return;
        await this._host.closeAsync(result);
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/WebView.js


/********************************************/
class WebView_WebView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "WebView" }, config));
    }
    /********************************************/
    attach(element) {
        this.window = element.contentWindow;
    }
}
registerType(WebView_WebView, "WebView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/WebPage.js






/****************************************/
class WebPage extends Page {
    constructor(config) {
        super(config);
        this.view = new WebView_WebView();
        this.updateUrl();
        this.prop("url").subscribe(() => this.updateUrl());
    }
    /****************************************/
    updateUrl() {
        this.view.content = Helpers_Uri/* Uri.absolute */.S.absolute(Helpers_Format/* Format.replaceArgs */.E.replaceArgs(this.url, Global/* App.startupArgs */.gV.startupArgs));
    }
    /****************************************/
    loadWorkAsync() {
        if (!this.view.window || this.view.window.document.readyState == "complete")
            return Promise.resolve();
        return new Promise((res, rej) => {
            function onLoad(ev) {
                this.view.window.removeEventListener("load", onLoad);
                res();
            }
            function onError(ev) {
                this.view.window.removeEventListener("error", onError);
                rej();
            }
            this.view.window.addEventListener("load", onLoad);
            this.view.window.addEventListener("error", onError);
        });
    }
    /****************************************/
    refreshAsync() {
        if (!this.view.window)
            return Promise.resolve();
        return new Promise((res, rej) => {
            function onLoad(ev) {
                this.view.window.removeEventListener("load", onLoad);
                res();
            }
            function onError(ev) {
                this.view.window.removeEventListener("error", onError);
                rej();
            }
            this.view.window.addEventListener("load", onLoad);
            this.view.window.addEventListener("error", onError);
            this.view.window.document.location.reload();
        });
    }
    /****************************************/
    async closeAsync() {
        this.view.window.close();
        if ("goBackAsync" in this.host)
            await this.host.goBackAsync();
        return true;
    }
}
registerType(WebPage, "WebPage");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/BasePopUpMessage.js





/****************************************/
class BasePopUpMessage extends View_View {
    /****************************************/
    constructor(config) {
        super(config);
        this._isVisible = false;
        /****************************************/
        this.className = null;
        this.bindConfig("className", config);
        this._container = document.createElement("DIV");
        this._container.className = this.className + "-container";
    }
    /****************************************/
    async showAsync() {
        if (this._isVisible)
            return;
        this._isVisible = true;
        Global/* App.unblock */.gV.unblock(true);
        const builder = new TemplateBuilder_TemplateBuilder(this, this._container);
        builder.template(this.template, a => a);
        document.body.appendChild(this._container);
        await (0,PromiseUtils/* delayAsync */.$)(0);
        this._container.classList.add("visible");
        return new Promise(res => this._showResolve = res);
    }
    /****************************************/
    hide(actionName) {
        if (!this._isVisible)
            return;
        this._isVisible = false;
        Global/* App.restoreBlock */.gV.restoreBlock();
        this._container.classList.remove("visible");
        if (this._showResolve) {
            this._showResolve(actionName);
            this._showResolve = null;
        }
        setTimeout(() => {
            if (!this._isVisible)
                document.body.removeChild(this._container);
        }, 500);
    }
}
registerType(BasePopUpMessage, "BasePopUpMessage");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/PopUpContent.js








/****************************************/
class PopUpContent_PopUpContent extends BasePopUpMessage {
    constructor(config) {
        super(Object.assign({ template: "PopUpContent", className: "pop-up-content" }, config));
        /****************************************/
        this.contentProvider = null;
        this.actions = ObservableList_observableListOf();
        this.contentView = new Panel_Panel();
        this.title = null;
        this.contentStyle = ["vertical", "fill-h", "fit-items-h"];
        this.closeLabel = "Cancel";
        this.bindConfig("contentProvider", config);
        this.bindConfig("contentStyle", config);
        this.bindConfigString("title", config);
        this.bindConfigString("closeLabel", config);
    }
    /****************************************/
    async createAsync() {
        const viewContent = await this.contentProvider.getContentAsync(this);
        if (this.closeLabel) {
            this.addAction({
                name: "close",
                icon: "fas fa-close",
                displayName: this.closeLabel,
                executeAsync: () => this.closeAsync()
            });
        }
        if (viewContent.actions)
            viewContent.actions.forEach(a => this.addAction(a));
        if (!this.title && viewContent.title)
            this.title = Helpers_Format/* Format.title */.E.title(viewContent.title);
        this.contentView.content.clear();
        if (viewContent.views)
            viewContent.views.forEach(a => this.contentView.addView(a));
        this.contentView.styles = [...this.contentStyle, ...viewContent.styles];
    }
    /****************************************/
    get result() {
        return new Promise(res => this._resultResolve = res);
    }
    /****************************************/
    async openAsync() {
        await this.createAsync();
        await this.contentView.loadAsync();
        this.showAsync(); //Not awaited
        return this;
    }
    /****************************************/
    notifyContentChanged(provider) {
        this.createAsync();
    }
    /****************************************/
    closeAsync(result) {
        if (this._resultResolve)
            this._resultResolve(result);
        this.hide("");
        return Promise.resolve(true);
    }
    /****************************************/
    addAction(action) {
        const actionView = ActionView_ActionView.fromAction(action);
        if (action.priority == IAction_ActionPriority.Evidence) {
            actionView.styles.push("primary");
            actionView.buildStyles();
        }
        this.actions.add(actionView);
        return actionView;
    }
}
registerType(PopUpContent_PopUpContent, "PopUpContent");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/PopupEditor.js






/********************************************/
class PopupEditor_PopUpEditor extends BindableObject_BindableObject {
    constructor(config) {
        super();
        /********************************************/
        this.editor = null;
        this.title = "Edit";
        this.saveLabel = null;
        this.actions = [];
        this.savePriority = null;
        this.closeLabel = null;
        this.saveOnCommit = false;
        this.styles = [];
        this.name = null;
        this.bindConfig("name", config);
        this.bindConfig("editor", config);
        this.bindConfig("actions", config);
        this.bindConfig("styles", config);
        this.bindConfig("saveOnCommit", config);
        this.bindConfig("savePriority", config);
        this.bindConfigString("title", config, DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfigString("closeLabel", config, DynamicString/* StringUsage.Action */.Fq.Action);
        this.bindConfigString("saveLabel", config, DynamicString/* StringUsage.Action */.Fq.Action);
        if (config) {
            if (config.editToItemAsync)
                this.editToItemAsync = config.editToItemAsync;
        }
        if (!this.closeLabel)
            this.closeLabel = Helpers_Format/* Format.action */.E.action("cancel");
        if (!this.saveLabel)
            this.saveLabel = Helpers_Format/* Format.action */.E.action("ok");
    }
    /********************************************/
    async editAsync(value, validate) {
        const popUp = new PopUpContent_PopUpContent({
            title: this.title,
            contentProvider: new ItemEditContent({
                editor: this.editor,
                value: value,
                actions: this.actions,
                styles: this.styles,
                savePriority: this.savePriority,
                saveOnCommit: this.saveOnCommit,
                saveLabel: this.saveLabel,
                saveItemAsync: async (edit) => {
                    if (validate) {
                        const valResult = await validate(edit);
                        if (valResult == null)
                            return null;
                    }
                    return await this.editToItemAsync(edit);
                }
            }),
            closeLabel: this.closeLabel
        });
        const result = await (await popUp.openAsync()).result;
        if (!result)
            return null;
        return this.editor.value;
    }
    /********************************************/
    editToItemAsync(edit) {
        return Promise.resolve(edit);
    }
}
registerType(PopupEditor_PopUpEditor, "PopUpEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/BaseEditor.js





/********************************************/
class BaseEditor extends ViewComponent {
    /********************************************/
    constructor(config) {
        super(Object.assign({}, config));
        this._needValidation = false;
        this._isEditing = 0;
        this._editValue = null;
        /********************************************/
        this.isValid = true;
        this.status = "none";
        this.commitMode = "onchange";
        this.validationMode = "onchanged";
        this.allowNull = true;
        this.displayValue = null;
        this.value = null;
        this.hasFocus = false;
        this.isDirty = false;
        this.uid = null;
        this.error = null;
        //TODO: hack, props are not enumerable in ts 3.9
        setEnumerable(this, "editValue");
        this._onCommit = config === null || config === void 0 ? void 0 : config.onCommit;
        this.bindConfig("allowNull", config);
        this.bindConfig("hasFocus", config);
        this.bindConfig("value", config);
        this.bindConfig("commitMode", config);
        this.bindConfig("validationMode", config);
        this.prop("displayValue");
        this.prop("value").subscribe((value, old) => this.onValueChanged(value, old));
        this.prop("name").subscribe(() => this.updateUid());
        if (config.converter) {
            this.editToValue = config.converter.convertFrom;
            this.valueToEdit = config.converter.convertTo;
        }
        this.updateUid();
    }
    /********************************************/
    updateUid() {
        var _a;
        this.uid = generateId(ViewUtils_formatForCss((_a = this.name) !== null && _a !== void 0 ? _a : getTypeName(this)));
    }
    /********************************************/
    createEditValueProp() {
        this.prop("editValue").subscribe(() => this.notifyEditValueChangedAsync());
    }
    /********************************************/
    async notifyEditValueChangedAsync() {
        console.debug("value changed: ", this.debugName);
        this._needValidation = true;
        this.isDirty = true;
        if (!this._isEditing) {
            if (this.commitMode == "onchange")
                await this.commitAsync();
            else
                await this.validateAsync();
        }
    }
    /********************************************/
    onValueChanged(value, oldValue) {
        if (this.status == "commiting")
            return;
        this.beginEditAsync(value);
    }
    /********************************************/
    clear() {
        this.value = null;
    }
    /********************************************/
    async loadAsync() {
        console.group("begin load: ", this.debugName, " - status: ", this.status);
        try {
            if (this.status != "none")
                return;
            this.status = "loading";
            try {
                await this.loadAsyncWork();
            }
            finally {
                this.status = "loaded";
            }
        }
        finally {
            console.groupEnd();
        }
    }
    /********************************************/
    clearError() {
        this.error = null;
    }
    /********************************************/
    loadAsyncWork() {
        return Promise.resolve();
    }
    /********************************************/
    async beginEditAsync(value) {
        if (this._isEditing)
            return;
        console.group("begin edit: ", this.debugName);
        this._isEditing++;
        try {
            if (this.status == "none")
                await this.loadAsync();
            this.value = value;
            this.editValue = this.valueToEdit(value);
            await this.beginEditWorkAsync(value);
            this._needValidation = true;
        }
        finally {
            this._isEditing--;
            console.groupEnd();
        }
    }
    /********************************************/
    valueToEdit(value) {
        return value;
    }
    /********************************************/
    editToValue(value) {
        return value;
    }
    /********************************************/
    beginEditWorkAsync(value) {
        return Promise.resolve();
    }
    /********************************************/
    async validateAsync(force) {
        console.group("begin validation: " + this.debugName, " - needValidation: ", this._needValidation);
        try {
            if (this._isEditing)
                return undefined;
            if (!this._needValidation && this.validationMode == "onchanged" && !force)
                return this.isValid;
            this.clearError();
            const validationResult = await this.validateAsyncWork(force);
            if (validationResult !== undefined) {
                this.isValid = validationResult;
                this._needValidation = false;
            }
            console.debug("validation: ", this.debugName, " = ", this.isValid);
            return this.isValid;
        }
        finally {
            console.groupEnd();
        }
    }
    /********************************************/
    validateAsyncWork(force) {
        return Promise.resolve(true);
    }
    /********************************************/
    async commitAsync(force) {
        console.group("begin commit: ", this.debugName, " isDirty: ", this.isDirty, " - status: ", this.status);
        try {
            if (this._isEditing)
                return false;
            if (!force && this.commitMode != "manual" && !this.isDirty)
                return true;
            if (this.status != "loaded")
                return this.status == "commiting";
            this.status = "commiting";
            try {
                if (!await this.validateAsync(force))
                    return false;
                if (!await this.commitAsyncWork(force))
                    return false;
                const newValue = this.editToValue(this.editValue);
                if (newValue !== undefined)
                    this.value = newValue;
                if (this._onCommit)
                    this._onCommit(this);
                this.isDirty = false;
                return true;
            }
            finally {
                this.status = "loaded";
            }
        }
        finally {
            console.groupEnd();
        }
    }
    /********************************************/
    activateAsync() {
        return Promise.resolve();
    }
    /********************************************/
    commitAsyncWork(force) {
        return Promise.resolve(true);
    }
    /********************************************/
    rollback() {
        this.editValue = this.valueToEdit(this.value);
    }
    /********************************************/
    get view() {
        return this;
    }
    /********************************************/
    get editValue() {
        return this._editValue;
    }
    set editValue(value) {
        this._editValue = value;
    }
}
registerType(BaseEditor, "BaseEditor");

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/ItemSelector.html
var ItemSelector = __webpack_require__(3999);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/SingleItemSelector.js









/****************************************/
class SingleItemSelector_SingleItemSelector extends BaseEditor {
    constructor(config) {
        super(Object.assign({ template: "SelectEditor" }, config));
        /****************************************/
        this.itemTemplate = "SelectableItemView";
        this.placeholder = null;
        this.emptyText = null;
        this.selectedItemText = null;
        this.selectedItem = null;
        this.selectedIndex = -1;
        this.itemsSource = null;
        this.items = ObservableList_observableListOf();
        this.bindConfig("itemsSource", config);
        this.bindConfig("itemTemplate", config);
        this.bindConfigString("placeholder", config);
        this.bindConfigString("emptyText", config, DynamicString/* StringUsage.Title */.Fq.Title);
        if (config === null || config === void 0 ? void 0 : config.createItemView)
            this.createItemViewWork = config === null || config === void 0 ? void 0 : config.createItemView;
        if (config === null || config === void 0 ? void 0 : config.items) {
            if (this.allowNull)
                this.items.add(this.createEmptyItem());
            config.items.forEach(a => this.items.add(this.createItemView(a)));
            this.status = "loaded";
        }
        this.prop("selectedItem").subscribe(async (value, oldValue) => {
            var _a;
            if (this._isSelecting)
                return;
            if (!value && this.emptyText) {
                this.selectedItemText = this.emptyText;
                this.selectedItem = this.items.get(0);
                return;
            }
            this._isSelecting = true;
            try {
                if (oldValue)
                    oldValue.isSelected = false;
                if (value)
                    value.isSelected = true;
                this.selectedIndex = this.items.indexOf(value);
                if (this.itemsSource)
                    this.selectedItemText = (_a = value === null || value === void 0 ? void 0 : value.content) !== null && _a !== void 0 ? _a : "";
                if (this.status != "loading")
                    await this.notifyEditValueChangedAsync();
            }
            finally {
                this._isSelecting = false;
            }
        });
        this.prop("selectedIndex").subscribe(value => {
            var _a;
            if (value == -1 && this.emptyText) {
                this.selectedIndex = 0;
                return;
            }
            this.selectedItem = value == -1 ? null : this.items.get(value);
            if (((_a = this.element) === null || _a === void 0 ? void 0 : _a.tagName) == "SELECT")
                this.element.selectedIndex = value;
        });
    }
    /********************************************/
    attach(element) {
        this.element = element;
        if (element.tagName == "SELECT") {
            this.element.selectedIndex = this.selectedIndex;
            this.element.addEventListener("change", () => this.selectedIndex = element.selectedIndex);
        }
    }
    /********************************************/
    async selectAsync() {
        const editor = new PopupEditor_PopUpEditor({
            editor: new SingleItemSelector_SingleItemSelector({
                template: "ItemSelectorList",
                itemsSource: this.itemsSource,
                allowNull: false,
                styles: ["no-padding-items-h"]
            }),
            saveOnCommit: true,
            saveLabel: "select",
            closeLabel: "cancel",
            title: "select-an-item",
            styles: [""]
        });
        const result = await editor.editAsync(this.value);
        if (result !== null)
            this.editValue = result;
    }
    /********************************************/
    findItemByValue(value) {
        if (this.itemsSource)
            return (0,Linq/* linq */.k)(this.items).first(a => this.itemsSource.equals(a.item, value));
        return (0,Linq/* linq */.k)(this.items).first(a => a.item == value);
    }
    /********************************************/
    set editValue(value) {
        if (this.editValue == value)
            return;
        if (value == null && this.emptyText)
            this.selectedItem = this.items[0];
        else
            this.selectedItem = this.findItemByValue(value);
    }
    get editValue() {
        var _a;
        return (_a = this.selectedItem) === null || _a === void 0 ? void 0 : _a.item;
    }
    /****************************************/
    async loadAsyncWork() {
        if (this.itemsSource) {
            this.items.clear();
            if (this.allowNull)
                this.items.add(this.createEmptyItem());
            const items = await this.itemsSource.getItemsAsync(this.itemsSource.getFilter());
            if (items)
                items.forEach(a => this.items.add(this.createItemView(a)));
        }
        this.selectedIndex = 0;
        this.isDirty = true;
    }
    /****************************************/
    createEmptyItem() {
        var _a;
        const result = new SelectableItemView_SelectableItemView({
            item: null,
            content: (_a = this.emptyText) !== null && _a !== void 0 ? _a : "",
            template: this.itemTemplate,
            styles: ["single", "checkbox"]
        });
        result.prop("isSelected").subscribe(value => {
            if (value)
                this.selectedItem = null;
        });
        return result;
    }
    /****************************************/
    createItemViewWork(item) {
        if (this.itemsSource)
            return new SelectableItemView_SelectableItemView({
                item: this.itemsSource.getItemValue(item),
                content: this.itemsSource.getItemText(item),
                template: this.itemTemplate,
                styles: ["single", "checkbox"]
            });
    }
    /****************************************/
    createItemView(item) {
        const itemView = this.createItemViewWork(item);
        itemView.prop("isSelected").subscribe(value => {
            if (value)
                this.selectedItem = itemView;
        });
        return itemView;
    }
}
registerType(SingleItemSelector_SingleItemSelector, "SingleItemSelector");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/Actions.js






const Actions_Actions = {};
/****************************************/
Actions_Actions.selectFileAsync = options => {
    return new Promise((res, rej) => {
        const input = document.createElement("input");
        input.type = "file";
        let isSelected = false;
        input.onchange = () => {
            isSelected = true;
            res(input.files[0]);
        };
        input.click();
        const handler = async () => {
            window.removeEventListener("focus", handler);
            await (0,PromiseUtils/* delayAsync */.$)(500);
            if (!isSelected || input.files.length == 0)
                res(undefined);
        };
        window.addEventListener("focus", handler);
    });
};
/****************************************/
Actions_Actions.selectOptionAsync = async (options) => {
    const editor = new PopupEditor_PopUpEditor({
        editor: new SingleItemSelector_SingleItemSelector({
            template: "ItemSelectorList",
            itemsSource: options.itemsSource,
            styles: ["no-padding-items-h"]
        }),
        saveOnCommit: options.saveOnCommit == undefined ? true : options.saveOnCommit,
        saveLabel: options.saveLabel,
        closeLabel: options.closeLabel,
        title: options.title,
        styles: options.styles
    });
    return await editor.editAsync(options.value);
};
/****************************************/
Actions_Actions.loadPageAsync = async (page, options) => {
    return await Global/* App.pageHost.loadAsync */.gV.pageHost.loadAsync(page, options);
};
/****************************************/
Actions_Actions.content = (content, contentOptions, pageOptions) => {
    const value = typeof content == "function" ? new content() : content;
    const activity = new ContentActivity_ContentActivity(Object.assign({ providers: [
            value
        ] }, contentOptions));
    return Actions_Actions.loadPageAsync(activity, pageOptions);
};
/****************************************/
Actions_Actions.go = url => {
    window.location.href = url;
    return Promise.resolve();
};
/****************************************/
Actions_Actions.call = phoneNumber => {
    window.location.href = "tel:" + phoneNumber;
    return Promise.resolve();
};
/****************************************/
Actions_Actions.email = email => {
    window.location.href = "mailto:" + email;
    return Promise.resolve();
};
/****************************************/
Actions_Actions.webPage = url => {
    return Actions_Actions.loadPageAsync(new WebPage({ url: url }));
};
/****************************************/
Actions_Actions.navigate = uri => {
    return new Promise((res, rej) => {
        const newWindows = window.open(uri, "_blank");
        newWindows.addEventListener("load", ev => {
            res();
        });
        newWindows.addEventListener("error", ev => {
            rej();
        });
    });
};
/****************************************/
Actions_Actions.facebookPage = pageId => {
    window.location.href = "https://www.facebook.com/" + pageId;
    //window.location.href = "fb://page/" + pageId;
    return Promise.resolve();
};
/****************************************/
Actions_Actions.maps = (location, zoomLevel = 17) => {
    if (location.position)
        window.location.href = "https://www.google.com/maps/search/?api=1&query=" + location.position.latitude + "," + location.position.longitude;
    //window.location.href = "geo:" + location.position.latitude + "," + location.position.longitude;
    else
        window.location.href = "https://www.google.com/maps/search/?api=1&query=" + encodeURIComponent(location.address);
    return Promise.resolve();
};

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/ActivityEditor.js





/********************************************/
class ActivityEditor extends BindableObject_BindableObject {
    constructor(config) {
        super();
        /********************************************/
        this.editor = null;
        this.title = "Edit";
        this.bindConfig("editor", config);
        this.bindConfigString("title", config);
        if (config) {
            if (config.editToItemAsync)
                this.editToItemAsync = config.editToItemAsync;
        }
    }
    /********************************************/
    async editAsync(value, validate) {
        const activity = new ContentActivity_ContentActivity({
            providers: [new ItemEditContent({
                    editor: this.editor,
                    title: this.title,
                    value: value,
                    saveItemAsync: async (edit) => {
                        if (validate) {
                            const valResult = await validate(edit);
                            if (valResult == null)
                                return null;
                        }
                        return await this.editToItemAsync(edit);
                    }
                })]
        });
        const result = await (await Actions_Actions.loadPageAsync(activity, { loadMode: "add" })).result;
        if (result == null)
            return null;
        return this.editor.value;
    }
    /********************************************/
    editToItemAsync(edit) {
        return Promise.resolve(edit);
    }
}
registerType(ActivityEditor, "ActivityEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Activities/SelectMultipleItemsActivity.js
















/****************************************/
class SelectMultipleItemsActivity extends SearchActivity {
    constructor(config) {
        super(config);
        /****************************************/
        this.canAdd = false;
        this.showEmptyItem = false;
        this.emptyLabel = "[None]";
        this.itemsSource = null;
        this.addLabel = "Add New";
        this.filters = ObservableList_observableListOf();
        this.selectedItems = ObservableList_observableListOf();
        this.bindConfig("canAdd", config);
        this.bindConfigString("emptyLabel", config, DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfig("showEmptyItem", config);
        this.bindConfig("itemsSource", config);
        this.bindConfigString("addLabel", config);
        if (config) {
            if (config.createItemView)
                this.createItemContentView = config.createItemContentView;
            if (config.createItemListView)
                this.createItemListView = config.createItemListView;
            if (config.createItemEditor)
                this.createItemEditor = config.createItemEditor;
            if (config.filters)
                this.filters.addRange(config.filters);
            if (config.selectedItems)
                this.setSelectedItems(config.selectedItems);
            if (config.searchMode == "client") {
                this.searchWorkAsync = async (query) => {
                    if (!this._lastItems)
                        this._lastItems = await this.itemsSource.getItemsAsync(this.getFilter(undefined));
                    if (query) {
                        query = query.toLowerCase();
                        return (0,Linq/* linq */.k)(this._listView.items).where(a => {
                            const text = this.itemsSource.getItemText(a).toLowerCase();
                            return text && text.indexOf(query) != -1;
                        }).toArray();
                    }
                    else
                        return this._lastItems;
                };
            }
        }
        if (!(config === null || config === void 0 ? void 0 : config.tooltip))
            this.tooltip = DynamicString/* DynamicString.get */.wI.get("select-item")({ params: [this.itemsSource.displayName], number: DynamicString/* WordNumber.Plural */.sZ.Plural, usage: DynamicString/* StringUsage.Tooltip */.Fq.Tooltip });
        if (!(config === null || config === void 0 ? void 0 : config.addLabel))
            this.addLabel = Helpers_Format/* Format.action */.E.action("new-item", this.itemsSource.displayName);
    }
    /****************************************/
    setSelectedItems(items) {
        this.selectedItems.clear();
        if (items) {
            items.forEach(a => this.addSelection(a));
        }
    }
    /****************************************/
    async createAsync() {
        await super.createAsync();
        this._actionBar.addAction({
            name: "confirm",
            icon: "fas fa-check",
            displayName: "confirm",
            executeAsync: () => this.confirmAsync(),
            priority: IAction_ActionPriority.Primary
        });
        this._bottomSheet = new BottomSheet_BottomSheet({
            headHeight: 50,
            content: new ItemsView_ItemsView({
                styles: ["padding", "horizontal-wrap"],
                content: this.selectedItems
            })
        });
        this.view.addView(this._bottomSheet);
        this.updateView();
    }
    /****************************************/
    async confirmAsync() {
        await this.closeAsync((0,Linq/* linq */.k)(this.selectedItems).select(a => a.item).toArray());
    }
    /****************************************/
    configureListView() {
        const header = [];
        if (this.canAdd)
            header.push(ActionView_ActionView.fromAction({
                name: "add-item",
                icon: "fas fa-plus",
                operation: IOperation_OperationType.Local,
                executeAsync: () => this.addItemAsync(),
                displayName: this.addLabel,
            }));
        if (this.showEmptyItem) {
            this._emptyItem = new SelectableItemView_SelectableItemView({
                content: new TextView_TextView({ content: this.emptyLabel }),
                item: null,
            });
            this._emptyItem.toggle = () => this.closeAsync([]);
            header.push(this._emptyItem);
        }
        const result = {
            header: header,
            selectionMode: "multiple"
        };
        if (this.pageSize > 0)
            result.itemsSource = this.itemsSource;
        return result;
    }
    /****************************************/
    searchWorkAsync(query) {
        return this.itemsSource.getItemsAsync(this.getFilter(query));
    }
    /****************************************/
    getFilter(query, offset, pageSize) {
        let filter = this.itemsSource.getFilter(query, offset, pageSize);
        if (this.filters.count == 1)
            filter = Object.assign(Object.assign({}, filter), this.filters.get(0).content);
        return filter;
    }
    /****************************************/
    createItemListView(item) {
        return new TextView_TextView({ content: this.itemsSource.getItemText(item) });
    }
    /****************************************/
    createItemContentView(item) {
        return new TextView_TextView({ content: this.itemsSource.getItemText(item) });
    }
    /****************************************/
    createItemEditor() {
        throw "Not Supported";
    }
    /****************************************/
    createItemView(item) {
        const view = new SelectableItemView_SelectableItemView({
            content: this.createItemListView(item),
            item: item
        });
        view.prop("isSelected").subscribe(value => this.updateSelection(view, item, value));
        const exItem = this.findItem(item);
        if (exItem != null)
            view.isSelected = true;
        return view;
    }
    /****************************************/
    updateSelection(selView, item, isSelected) {
        if (!isSelected)
            this.removeSelection(item);
        else
            this.addSelection(item, selView);
        this.updateView();
    }
    /****************************************/
    updateView() {
        if (this._bottomSheet) {
            if (this.selectedItems.count > 0)
                this._bottomSheet.open();
            else
                this._bottomSheet.close();
        }
    }
    /****************************************/
    removeSelection(item) {
        const exItem = this.findItem(item);
        if (exItem)
            this.selectedItems.remove(exItem);
    }
    /****************************************/
    addSelection(item, selView) {
        const exItem = this.findItem(item);
        if (exItem)
            return;
        const itemView = new RemovableItemView_RemovableItemView({
            content: this.createItemContentView(item),
            removeAsync: () => {
                this.selectedItems.remove(itemView);
                const selItem = this.findSelectable(item);
                if (selItem)
                    selItem.isSelected = false;
                return Promise.resolve();
            },
            item: item
        });
        this.selectedItems.add(itemView);
        return itemView;
    }
    /****************************************/
    findItem(item) {
        return (0,Linq/* linq */.k)(this.selectedItems).first(a => this.itemsSource.itemComparer(a.item, item));
    }
    /****************************************/
    findSelectable(item) {
        return (0,Linq/* linq */.k)(this._listView.content).first(a => this.itemsSource.itemComparer(a.item, item));
    }
    /****************************************/
    async addItemAsync() {
        const editor = this.createItemEditor();
        let editValue;
        if (isAsyncEditor(editor))
            editValue = await editor.editAsync(this.itemsSource.newItem());
        else {
            const activity = new ActivityEditor({
                editor: editor,
                title: this.addLabel
            });
            editValue = await activity.editAsync(this.itemsSource.newItem());
        }
        if (!editValue)
            return;
        const newItem = await this.itemsSource.addItemAsync(editValue);
        if (!newItem)
            return;
        const itemView = this.createItemView(newItem);
        itemView.isSelected = true;
        this._listView.content.insert(0, itemView);
    }
}
registerType(SelectMultipleItemsActivity, "SelectMultipleItemsActivity");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Activities/SelectSingleItemActivity.js











/****************************************/
class SelectSingleItemActivity extends SearchActivity {
    constructor(config) {
        super(config);
        /****************************************/
        this.canAdd = false;
        this.itemsSource = null;
        this.addLabel = "Add New";
        this.filters = ObservableList_observableListOf();
        this.selectedValue = null;
        this.bindConfig("canAdd", config);
        this.bindConfig("itemsSource", config);
        this.bindConfig("selectedValue", config);
        this.bindConfigString("addLabel", config);
        if (config) {
            if (config.createItemContentView)
                this.createItemContentView = config.createItemContentView;
            if (config.createItemEditor)
                this.createItemEditor = config.createItemEditor;
            if (config.filters)
                this.filters.addRange(config.filters);
        }
        if (!(config === null || config === void 0 ? void 0 : config.tooltip))
            this.tooltip = Helpers_Format/* Format.tooltip */.E.tooltip("select-item", this.itemsSource.displayName);
        if (!(config === null || config === void 0 ? void 0 : config.addLabel))
            this.addLabel = Helpers_Format/* Format.action */.E.action("new-item", this.itemsSource.displayName);
    }
    /****************************************/
    async createAsync() {
        await super.createAsync();
        this._actionBar.addAction({
            name: "confirm",
            icon: "fas fa-check",
            displayName: "confirm",
            executeAsync: () => this.confirmAsync(),
            priority: IAction_ActionPriority.Primary
        });
    }
    /****************************************/
    async confirmAsync() {
        await this.closeAsync();
    }
    /****************************************/
    configureListView() {
        const header = [];
        if (this.canAdd)
            header.push(ActionView_ActionView.fromAction({
                name: "add-item",
                icon: "fas fa-plus",
                operation: IOperation_OperationType.Local,
                executeAsync: () => this.addItemAsync(),
                displayName: this.addLabel
            }));
        const result = {
            header: header,
        };
        if (this.pageSize > 0)
            result.itemsSource = this.itemsSource;
        return result;
    }
    /****************************************/
    searchWorkAsync(query) {
        return this.itemsSource.getItemsAsync(this.getFilter(query));
    }
    /****************************************/
    getFilter(query, offset, pageSize) {
        let filter = this.itemsSource.getFilter(query, offset, pageSize);
        if (this.filters.count == 1)
            filter = Object.assign(Object.assign({}, filter), this.filters.get(0).content);
        return filter;
    }
    /****************************************/
    createItemContentView(item) {
        return new TextView_TextView({ content: this.itemsSource.getItemText(item) });
    }
    /****************************************/
    createItemEditor() {
        throw "Not Supported";
    }
    /****************************************/
    createItemView(item) {
        const view = new SelectableItemView_SelectableItemView({
            content: this.createItemContentView(item),
            styles: ["single"],
            item: item
        });
        if (this.itemsSource.equals(this.itemsSource.getItemValue(item), this.selectedValue))
            view.isSelected = true;
        view.prop("isSelected").subscribe(value => {
            if (value)
                this.setSelectionAsync(item);
        });
        return view;
    }
    /****************************************/
    setSelectionAsync(item) {
        return this.closeAsync(item);
    }
    /****************************************/
    async addItemAsync() {
        const editor = this.createItemEditor();
        let editValue;
        if (isAsyncEditor(editor))
            editValue = await editor.editAsync(this.itemsSource.newItem());
        else {
            const activity = new ActivityEditor({
                editor: editor,
                title: this.addLabel
            });
            editValue = await activity.editAsync(this.itemsSource.newItem());
        }
        if (!editValue)
            return;
        const newItem = await this.itemsSource.addItemAsync(editValue);
        if (newItem)
            await this.setSelectionAsync(newItem);
    }
}
registerType(SelectSingleItemActivity, "SelectSingleItemActivity");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ConsoleView.js





class ConsoleItem extends View_View {
    constructor(args) {
        super();
        this.content = args;
    }
    /****************************************/
    debugTypeName() {
    }
}
/****************************************/
class ConsoleMessageView extends ConsoleItem {
    constructor(type, ...args) {
        super(args);
        this.type = type;
        this.template = "ConsoleMessageView";
    }
}
/****************************************/
class ConsoleGroupView extends ConsoleItem {
    constructor(...args) {
        super(args);
        /****************************************/
        this.items = ObservableList_observableListOf();
        this.template = "ConsoleGroupView";
    }
}
/****************************************/
class ConsoleView_ConsoleView extends ViewComponent {
    constructor() {
        super({ template: "ConsoleView" });
        this._groups = [];
        this._isCreated = false;
        this.root = new ConsoleGroupView();
        this._activeGroup = this.root;
    }
    /****************************************/
    debugTypeName() {
    }
    /****************************************/
    show() {
        if (!this._isCreated) {
            var builder = new TemplateBuilder_TemplateBuilder(this, document.body);
            builder.content(this);
        }
        this.visible = true;
    }
    /****************************************/
    hide() {
        this.visible = false;
    }
    /****************************************/
    attach() {
        if (this._oldConsole)
            return;
        this._oldConsole = {};
        for (const key in console)
            this._oldConsole[key] = console[key];
        console.log = (...args) => this.write("log", args);
        console.warn = (...args) => this.write("warn", args);
        console.info = (...args) => this.write("info", args);
        console.trace = (...args) => this.write("trace", args);
        console.error = (...args) => this.write("error", args);
        console.debug = (...args) => this.write("debug", args);
        console.clear = () => this.clear();
        console.group = (...args) => this.group(args);
        console.groupEnd = () => this.groupEnd();
    }
    /****************************************/
    detach() {
        if (!this._oldConsole)
            return;
        for (const key in console)
            console[key] = this._oldConsole[key];
        this._oldConsole = null;
    }
    /****************************************/
    write(logType, args) {
        this._oldConsole[logType].apply(console, args);
        this._activeGroup.items.add(new ConsoleMessageView(logType, args));
        if (logType == "error")
            this._activeGroup.items.add(new ConsoleMessageView(logType, new Error().stack));
    }
    /****************************************/
    group(args) {
        this._oldConsole.group.apply(console, args);
        const newGroup = new ConsoleGroupView(args);
        this._activeGroup.items.add(newGroup);
        this._groups.push(newGroup);
        this._activeGroup = newGroup;
    }
    /****************************************/
    groupEnd() {
        this._oldConsole.groupEnd.apply(console);
        if (this._groups.length > 0)
            this._activeGroup = this._groups.pop();
    }
    /****************************************/
    clear() {
        this._oldConsole.clear.apply(console);
        this._groups = [];
        this.root.items.clear();
        this._activeGroup = this.root;
    }
}
registerType(ConsoleView_ConsoleView, "ConsoleView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ContentHostView.js




/****************************************/
class ContentHostView_ContentHostView extends Panel_Panel {
    constructor(config) {
        super(Object.assign({}, config));
        /********************************************/
        this.title = null;
        this.actionTemplate = "ActionButton";
        this.contentProvider = null;
        this.bindConfig("contentProvider", config);
        this.bindConfig("actionTemplate", config);
        this._body = new Panel_Panel({ name: "body" });
        this._actions = new Panel_Panel({ name: "actions" });
        this.addView(this._body);
        this.addView(this._actions);
        this._body.emptyView = this.emptyView;
        this.emptyView = null;
    }
    /********************************************/
    async loadAsync() {
        if (this.contentProvider) {
            await this.closeAsync();
            const content = await this.contentProvider.getContentAsync(this);
            if (content.styles)
                this._body.styles = content.styles;
            this.name = this.contentProvider.info.name;
            this.title = Helpers_Format/* Format.title */.E.title(content.title);
            content.views.forEach(a => this._body.addView(a));
            if (content.actions)
                content.actions.forEach(a => this.addAction(a));
            await super.loadAsync();
            if (this.contentProvider.activateAsync)
                await this.contentProvider.activateAsync();
        }
        this._actions.visible = this._actions.content.count > 0;
    }
    /********************************************/
    addAction(action) {
        this._actions.addView(ActionView_ActionView.fromAction(action, { template: this.actionTemplate }));
    }
    /********************************************/
    notifyContentChanged(provider) {
        this.loadAsync();
    }
    /********************************************/
    async closeAsync(result) {
        var _a;
        if ((_a = this.contentProvider) === null || _a === void 0 ? void 0 : _a.deactivateAsync)
            await this.contentProvider.deactivateAsync();
        this._body.clear();
        this._actions.clear();
        this.title = null;
        return true;
    }
}
registerType(ContentHostView_ContentHostView, "ContentHostView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/Animation.js
/****************************************/
var Animation;
(function (Animation) {
    function cubic(p0, p1, p2, p3) {
        return t => Math.pow(1 - t, 3) * p0 +
            3 * Math.pow(1 - t, 2) * t * p1 +
            3 * (1 - t) * Math.pow(t, 2) * p2 +
            Math.pow(t, 3) * p3;
    }
    Animation.cubic = cubic;
    /****************************************/
    function linear() {
        return t => t;
    }
    Animation.linear = linear;
    /****************************************/
    function animate(options) {
        let curTime = 0;
        const handler = setInterval(() => {
            if (curTime > options.duration)
                curTime = options.duration;
            options.step(options.timeFunction(curTime / options.duration));
            if (curTime == options.duration)
                clearInterval(handler);
            curTime += options.stepTime;
        }, options.stepTime);
    }
    Animation.animate = animate;
})(Animation || (Animation = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/CounterView.js



/********************************************/
class CounterView_CounterView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "CounterView" }, config));
        /********************************************/
        this.title = null;
        this.value = 0;
        this.bindConfig("value", config);
        this.bindConfig("title", config);
        this.prop("value").subscribe(() => this.animate());
        if (this.value != null)
            this.animate();
    }
    /********************************************/
    animate() {
        this.content = 0;
        const duration = this.value / 200;
        return Animation.animate({
            timeFunction: Animation.linear(),
            duration: isNaN(duration) || duration < 1 ? 1 : duration,
            stepTime: 1 / 20,
            step: t => this.content = Math.round(this.value * t)
        });
    }
}
registerType(CounterView_CounterView, "CounterView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/Drawer.js









/****************************************/
class DrawerGroup {
    constructor(host, config) {
        /****************************************/
        this.actions = ObservableList_observableListOf();
        this.label = null;
        this._host = host;
        if (config) {
            this.label = Helpers_Format/* Format.action */.E.action(config.label);
            config.actions.forEach(a => this.addAction(a));
        }
    }
    /****************************************/
    addAction(action) {
        const actionView = ActionView_ActionView.fromAction(action, {
            executeAsync: async () => {
                this._host.hideAsync();
                await action.executeAsync();
            }
        });
        this.actions.add(actionView);
        return actionView;
    }
}
/****************************************/
class Drawer_Drawer extends View_View {
    constructor(config) {
        super(Object.assign({ template: "Drawer" }, config));
        /****************************************/
        this.status = "hidden";
        this.header = null;
        this.groups = ObservableList_observableListOf();
        this.bindConfig("header", config);
        if (config) {
            config.groups.forEach(a => this.addGroup(a));
        }
    }
    /****************************************/
    onGesture(data) {
        if (data.type == IGestureListener_GestureType.SwipeLeft)
            this.hideAsync();
    }
    /****************************************/
    getGroup(label) {
        const labelTxt = Helpers_Format/* Format.action */.E.action(label);
        return (0,Linq/* linq */.k)(this.groups).first(a => a.label == labelTxt);
    }
    /****************************************/
    addGroup(config) {
        const group = new DrawerGroup(this, config);
        this.groups.add(group);
        return group;
    }
    /****************************************/
    attach(element) {
        element.addEventListener("click", e => {
            if (e.srcElement == e.currentTarget)
                this.hideAsync();
        });
    }
    /****************************************/
    async showAsync(ctx) {
        this.status = "showing";
        await (0,PromiseUtils/* delayAsync */.$)(0);
        this.status = "visible";
    }
    /****************************************/
    async hideAsync() {
        this.status = "hiding";
        await (0,PromiseUtils/* delayAsync */.$)(500);
        if (this.status == "hiding")
            this.status = "hidden";
    }
}
registerType(Drawer_Drawer, "Drawer");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/FileUploadView.js




/****************************************/
/* FileViewModel                        */
/****************************************/
class FileUploadView_FileUploadView extends ViewComponent {
    constructor(config) {
        super(config);
        /****************************************/
        this.progress = 0;
        this.text = null;
        this.progressText = null;
        this.status = "empty";
        this.error = null;
        this.isSelected = false;
        this._input = document.createElement("input");
        this._input.type = "file";
        this._input.addEventListener("change", () => {
            this.update();
            if (config === null || config === void 0 ? void 0 : config.onChanged)
                config.onChanged();
        });
        this.update();
    }
    /****************************************/
    update() {
        const file = this._input.files[0];
        if (file) {
            this.text = file.name;
            this.status = "selected";
        }
        else {
            this.text = "Seleziona file";
            this.status = "empty";
        }
        this.isSelected = this._input.files[0] != null;
    }
    /****************************************/
    select() {
        this._input.click();
    }
    /****************************************/
    remove() {
    }
    /****************************************/
    async uploadAsync(url) {
        this.status = "uploading";
        const result = await Http/* Http.postBinaryAsync */.e.postBinaryAsync(url, this._input.files[0], ev => {
            this.progress = ev.loaded / ev.total;
            return true;
        });
        this.status = "uploaded";
        return result;
    }
    /****************************************/
    get file() {
        if (!this._input.files || this._input.files.length == 0)
            return null;
        return this._input.files[0];
    }
}
registerType(FileUploadView_FileUploadView, "FileUploadView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/GridView.js


/****************************************/
class GridView extends ListView_ListView {
    constructor(config) {
        super(Object.assign({ styles: ["grid"] }, config));
        /****************************************/
        this.colsCount = 0;
        this.rowsCount = 0;
        this.bindConfig("colsCount", config);
        this.bindConfig("rowsCount", config);
    }
}
registerType(GridView, "GridView");

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/Templates/HeadedContentView.html
var HeadedContentView = __webpack_require__(9337);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/HeadedContentView.js



/****************************************/
class HeadedContentView_HeadedContentView extends ContentView {
    constructor(config) {
        super(config);
        /****************************************/
        this.header = null;
        this.headerTemplate = null;
        this.bindConfig("header", config);
    }
}
registerType(HeadedContentView_HeadedContentView, "HeadedContentView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/HtmlView.js



class HtmlView_HtmlView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "Html" }, config));
    }
}
registerType(HtmlView_HtmlView, "HtmlView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/ImageLoade.js


function loadImageAsync(src) {
    const op = Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading image: " + src.substring(0, 50), type: IOperation_OperationType.Local });
    return new Promise((res, rej) => {
        const img = document.createElement("img");
        img.addEventListener("load", () => {
            res(img);
            op.end();
        });
        img.addEventListener("error", ev => {
            rej(ev === null || ev === void 0 ? void 0 : ev.error);
            op.end();
        });
        img.src = src;
    });
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ImageView.js




/********************************************/
class ImageView_ImageView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "Image" }, config));
    }
    /********************************************/
    loadAsync() {
        if (this.content)
            return loadImageAsync(this.content);
        return Promise.resolve();
    }
}
registerType(ImageView_ImageView, "ImageView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ItemView.js









/****************************************/
class ItemView_ItemView extends Panel_Panel {
    constructor(config) {
        super(Object.assign({ template: "ItemView" }, config));
        /****************************************/
        this.item = null;
        this.contextActions = [];
        this.mainActions = [];
        this.status = null;
        this.canOpen = false;
        this.hasActions = null;
        this.bindConfig("item", config);
        this.bindConfig("canOpen", config);
        if (config) {
            if (config.open)
                this.openWork = config.open;
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
            if (config.itemTemplate)
                this.content.add(new View_View({ template: t => t.template(config.itemTemplate, this) }));
        }
        this.computed("hasActions", m => (0,Linq/* linq */.k)(m.contextActions).any(a => a.visible));
        this.create();
    }
    /****************************************/
    addAction(action) {
        const view = ActionView_ActionView.fromItemAction(action, () => this.item);
        if (action.priority == IAction_ActionPriority.Primary) {
            if (this.mainActions.length >= 3) {
                if (!this._otherAction) {
                    this._otherAction = ActionView_ActionView.fromAction({
                        name: "other",
                        icon: "fas fa-ellipsis-h",
                        operation: IOperation_OperationType.Local,
                        executeAsync: () => Promise.resolve()
                    });
                    this._otherAction.subActions.add(this.mainActions.pop());
                    this.mainActions.push(this._otherAction);
                }
                this._otherAction.subActions.add(view);
            }
            else
                this.mainActions.push(view);
        }
        else {
            this.contextActions.push(view);
            this.prop("hasActions").notifyChanged();
        }
    }
    /****************************************/
    create() {
    }
    /****************************************/
    open() {
        if (this.canOpen)
            this.openWork();
    }
    /****************************************/
    openWork() {
    }
    /****************************************/
    showMenu() {
        const menu = new ContextMenu_ContextMenu();
        this.contextActions.forEach(a => menu.actions.add(a));
        menu.showAsync(window.event.srcElement);
    }
}
registerType(ItemView_ItemView, "ItemView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/LocationView.js




/********************************************/
class LocationView_LocationView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "LocationView" }, config));
        this.mapSize = { width: 1280, height: 720 };
        this.zoomLevel = 16;
        if (config) {
            if (config.mapSize)
                this.mapSize = config.mapSize;
            if (config.zoomLevel)
                this.zoomLevel = config.zoomLevel;
        }
        this.updateAsync();
    }
    /********************************************/
    onContentChanged() {
        this.updateAsync();
    }
    /********************************************/
    showMap() {
        Actions_Actions.maps(this.content);
    }
    /********************************************/
    async updateAsync() {
        const manager = Global/* Services.mapManager */.K9.mapManager();
        let pos = this.content.position;
        if (!pos)
            pos = await manager.getLocationAsync(this.content.address);
        this.map = manager.staticMap({
            center: pos,
            size: this.mapSize,
            zoomLevel: this.zoomLevel,
            pins: [{
                    center: pos,
                    icon: 113,
                    name: this.content.name
                }]
        });
    }
}
registerType(LocationView_LocationView, "LocationView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/MapItemsView.js






/********************************************/
class MapItemsView extends ItemsView_ItemsView {
    /********************************************/
    constructor(config) {
        super(Object.assign({ template: "Attach" }, config));
        /********************************************/
        this.itemsSource = null;
        this.status = "";
        this.selectedItem = null;
        this.showCurrentPosition = false;
        this.mapReady = new Signal_Signal();
        this.bindConfig("itemsSource", config);
        this.bindConfig("showCurrentPosition", config);
        if (config) {
            if (config.manager)
                this._manager = config.manager;
            if (config.createMapItem)
                this.createMapItem = config.createMapItem;
        }
        if (!this._manager)
            this._manager = Global/* Services.mapManager */.K9.mapManager();
        this.prop("selectedItem").subscribe(value => {
            if (!value)
                this._manager.selectedItem = null;
            else
                this._manager.selectedItem = value["@mapItem"];
            if (config && config.onItemSelected)
                config.onItemSelected(value);
        });
        this._manager.onSelectionChanged = () => {
            if (this._manager.selectedItem)
                this.selectedItem = this._manager.selectedItem["@item"];
            else
                this.selectedItem = null;
        };
        this.prop("showCurrentPosition").subscribe(value => {
            this.manager.showCurrentPositionAsync(value);
        });
    }
    /****************************************/
    async loadItemsAsync(filter) {
        if (!this.itemsSource)
            return;
        this.beginUpdate();
        this.content.clear();
        this.status = "loading";
        const operation = Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading items", type: IOperation_OperationType.Local });
        try {
            const items = await this.itemsSource.getItemsAsync(filter);
            if (items)
                items.forEach(a => this.content.add(a));
            if (this.mapReady.isSet)
                this.initItems();
        }
        finally {
            operation.end();
            this.status = "";
            this.endUpdate();
        }
    }
    /********************************************/
    attach(element) {
        Global/* Services.operation.progress */.K9.operation.progress("Map attacched");
        if (this._manager)
            this._manager.attach(element);
        this.mapReady.set();
        if (this.status != "loading")
            this.initItems();
        this._manager.showCurrentPositionAsync(this.showCurrentPosition);
    }
    /********************************************/
    initItems() {
        const mapOptions = (0,Linq/* linq */.k)(this.content).select(a => this.createMapItem(a)).toArray();
        const mapItems = this._manager.addItems(mapOptions);
        for (let i = 0; i < mapItems.length; i++) {
            set(this.content.get(i), "@mapItem", mapItems[i]);
            set(mapItems[i], "@item", this.content.get(i));
        }
    }
    /********************************************/
    createMapItem(item) {
        return undefined;
    }
    /********************************************/
    onItemAdded(item) {
        if (!this.mapReady.isSet)
            return;
        const options = this.createMapItem(item);
        if (!options.location || isNaN(options.location.latitude) || isNaN(options.location.longitude)) {
            console.warn("Invalid location for " + options.title);
            return;
        }
        const mapItem = this._manager.addItems([options]);
        set(item, "@mapItem", mapItem);
        set(mapItem, "@item", item);
    }
    /********************************************/
    onItemRemoved(item) {
        if (!this.mapReady.isSet)
            return;
        const mapItem = get(item, "@mapItem");
        if (mapItem)
            this._manager.removeItem(mapItem);
    }
    get manager() { return this._manager; }
}
registerType(MapItemsView, "MapItemsView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/MapView.js




/********************************************/
class MapView_MapView extends ViewComponent {
    constructor(config) {
        super(Object.assign({ template: "Attach" }, config));
        /********************************************/
        this.showCurrentPosition = false;
        this.mapReady = new Signal_Signal();
        if (config) {
            if (config.onMapLoaded)
                this.onMapLoaded = config.onMapLoaded;
            if (config.manager)
                this.manager = config.manager;
            this.bindConfig("showCurrentPosition", config);
        }
        if (!this.manager)
            this.manager = Global/* Services.mapManager */.K9.mapManager();
        this.prop("showCurrentPosition").subscribe(value => {
            this.manager.showCurrentPositionAsync(value);
        });
    }
    /********************************************/
    attach(element) {
        if (this.manager)
            this.manager.attach(element);
        this.mapReady.set();
        this.onMapLoaded();
        this.manager.showCurrentPositionAsync(this.showCurrentPosition);
    }
    /********************************************/
    onMapLoaded() {
    }
}
registerType(MapView_MapView, "MapView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/VideoLoader.js


function loadVideoAsync(src) {
    const op = Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading video: " + src.substring(0, 50), type: IOperation_OperationType.Local });
    return new Promise((res, rej) => {
        const video = document.createElement("video");
        video.addEventListener("playing", () => {
            video.pause();
            op.end();
            res(video);
        });
        video.addEventListener("error", ev => {
            op.end();
            rej("error" in ev ? ev.error : "video load error");
        });
        video.src = src;
        video.muted = true;
        video.play();
        if (video.readyState >= 2)
            res(video);
    });
}
function loadVideoIntoAsync(src, video) {
    if (!video.paused || video.played)
        return Promise.resolve();
    const op = Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading image: " + src, type: IOperation_OperationType.Local });
    return new Promise((res, rej) => {
        function removeListeners() {
            video.removeEventListener("playing", loadListener);
            video.removeEventListener("error", errorListener);
        }
        const loadListener = () => {
            op.end();
            removeListeners();
            res(undefined);
        };
        const errorListener = ev => {
            op.end();
            removeListeners();
            rej(ev.error);
        };
        video.addEventListener("playing", loadListener);
        video.addEventListener("error", errorListener);
        video.src = src;
        video.play();
    });
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/VideoView.js


;

/********************************************/
class VideoView_VideoView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "VideoView" }, config));
        /********************************************/
        this.isAutoPlay = true;
        this.isMuted = true;
        this.showControls = false;
        this.isLoop = true;
        this.bindConfig("isAutoPlay", config);
        this.bindConfig("isMuted", config);
        this.bindConfig("showControls", config);
        this.bindConfig("isLoop", config);
    }
    /********************************************/
    onContentChanged() {
        this.updateVideo();
    }
    /********************************************/
    attach(element) {
        this._video = element;
        this.updateVideo();
    }
    /********************************************/
    loadAsync() {
        if (this.content) {
            if (this._video)
                return loadVideoIntoAsync(this.content, this._video);
            else
                return loadVideoAsync(this.content);
        }
        return Promise.resolve();
    }
    /********************************************/
    updateVideo() {
        if (!this._video)
            return;
        this._video.muted = this.isMuted;
        this._video.autoplay = this.isAutoPlay;
        this._video.controls = this.showControls;
        this._video.loop = this.isLoop;
        if (this.content)
            this._video.load();
    }
    /********************************************/
    play() {
        if (this._video)
            this._video.play();
    }
    /********************************************/
    pause() {
        if (this._video)
            this._video.pause();
    }
}
registerType(VideoView_VideoView, "VideoView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/MediaView.js





/********************************************/
class MediaView_MediaView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "MediaView" }, config));
        this._imageConfig = {};
        this._videoConfig = {};
        /********************************************/
        this.activeView = null;
        if (config) {
            if (config.image)
                this._imageConfig = config.image;
            if (config.video)
                this._videoConfig = config.video;
        }
        this.updateContent();
    }
    /********************************************/
    loadAsync() {
        if (this.activeView)
            return this.activeView.loadAsync();
        return Promise.resolve();
    }
    /********************************************/
    onContentChanged() {
        this.updateContent();
    }
    /********************************************/
    updateContent() {
        if (this.content && this.content.type == "image")
            this.activeView = new ImageView_ImageView(Object.assign(Object.assign({}, this._imageConfig), { content: this.content.src }));
        if (this.content && this.content.type == "video")
            this.activeView = new VideoView_VideoView(Object.assign(Object.assign({}, this._videoConfig), { content: this.content.src }));
    }
}
registerType(MediaView_MediaView, "MediaView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/MessageBox.js






/****************************************/
class MessageBox_MessageBox extends BasePopUpMessage {
    constructor(config) {
        super(Object.assign({ template: "MessageBox", className: "message-box" }, config));
        /****************************************/
        this.actions = ObservableList_observableListOf();
        this.message = null;
        this.title = null;
        this.icon = null;
        this.bindConfigString("title", config, DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfigString("message", config, DynamicString/* StringUsage.Message */.Fq.Message);
        this.bindConfig("icon", config);
        if (config) {
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
        }
    }
    /****************************************/
    addAction(action) {
        var _a;
        const styles = (_a = action.styles) !== null && _a !== void 0 ? _a : [];
        if (action.priority == IAction_ActionPriority.Evidence)
            styles.push("primary");
        this.actions.add(ActionView_ActionView.fromAction(action, {
            template: "ActionButton",
            styles: styles,
            executeAsync: async () => {
                await action.executeAsync();
                this.hide(action.name);
            }
        }));
    }
}
registerType(MessageBox_MessageBox, "MessageBox");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/ProgressView.js


/********************************************/
class ProgressView_ProgressView extends ViewComponent {
    constructor(config) {
        super(config);
    }
}
registerType(ProgressView_ProgressView, "ProgressView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/BaseTextEditor.js



/********************************************/
class BaseTextEditor extends BaseEditor {
    constructor(config) {
        super(config);
        /********************************************/
        this.trackMode = "onlostfocus";
        this.bindConfig("trackMode", config);
        this.prop("hasFocus").subscribe(a => this.onFocusChanged(a));
    }
    /********************************************/
    attach(element) {
        this._element = element;
    }
    /********************************************/
    async activateAsync() {
        var _a;
        if (this._element.nodeName == "INPUT" || this._element.nodeName == "TEXTAREA") {
            while (true) {
                const input = this._element;
                input.selectionStart = 0;
                input.selectionEnd = (_a = input.value) === null || _a === void 0 ? void 0 : _a.length;
                this._element.focus();
                if (this.hasFocus)
                    break;
                await (0,PromiseUtils/* delayAsync */.$)(100);
            }
        }
    }
    /********************************************/
    onFocusChanged(value) {
        if (!value && this.trackMode == "onlostfocus")
            this.notifyEditValueChangedAsync();
    }
    /********************************************/
    notifyEditValueChangedAsync() {
        if (this.hasFocus && this.trackMode == "onlostfocus") {
            this._needValidation = true;
            this.isDirty = true;
            return Promise.resolve();
        }
        return super.notifyEditValueChangedAsync();
    }
}
registerType(BaseTextEditor, "BaseTextEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/NumberEditor.js


/********************************************/
class NumberEditor extends BaseTextEditor {
    constructor(config) {
        super(Object.assign({ template: "NumberEditor" }, config));
        /********************************************/
        this.placeholder = null;
        this.min = null;
        this.max = null;
        this.precision = null;
        this.bindConfig("placeholder", config);
        this.bindConfig("precision", config);
        this.createEditValueProp();
    }
    /********************************************/
    valueToEdit(value) {
        return isNaN(value) ? "" : (this.precision != null ? value.toFixed(this.precision) : value.toString()).replace(".", ",");
    }
    /********************************************/
    editToValue(value) {
        const result = parseFloat(value === null || value === void 0 ? void 0 : value.replace(",", "."));
        return isNaN(result) ? null : result;
    }
}
registerType(NumberEditor, "NumberEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/PropertyView.js







/********************************************/
class PropertyView_PropertyView extends ViewComponent {
    constructor(config) {
        super(Object.assign({ template: "PropertyView" }, config));
        this._lastValidationValue = undefined;
        /********************************************/
        this.isDirty = null;
        this.isValid = true;
        this.value = null;
        this.editor = null;
        this.error = null;
        this.label = null;
        this.readonly = false;
        this.showLabel = true;
        this.host = null;
        this.validators = [];
        this.bindConfig("host", config);
        this.bindConfig("editor", config);
        this.bindConfig("readonly", config);
        this.bindConfig("showLabel", config);
        this.bindConfig("value", config);
        this.bindConfigString("label", config, DynamicString/* StringUsage.Label */.Fq.Label);
        this.prop("error");
        if (config) {
            if (config.onChanged)
                this.prop("value").subscribe((o, n) => { var _a; return config.onChanged(o, n, (_a = this.host) === null || _a === void 0 ? void 0 : _a.editValue, "editor"); });
            if (config.validators)
                this.validators = config.validators;
        }
        this.prop("editor").subscribe(() => this.bindEditor());
        this.bindEditor();
    }
    /********************************************/
    bindEditor() {
        if (this.editor) {
            this.editor.name = this.name;
            this.editor.value = this.value;
            this.bind("value", this.editor.prop("value"));
            this.bind("isDirty", this.editor.prop("isDirty"));
            if ("label" in this.editor) {
                this.bind("label", this.editor.prop("label"));
                this.showLabel = false;
            }
            this.editor.prop("isValid").subscribe(value => {
                if (!value)
                    this.isValid = false;
                this.error = this.editor.error;
            });
        }
    }
    /********************************************/
    clearError() {
        this.editor.error = null;
        this.error = null;
    }
    /********************************************/
    async validateAsync(target, force) {
        console.group("begin validation: " + this.label, " - needValidation: ", this.isDirty);
        try {
            await (0,PromiseUtils/* delayAsync */.$)(0);
            //TODO fix this, sometimes is editValue other time value
            const curValue = this.editor instanceof NumberEditor ? this.editor.value : this.editor.editValue;
            if (!force && this._lastValidationValue !== undefined && equals(this._lastValidationValue, curValue))
                return this.isValid;
            this.clearError();
            this._lastValidationValue = curValue;
            if (!await this.editor.validateAsync(force)) {
                this.isValid = false;
                this.error = this.editor.error;
                return false;
            }
            const ctx = {
                value: curValue,
                fieldName: this.label,
                target: target
            };
            for (const validator of this.validators) {
                const result = await validator.validateAsync(ctx);
                if (!result.isValid) {
                    this.error = Helpers_Format/* Format.message */.E.message(result.error);
                    this.isValid = false;
                    return false;
                }
            }
            this.isValid = true;
            return true;
        }
        finally {
            console.groupEnd();
        }
    }
    /********************************************/
    loadAsync() {
        return this.editor.loadAsync();
    }
    /********************************************/
    clear() {
        this.editor.clear();
        this.clearError();
    }
}
registerType(PropertyView_PropertyView, "PropertyView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/SectionsView.js





/********************************************/
class SectionView extends ContentView {
    constructor(config) {
        super(config);
        if (typeof (config === null || config === void 0 ? void 0 : config.header) == "string")
            this.header = new TextView_TextView({ content: config.header });
    }
}
/********************************************/
class SectionsView_SectionsView extends ItemsView_ItemsView {
    constructor(config) {
        super(config);
        if (config === null || config === void 0 ? void 0 : config.sections)
            config.sections.forEach(a => this.content.add(new SectionView(a)));
    }
    /********************************************/
    section(name) {
        return (0,Linq/* linq */.k)(this.content).first(a => a.name == name);
    }
}
registerType(SectionsView_SectionsView, "SectionsView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/SimpleItemView.js



/****************************************/
class SimpleItemView_SimpleItemView extends IconTextView_IconTextView {
    constructor(config) {
        super(config);
        /****************************************/
        this.subText = null;
        this.status = null;
        this.item = null;
        this.bindConfigString("subText", config);
        this.bindConfig("status", config);
        this.bindConfig("item", config);
    }
}
registerType(SimpleItemView_SimpleItemView, "SimpleItemView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/SnackBar.js







/****************************************/
class SnackBar_SnackBar extends ViewComponent {
    constructor() {
        super({ template: "SnackBar" });
        /****************************************/
        this.action = null;
        this.content = null;
        this.showTime = TimeSpan_TimeSpan.fromSeconds(0);
        this.instanceId = null;
        this.status = "close";
        new TemplateBuilder_TemplateBuilder(this, document.body).content(this);
    }
    /****************************************/
    async showAsync() {
        if (this.status == "open")
            return;
        Global/* App.unblock */.gV.unblock(true);
        await (0,PromiseUtils/* delayAsync */.$)(0);
        this.status = "open";
        return new Promise(res => this._showResolve = res);
    }
    /****************************************/
    hide(actionName) {
        if (this.status != "open")
            return;
        this.status = "close";
        Global/* App.restoreBlock */.gV.restoreBlock();
        if (this._showResolve) {
            this._showResolve(actionName);
            this._showResolve = null;
        }
    }
    /****************************************/
    static showAsync(options) {
        const instanceId = new Date().valueOf();
        if (!SnackBar_SnackBar.instance)
            SnackBar_SnackBar.instance = new SnackBar_SnackBar();
        SnackBar_SnackBar.instance.content = options.content;
        SnackBar_SnackBar.instance.instanceId = instanceId;
        if (options.action) {
            let action;
            if (typeof options.action == "string")
                action = {
                    name: options.action,
                    executeAsync: () => Promise.resolve()
                };
            else
                action = options.action;
            SnackBar_SnackBar.instance.action = ActionView_ActionView.fromAction(action, {
                executeAsync: async () => {
                    await action.executeAsync();
                    SnackBar_SnackBar.instance.hide(action.name);
                }
            });
        }
        else
            SnackBar_SnackBar.instance.action = null;
        if (options.showTime) {
            setTimeout(() => {
                if (SnackBar_SnackBar.instance.instanceId == instanceId && SnackBar_SnackBar.instance._isVisible)
                    SnackBar_SnackBar.instance.hide(null);
            }, options.showTime.totalMilliseconds);
        }
        return SnackBar_SnackBar.instance.showAsync();
    }
}
SnackBar_SnackBar.instance = null;
registerType(SnackBar_SnackBar, "SnackBar");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/StaticMapView.js



/********************************************/
class StaticMapView extends ViewComponent {
    constructor(config) {
        super(Object.assign({ template: "ImageView" }, config));
        this.bindConfig("options", config);
        this.update();
    }
    /********************************************/
    update() {
        this.content = Global/* Services.mapManager */.K9.mapManager().staticMap(this.options);
    }
}
registerType(StaticMapView, "StaticMapView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/Toast.js







/****************************************/
class Toast_Toast extends ViewComponent {
    constructor(config) {
        super(Object.assign({ template: "Toast", visible: false }, config));
        /****************************************/
        this.message = null;
        this.icon = null;
        this.showTime = TimeSpan_TimeSpan.fromSeconds(0);
        if (Toast_Toast._container == null)
            Toast_Toast.init();
        this.bindConfigString("message", config, DynamicString/* StringUsage.Tooltip */.Fq.Tooltip);
        this.bindConfig("showTime", config);
        this.bindConfig("icon", config);
    }
    /****************************************/
    static init() {
        Toast_Toast._container = document.createElement("div");
        Toast_Toast._container.className = "toast-container";
        const builder = new TemplateBuilder_TemplateBuilder(Toast_Toast._items, Toast_Toast._container);
        builder.template("ToastContainer", a => a);
        document.body.appendChild(Toast_Toast._container);
    }
    /****************************************/
    async showAsync() {
        Toast_Toast._items.add(this);
        await (0,PromiseUtils/* delayAsync */.$)(10);
        this.visible = true;
        let showMs = this.showTime.totalMilliseconds;
        if (showMs == 0)
            showMs = Math.min(Math.max(this.message.length * 70, 2000), 7000);
        setTimeout(() => this.hideAsync(), showMs);
        return new Promise(res => this._showResolve = res);
    }
    /****************************************/
    async hideAsync() {
        this.visible = false;
        await (0,PromiseUtils/* delayAsync */.$)(600);
        Toast_Toast._items.remove(this);
        if (this._showResolve) {
            this._showResolve();
            this._showResolve = null;
        }
    }
}
Toast_Toast._items = ObservableList_observableListOf();
registerType(Toast_Toast, "Toast");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Components/WizardView.js









/****************************************/
class WizardStepView extends ContentView {
    constructor(config) {
        super(Object.assign({ template: "ContentView" }, config));
        /****************************************/
        this.error = null;
        this.isValid = true;
        this.index = 0;
        this.title = "";
        this.isActive = false;
        this.nextLabel = null;
        this.coverImage = null;
        this.actions = ObservableList_observableListOf();
        this.bindConfig("index", config);
        this.bindConfig("coverImage", config);
        this.bindConfigString("title", config, DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfigString("nextLabel", config, DynamicString/* StringUsage.Action */.Fq.Action);
        if (config) {
            if (config.loadAsync)
                this.loadAsync = () => config.loadAsync(this);
            if (config.validateAsync)
                this.validateAsync = force => config.validateAsync(this);
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
        }
    }
    /****************************************/
    addAction(action) {
        const view = ActionView_ActionView.fromAction(action, { template: "ActionButton", styles: ["primary"] });
        this.actions.add(view);
        return view;
    }
    /****************************************/
    loadAsync() {
        if (isAsyncLoad(this.content))
            return this.content.loadAsync();
        return Promise.resolve();
    }
    /****************************************/
    async validateAsync(force) {
        if (isValidable(this.content))
            this.isValid = await this.content.validateAsync(force);
        return this.isValid;
    }
    /****************************************/
    select() {
        this.parentView.selectStepAsync(this.index);
    }
}
/****************************************/
/* WizardViewModel
/****************************************/
class WizardView_WizardView extends ItemsView_ItemsView {
    constructor(config) {
        super(Object.assign({ template: "WizardView" }, config));
        /****************************************/
        this.currentStepIndex = -1;
        this.nextLabel = "Next";
        this.prevLabel = "Previous";
        this.finishLabel = "Finish";
        this.actions = {
            next: new ActionView_ActionView({
                name: "next",
                template: "ActionButton",
                styles: ["secondary"],
                content: new IconTextView_IconTextView({
                    template: "IconTextViewInline",
                    text: this.prop("nextLabel")
                }),
                executeAsync: () => this.nextAsync()
            }),
            prev: new ActionView_ActionView({
                name: "prev",
                template: "ActionButton",
                styles: ["secondary"],
                content: new IconTextView_IconTextView({
                    template: "IconTextViewInline",
                    text: this.prop("prevLabel")
                }),
                executeAsync: () => this.previousAsync()
            }),
            finish: new ActionView_ActionView({
                name: "finish",
                template: "ActionButton",
                styles: ["secondary"],
                content: new IconTextView_IconTextView({
                    template: "IconTextViewInline",
                    text: this.prop("finishLabel")
                }),
                executeAsync: () => this.finishAsync()
            })
        };
        this.prop("currentStepIndex").subscribe((value, oldValue) => {
            var _a;
            if (oldValue != -1)
                this.content.get(oldValue).isActive = false;
            this.content.get(value).isActive = true;
            this.currentView = this.content.get(value);
            this.actions.next.visible = this.hasNextStep();
            this.actions.prev.visible = this.hasPrevStep();
            this.actions.finish.visible = !this.hasNextStep();
            if (this.currentView.nextLabel)
                this.nextLabel = this.currentView.nextLabel;
            else
                this.nextLabel = Helpers_Format/* Format.action */.E.action((_a = config === null || config === void 0 ? void 0 : config.nextLabel) !== null && _a !== void 0 ? _a : "wizard-next");
        });
        this.bindConfigString("nextLabel", config, DynamicString/* StringUsage.Action */.Fq.Action);
        this.bindConfigString("prevLabel", config, DynamicString/* StringUsage.Action */.Fq.Action);
        this.bindConfigString("finishLabel", config, DynamicString/* StringUsage.Action */.Fq.Action);
        if (config) {
            if (config.steps) {
                config.steps.forEach((step, i) => this.content.add(new WizardStepView(Object.assign(Object.assign({}, step), { index: i }))));
                this.currentStepIndex = 0;
            }
            if (config.finishAsync)
                this.doFinishAsync = config.finishAsync;
        }
        if (!(config === null || config === void 0 ? void 0 : config.prevLabel))
            this.prevLabel = Helpers_Format/* Format.action */.E.action("wizard-prev");
        if (!(config === null || config === void 0 ? void 0 : config.finishLabel))
            this.prevLabel = Helpers_Format/* Format.action */.E.action("wizard-finish");
    }
    /****************************************/
    async finishAsync() {
        if (await this.validateUntilAsync(this.content.count - 1) !== true)
            return;
        await this.doFinishAsync();
    }
    /****************************************/
    async doFinishAsync() {
        return Promise.resolve();
    }
    /****************************************/
    clearErrors() {
    }
    /****************************************/
    async validateUntilAsync(targetIndex) {
        let curStep = this.currentStepIndex;
        while (curStep <= targetIndex) {
            if (!await this.content.get(curStep).validateAsync())
                return curStep;
            curStep++;
        }
        return true;
    }
    /****************************************/
    async loadAsync() {
        if (this.content.count > 0)
            await this.content.get(this.currentStepIndex).loadAsync();
    }
    /****************************************/
    async selectStepAsync(index) {
        if (index == this.currentStepIndex)
            return;
        this.clearErrors();
        if (index > this.currentStepIndex) {
            const result = await this.validateUntilAsync(index - 1);
            if (result === true) {
                this.currentStepIndex = index;
                await this.content.get(index).loadAsync();
            }
            else {
                this.currentStepIndex = result;
                if (result != this.currentStepIndex)
                    await this.content.get(result).loadAsync();
            }
        }
        else
            this.currentStepIndex = index;
    }
    /****************************************/
    async nextAsync() {
        if (this.currentStepIndex + 1 < this.content.count)
            await this.selectStepAsync(this.currentStepIndex + 1);
    }
    /****************************************/
    async previousAsync() {
        if (this.currentStepIndex > 0)
            await this.selectStepAsync(this.currentStepIndex - 1);
    }
    /****************************************/
    async endAsync() {
        await this.selectStepAsync(this.content.count - 1);
    }
    /****************************************/
    hasPrevStep() {
        let curIndex = this.currentStepIndex - 1;
        while (curIndex >= 0) {
            if (this.content.get(curIndex).visible)
                return true;
            curIndex--;
        }
        return false;
    }
    /****************************************/
    hasNextStep() {
        let curIndex = this.currentStepIndex + 1;
        while (curIndex <= this.content.count - 1) {
            if (this.content.get(curIndex).visible)
                return true;
            curIndex++;
        }
        return false;
    }
    /****************************************/
    isComplete() {
        return !this.hasNextStep();
    }
}
registerType(WizardStepView, "WizardStepView");
registerType(WizardView_WizardView, "WizardView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Content/ItemListContent.js







/****************************************/
class ItemListContent extends BindableObject_BindableObject {
    /****************************************/
    constructor() {
        super();
        this._isRefreshing = false;
        this._isBodyScroll = false;
    }
    /****************************************/
    async refreshAsync() {
        this._isRefreshing = true;
        try {
            if (await this.prepareFilterAsync(this._listView.filter))
                await this._listView.refreshAsync();
        }
        finally {
            this._isRefreshing = false;
        }
    }
    /****************************************/
    prepareFilterAsync(filter) {
        return Promise.resolve(true);
    }
    /****************************************/
    deactivateAsync() {
        var _a;
        if (this._isBodyScroll)
            this.removeContent();
        (_a = this._listView) === null || _a === void 0 ? void 0 : _a.deactivateListener();
        return Promise.resolve();
    }
    /****************************************/
    async activateAsync(reason) {
        var _a;
        (_a = this._listView) === null || _a === void 0 ? void 0 : _a.activateListener();
        if (reason == "loading")
            await this.refreshAsync();
    }
    /****************************************/
    async getContentAsync(host) {
        var _a;
        const views = [];
        const options = await this.configureAsync(host);
        this._listView = new ListView_ListView(Object.assign({ itemsSource: options.itemsSource, itemsLoader: options.pageSize ? new PagedItemsLoader_PagedItemsLoader({
                pageSize: options.pageSize
            }) : undefined }, options.listView));
        this._listView.loadAsync = () => Promise.resolve();
        if (options.filters) {
            if (options.filters.length > 1) {
                this._tabView = new NavBar_NavBar({
                    styles: ["tab-view"],
                    itemTemplate: "TextView",
                    itemBehavoirs: ["ripple"],
                    onItemSelected: item => {
                        this._listView.filter = item.content;
                        this.refreshAsync();
                    },
                    items: (0,Linq/* linq */.k)(options.filters).select(a => ({
                        name: a.name,
                        text: a.name,
                        content: a.content
                    })).toArray()
                });
                views.push(this._tabView);
            }
            else if (options.filters.length == 1)
                this._listView.filter = options.filters[0].content;
        }
        views.push(this._listView);
        if (this._tabView)
            this._tabView.selectedItem = this._tabView.content.get(0);
        if (options.footer)
            options.footer.forEach(a => views.push(a));
        this._listView.activateListener();
        //await this.refreshAsync();
        if (options.isBodyScroll) {
            this._isBodyScroll = true;
            setTimeout(() => this.moveContent());
        }
        return Promise.resolve({
            title: (_a = options.title) !== null && _a !== void 0 ? _a : this.info.displayName,
            actions: options.actions,
            styles: options.styles,
            views: views,
            url: options.url,
            searchAsync: options.canSearch ? text => this.searchAsync(text) : undefined
        });
    }
    /****************************************/
    removeContent() {
        DomUtils_removeClass(document.scrollingElement, "scroll");
        DomUtils_removeClass(document.body.parentElement, "body-scroll");
        const element = document.querySelector("." + ViewUtils_formatForCss(this.info.name));
        if (element)
            element.remove();
    }
    /****************************************/
    moveContent() {
        const element = document.querySelector("." + ViewUtils_formatForCss(this.info.name));
        let container = document.querySelector(".scroll-content");
        if (!container) {
            container = document.createElement("div");
            container.classList.add("scroll-content");
            document.body.insertBefore(container, document.body.firstChild);
        }
        container.innerHTML = "";
        container.appendChild(element);
        DomUtils_addClass(document.body.parentElement, "body-scroll");
        DomUtils_removeClass(element, "scroll");
        DomUtils_addClass(document.scrollingElement, "scroll");
    }
    /****************************************/
    setFilter(name, content) {
        this._listView.filter = content;
        if (this._tabView) {
            let item = this._tabView.getItem(name);
            if (!item) {
                item = this._tabView.addItem({
                    text: name,
                    name: name,
                    content: content
                });
            }
            else {
                item.content = content;
            }
            const isSelected = this._tabView.selectedItem == item;
            this._tabView.selectedItem = item;
            return isSelected;
        }
        else
            return true;
    }
    /****************************************/
    async searchAsync(text) {
        this._listView.filter = Object.assign(Object.assign({}, this._listView.filter), this._listView.itemsSource.getFilter(text));
        await this._listView.refreshAsync();
    }
    /****************************************/
    get listView() {
        return this._listView;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Content/MapContent.js



/****************************************/
class MapContent {
    /****************************************/
    constructor(config) {
        if (config) {
            if (config.showCurrentPosition !== undefined)
                this._showCurrentPosition = config.showCurrentPosition;
        }
    }
    /****************************************/
    refreshAsync() {
        return null;
    }
    /****************************************/
    async getContentAsync(host) {
        this._mapView = new MapView_MapView({
            onMapLoaded: () => this.onMapLoaded(),
            manager: Global/* Services.mapManager */.K9.mapManager(),
            showCurrentPosition: this._showCurrentPosition
        });
        this._progress = new ProgressView_ProgressView();
        return {
            views: [this._mapView, this._progress],
            title: this.info.displayName
        };
    }
    /****************************************/
    createMapAsync(manager) {
        return Promise.resolve();
    }
    /****************************************/
    async onMapLoaded() {
        await this.createMapAsync(this._mapView.manager);
        this._progress.visible = false;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Content/MasterDetailsContent.js






/****************************************/
class MasterDetailsContent extends BindableObject_BindableObject {
    constructor(config) {
        super();
        /****************************************/
        this.isDetailsLoading = false;
        this.details = null;
        this.minWidth = 400;
        this.masterContent = null;
        this.styles = ["horizontal", "fill-v", "fill-h", "fill-items-v", "master-details"];
        this.mode = "auto";
        this.itemDisplayName = null;
        this.bindConfig("mode", config);
        this.bindConfig("masterContent", config);
        this.bindConfig("itemDisplayName", config);
        this.bindConfig("minWidth", config);
        if (config != null) {
            if (config.styles)
                config.styles.forEach(a => this.styles.push(a));
        }
        if (this.masterContent)
            this.masterContent.masterHost = this;
    }
    /****************************************/
    activateAsync(reason) {
        if (this.masterContent.activateAsync)
            return this.masterContent.activateAsync(reason);
        return Promise.resolve();
    }
    /****************************************/
    deactivateAsync() {
        if (this.masterContent.deactivateAsync)
            return this.masterContent.deactivateAsync();
        return Promise.resolve();
    }
    /****************************************/
    async getContentAsync(host) {
        this._host = host;
        if (this.mode == "auto") {
            const curWidth = document.body.clientWidth / window.devicePixelRatio;
            if (curWidth > this.minWidth)
                this.mode = "split-h";
            else
                this.mode = "separate";
        }
        if (this.mode != "separate") {
            const views = [];
            this._masterContainer = new ContentHostView_ContentHostView({
                name: "master",
                contentProvider: this.masterContent
            });
            this._detailsContainer = new ContentHostView_ContentHostView({
                name: "details",
                emptyView: new IconTextView_IconTextView({
                    styles: ["empty-view"],
                    icon: this.info.icon,
                    text: Helpers_Format/* Format.message */.E.message("msg-select-an-item", this.itemDisplayName)
                })
            });
            views.push(this._masterContainer);
            views.push(this._detailsContainer);
            return Promise.resolve({
                views: views,
                styles: [...this.styles, this.mode],
                title: this.info.displayName
            });
        }
        else
            return this.masterContent.getContentAsync(host);
    }
    /****************************************/
    async showDetailsAsync(item) {
        var _a;
        if (this.isDetailsLoading)
            return;
        try {
            this.isDetailsLoading = true;
            if (!item) {
                if (this.mode != "separate")
                    await this._detailsContainer.closeAsync();
            }
            else {
                const details = await this.masterContent.getDetailsAsync(item);
                if (!details)
                    return;
                if (this.mode != "separate") {
                    if ((_a = this._detailsContainer.contentProvider) === null || _a === void 0 ? void 0 : _a.deactivateAsync)
                        await this._detailsContainer.contentProvider.deactivateAsync();
                    this._detailsContainer.contentProvider = details;
                    await this._detailsContainer.loadAsync();
                }
                else {
                    await Actions_Actions.loadPageAsync(new ContentActivity_ContentActivity({
                        providers: [details],
                        name: details.info.name,
                    }));
                }
                this.details = details;
            }
        }
        finally {
            this.isDetailsLoading = false;
        }
    }
    get info() { return this.masterContent.info; }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Content/MessageContent.js




class MessageContent {
    /****************************************/
    constructor(options) {
        this._options = options;
    }
    /****************************************/
    async getContentAsync(host) {
        const views = [];
        views.push(new IconTextView_IconTextView({
            icon: this._options.icon,
            text: this._options.message,
            styles: ["message-view"]
        }));
        if (this._options.customActions) {
            this._options.customActions.forEach(action => views.push(new ActionView_ActionView({
                name: action.name,
                template: "ActionButton",
                styles: ["primary"],
                content: new TextView_TextView({ content: Helpers_Format/* Format.action */.E.action(action.displayName) }),
                executeAsync: async () => {
                    await host.closeAsync();
                    await action.executeAsync();
                }
            })));
        }
        return Promise.resolve({
            views: views,
            title: this._options.title,
            styles: ["vertical", "margin-items-v", "scroll", "fit-items-h", "surface", "padding", "small"],
        });
    }
    /****************************************/
    get info() {
        return {
            name: "message",
            icon: null,
            displayName: this._options.title
        };
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/BaseItemEditor.js


/****************************************/
class BaseItemEditor extends BindableObject_BindableObject {
    constructor(config) {
        super();
        /****************************************/
        this.view = null;
        this.value = null;
        this.isValid = null;
    }
    /****************************************/
    beginEditAsync(item) {
        throw "Not implemented";
    }
    /****************************************/
    commitAsync(force) {
        throw "Not implemented";
    }
}
registerType(BaseItemEditor, "BaseItemEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/BasePicker.js







/****************************************/
class BasePicker extends BaseEditor {
    constructor(config) {
        super(config);
        /****************************************/
        this.canAdd = false;
        this.addLabel = "Add";
        this.pickLabel = "Select";
        this.selectAction = null;
        this.itemsSource = null;
        this.pageSize = 0;
        this.searchMode = "default";
        this.filters = ObservableList_observableListOf();
        this.bindConfig("canAdd", config);
        this.bindConfig("itemsSource", config);
        this.bindConfig("pageSize", config);
        this.bindConfigString("addLabel", config);
        this.bindConfigString("pickLabel", config);
        this.bindConfig("searchMode", config);
        if (config) {
            if (config.filters)
                this.filters.addRange(config.filters);
            if (config.createItemView)
                this.createItemView = config.createItemView;
            if (config.createItemListView)
                this.createItemListView = config.createItemListView;
            if (config.createItemEditor)
                this.createItemEditor = config.createItemEditor;
        }
        if (!(config === null || config === void 0 ? void 0 : config.addLabel))
            this.addLabel = Helpers_Format/* Format.title */.E.title("new-item", this.itemsSource.displayName);
        if (!(config === null || config === void 0 ? void 0 : config.pickLabel))
            this.pickLabel = Helpers_Format/* Format.title */.E.title("select-item", this.itemsSource.displayName);
        this.createEditValueProp();
        this.selectAction = ActionView_ActionView.fromActionIcon({
            name: "select",
            icon: "fas fa-list",
            operation: IOperation_OperationType.Local,
            displayName: this.pickLabel,
            executeAsync: () => this.selectAsync()
        });
    }
    /****************************************/
    createItemEditor() {
        throw "Not Supported";
    }
    /****************************************/
    createItemView(item) {
        return new TextView_TextView({ content: this.itemsSource.getItemText(item) });
    }
    /****************************************/
    createItemListView(item) {
        return this.createItemView(item);
    }
    /****************************************/
    async notifyEditValueChangedAsync() {
        await super.notifyEditValueChangedAsync();
        await this.updateViewAsync();
    }
}
registerType(BasePicker, "BasePicker");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/BooleanEditor.js



/********************************************/
class BooleanEditor_BooleanEditor extends BaseEditor {
    constructor(config) {
        super(Object.assign({ template: "CheckBox" }, config));
        /********************************************/
        this.trueLabel = null;
        this.falseLabel = null;
        this.label = null;
        this.bindConfigString("trueLabel", config);
        this.bindConfigString("falseLabel", config);
        this.bindConfigString("label", config, DynamicString/* StringUsage.Action */.Fq.Action);
        this.createEditValueProp();
    }
    /********************************************/
    toggle() {
        if (window.event)
            window.event.stopPropagation();
        this.editValue = !this.editValue;
    }
}
registerType(BooleanEditor_BooleanEditor, "BooleanEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/DateEditor.js



/********************************************/
class DateEditor_DateEditor extends BaseTextEditor {
    constructor(config) {
        super(Object.assign({ template: "DateEditor" }, config));
        /********************************************/
        this.placeholder = null;
        this.bindConfig("placeholder", config);
        this.createEditValueProp();
    }
    /********************************************/
    valueToEdit(value) {
        return value === null || value === undefined ? "" : formatDate(value, "{YYYY}-{MM}-{DD}");
    }
    /********************************************/
    editToValue(value) {
        if (value === undefined || value === null)
            return null;
        return parseDate(value + " 00:00");
    }
}
registerType(DateEditor_DateEditor, "DateEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/DateEditorCombo.js



/********************************************/
class DateEditorCombo_DateEditorCombo extends BaseEditor {
    constructor(config) {
        var _a, _b;
        super(config);
        /********************************************/
        this.selectedDay = null;
        this.selectedMonth = null;
        this.selectedYear = null;
        this.days = [];
        this.months = [];
        this.years = [];
        for (let i = 1; i <= 31; i++)
            this.days.push(i.toString());
        for (let i = 1; i <= 12; i++)
            this.months.push({ number: i.toString(), name: MONTHS[i - 1] });
        const maxYear = (_a = config === null || config === void 0 ? void 0 : config.maxYear) !== null && _a !== void 0 ? _a : new Date().getFullYear();
        const minYear = (_b = config === null || config === void 0 ? void 0 : config.minYear) !== null && _b !== void 0 ? _b : new Date().getFullYear() - 100;
        for (let i = minYear; i <= maxYear; i++)
            this.years.push(i.toString());
        this.prop("selectedDay").subscribe(() => this.tryCommit());
        this.prop("selectedMonth").subscribe(() => this.tryCommit());
        this.prop("selectedYear").subscribe(() => this.tryCommit());
    }
    /********************************************/
    tryCommit() {
        this.commitAsync();
    }
    /********************************************/
    commitAsync(force) {
        var _a, _b;
        if (((_a = this.editValue) === null || _a === void 0 ? void 0 : _a.getTime()) != ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getTime()))
            this.value = this.editValue;
        return Promise.resolve(true);
    }
    /********************************************/
    get editValue() {
        if (!this.selectedDay || !this.selectedMonth || !this.selectedYear)
            return null;
        return new Date(parseInt(this.selectedYear), parseInt(this.selectedMonth) - 1, parseInt(this.selectedDay));
    }
    /********************************************/
    set editValue(value) {
        var _a;
        if ((value === null || value === void 0 ? void 0 : value.getTime()) == ((_a = this.editValue) === null || _a === void 0 ? void 0 : _a.getTime()))
            return;
        if (!value) {
            this.selectedDay = null;
            this.selectedMonth = null;
            this.selectedYear = null;
        }
        else {
            this.selectedDay = (value.getDate()).toString();
            this.selectedMonth = (value.getMonth() + 1).toString();
            this.selectedYear = value.getFullYear().toString();
        }
    }
}
registerType(DateEditorCombo_DateEditorCombo, "DateEditorCombo");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/ItemEditorConverter.js



/****************************************/
class ItemEditorConverter extends BindableObject_BindableObject {
    constructor(config) {
        super();
        this.editor = null;
        this.bindConfig("editor", config);
        if (config) {
            if (config.itemToEdit)
                this.itemToEdit = config.itemToEdit;
            if (config.editToItem)
                this.editToItem = config.editToItem;
        }
    }
    /****************************************/
    activateAsync() {
        if (isActivable(this.editor))
            return this.editor.activateAsync();
        return Promise.resolve();
    }
    /****************************************/
    beginEditAsync(item) {
        this._item = item;
        return this.editor.beginEditAsync(this.itemToEdit(item));
    }
    /****************************************/
    async commitAsync(force) {
        if (await this.editor.commitAsync(force)) {
            this.editToItem(this._item, this.editor.value);
            return true;
        }
        return false;
    }
    /****************************************/
    itemToEdit(item) {
        throw "Not supported";
    }
    /****************************************/
    editToItem(item, editValue) {
    }
    /****************************************/
    get value() {
        return this.editor.value;
    }
    get view() {
        return this.editor;
    }
    get isValid() {
        return this.editor.isValid;
    }
}
registerType(ItemEditorConverter, "ItemEditorConverter");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/Interaction.js






/****************************************/
var Interaction;
(function (Interaction) {
    async function showMessageAsync(options) {
        var _a;
        const msgActions = (_a = options.actions) !== null && _a !== void 0 ? _a : (options.customActions ? [] : ["ok"]);
        const msgBox = new MessageBox_MessageBox({ message: options.message, icon: options.icon, title: options.title });
        msgActions.forEach(a => {
            msgBox.addAction({
                name: a,
                displayName: Helpers_Format/* Format.action */.E.action(a),
                executeAsync: () => Promise.resolve()
            });
        });
        if (options.customActions)
            options.customActions.forEach(a => msgBox.addAction(a));
        const result = await msgBox.showAsync();
        return result;
    }
    Interaction.showMessageAsync = showMessageAsync;
    /****************************************/
    async function confirmAsync(message) {
        const result = await showMessageAsync({
            message: message,
            title: "confirm",
            actions: ["yes", "no"]
        });
        return result == "yes";
    }
    Interaction.confirmAsync = confirmAsync;
    /****************************************/
    function info(message) {
        const toast = new Toast_Toast({ message: message });
        toast.showAsync();
    }
    Interaction.info = info;
    /****************************************/
    function warning(message) {
        const toast = new Toast_Toast({ message: message, styles: ["warning"] });
        toast.showAsync();
    }
    Interaction.warning = warning;
    /****************************************/
    function error(message) {
        const toast = new Toast_Toast({ message: message, styles: ["error"], icon: "fas fa-exclamation" });
        toast.showAsync();
    }
    Interaction.error = error;
    /****************************************/
    async function succeed(message) {
        const page = await Actions_Actions.loadPageAsync(new ContentActivity_ContentActivity({
            providers: [new MessageContent(Object.assign({ icon: "far fa-smile", customActions: [{
                            name: "close",
                            displayName: "close",
                            executeAsync: () => Promise.resolve(),
                        }] }, message))],
            name: "message"
        }));
        return await page.result;
    }
    Interaction.succeed = succeed;
    /****************************************/
    async function fail(message) {
        const page = await Actions_Actions.loadPageAsync(new ContentActivity_ContentActivity({
            providers: [new MessageContent(Object.assign({ icon: "far fa-sad-tear", customActions: [{
                            name: "close",
                            displayName: "close",
                            executeAsync: () => Promise.resolve(),
                        }] }, message))],
            name: "message"
        }));
        return await page.result;
    }
    Interaction.fail = fail;
})(Interaction || (Interaction = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Items/EditableItemsSource.js

/****************************************/
class EditableItemsSource_EditableItemsSource extends ItemsSource_ItemsSource {
    constructor(config) {
        super(config);
        if (config) {
            if (config.addItemAsync)
                this.addItemAsync = config.addItemAsync;
            if (config.updateItemAsync)
                this.updateItemAsync = config.updateItemAsync;
            if (config.removeItemAsync)
                this.removeItemAsync = config.removeItemAsync;
            if (config.newItem)
                this.newItem = config.newItem;
        }
    }
    /********************************************/
    newItem() {
        return {};
    }
    /********************************************/
    addItemAsync(item) {
        return Promise.resolve(item);
    }
    /********************************************/
    updateItemAsync(editItem, item) {
        return Promise.resolve(item);
    }
    /********************************************/
    removeItemAsync(item) {
        return Promise.resolve(true);
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/ItemsEditor.js


















/********************************************/
class ItemsEditorItemView extends ItemView_ItemView {
    constructor(config) {
        super(Object.assign({}, config));
        /********************************************/
        this.error = null;
        this.addTitle = null;
        this.editTitle = null;
        this.editor = null;
        this.view = null;
        this.value = null;
        this.status = "unchanged";
        this.editMode = "external";
        this.isEdit = false;
        if (config.canEdit) {
            this.addAction({
                name: "edit-item",
                icon: "fas fa-edit",
                operation: IOperation_OperationType.Local,
                priority: BindableObject_BindableObject.bindValue(config.editActionsPriority),
                displayName: config.editActionLabel,
                executeAsync: () => this.editAsync()
            });
        }
        if (config.canRemove) {
            this.addAction({
                name: "remove-item",
                icon: "fas fa-trash",
                operation: IOperation_OperationType.Local,
                priority: BindableObject_BindableObject.bindValue(config.editActionsPriority),
                displayName: config.removeActionLabel,
                executeAsync: () => this.removeAsync()
            });
        }
        if (config.itemActions) {
            config.itemActions.forEach(action => this.addAction({
                name: action.name,
                icon: action.icon,
                priority: action.priority,
                operation: action.operation,
                displayName: Helpers_Format/* Format.action */.E.action(action.displayName, config.itemsSource.displayName),
                canExecute: action.canExecute ? () => action.canExecute(this) : undefined,
                executeAsync: () => action.executeAsync(this)
            }));
        }
        this.value = config.value;
    }
    /********************************************/
    updateView() {
        this.content.clear();
        if (this.isEdit && this.editMode == "inline" && !isAsyncEditor(this.editor))
            this.content.add(this.editor.view);
        else
            this.content.add(this.view);
    }
    /********************************************/
    updateValueAsync() {
        throw "Not implemented";
    }
    /********************************************/
    createUpdateEditor() {
        throw "Not implemented";
    }
    /********************************************/
    createAddEditor() {
        throw "Not implemented";
    }
    /********************************************/
    executeUpdateAsync(item) {
        throw "Not implemented";
    }
    /********************************************/
    executeAddAsync(item) {
        throw "Not implemented";
    }
    /********************************************/
    async editAsync() {
        if (this.isEdit)
            return false;
        if (!this.editor) {
            if (this.status == "added")
                this.editor = this.createAddEditor();
            else
                this.editor = this.createUpdateEditor();
        }
        this.isEdit = true;
        if (this.editMode == "external") {
            let newItem = null;
            if (isAsyncEditor(this.editor)) {
                const editValue = await this.editor.editAsync(this.item);
                if (editValue) {
                    if (this.status == "added")
                        newItem = await this.executeAddAsync(editValue);
                    else
                        newItem = await this.executeUpdateAsync(editValue);
                }
            }
            else {
                const activity = new ContentActivity_ContentActivity({
                    providers: [new ItemEditContent({
                            editor: this.editor,
                            title: item => this.status == "added" ? this.addTitle : this.editTitle,
                            value: this.item,
                            saveItemAsync: item => this.status == "added" ? this.executeAddAsync(item) : this.executeUpdateAsync(item)
                        })]
                });
                newItem = await (await Actions_Actions.loadPageAsync(activity)).result;
            }
            if (newItem) {
                this.item = newItem;
                this.status = "unchanged";
                this.isEdit = false;
                await this.updateValueAsync();
            }
            else
                this.isEdit = false;
            this.editor = null;
            return newItem != null;
        }
        return false;
    }
    /********************************************/
    cancelEdit() {
        this.isEdit = false;
    }
    /********************************************/
    removeAsync() {
        throw "Not implemented";
    }
    /********************************************/
    clearErrors() {
        this.error = null;
    }
    /********************************************/
    async validateAsync(force) {
        if (this.isEdit) {
            if (isValidable(this.editor))
                return await this.editor.validateAsync();
        }
        else {
            if (isValidable(this.view))
                return await this.view.validateAsync();
        }
        return true;
    }
    /********************************************/
    async loadAsync() {
        this.updateView();
    }
    /********************************************/
    get itemsEditor() {
        return this.parentView;
    }
    ;
}
/********************************************/
class ItemsEditor_ItemsEditor extends BaseEditor {
    constructor(config) {
        var _a, _b, _c;
        super(Object.assign({ template: "ItemsEditor" }, config));
        this._changesCount = 0;
        this._isUpdating = 0;
        /********************************************/
        this.content = ObservableList_observableListOf();
        this.editActionsPriority = IAction_ActionPriority.Secondary;
        this.editActionLabel = "Edit";
        this.removeActionLabel = "Remove";
        this.canAdd = true;
        this.canRemove = true;
        this.canEdit = false;
        this.canOpen = false;
        this.editMode = "inline";
        this.itemActions = [];
        this.itemsSource = null;
        this.isConfirmRemove = true;
        this.bindConfig("editMode", config);
        this.bindConfig("canAdd", config);
        this.bindConfig("canOpen", config);
        this.bindConfig("canRemove", config);
        this.bindConfig("isConfirmRemove", config);
        this.bindConfig("canEdit", config);
        this.bindConfig("itemsSource", config);
        this.bindConfig("itemActions", config);
        this.bindConfig("editActionsPriority", config);
        this.bindConfig("removeActionLabel", config);
        this.bindConfig("editActionLabel", config);
        if (config) {
            if (!config.editActionLabel)
                this.editActionLabel = Helpers_Format/* Format.action */.E.action("edit-item", (_a = this.itemsSource) === null || _a === void 0 ? void 0 : _a.displayName);
            if (!config.removeActionLabel)
                this.removeActionLabel = Helpers_Format/* Format.action */.E.action("remove-item", (_b = this.itemsSource) === null || _b === void 0 ? void 0 : _b.displayName);
            if (config.createItemAddEditor)
                this.createItemAddEditor = config.createItemAddEditor;
            if (config.createItemUpdateEditor)
                this.createItemUpdateEditor = config.createItemUpdateEditor;
            if (config.createItemView)
                this.createItemView = config.createItemView;
            if (config.attachItem)
                this.attachItem = config.attachItem;
            if (config.newItem)
                this.newItem = config.newItem;
            if (config.openItem) {
                this.openItem = config.openItem;
                if (config.canOpen == undefined)
                    this.canOpen = true;
            }
        }
        if (!this.itemsSource)
            this.itemsSource = new EditableItemsSource_EditableItemsSource();
        this.addAction = ActionView_ActionView.fromAction({
            name: "add-item",
            icon: "fas fa-plus",
            operation: IOperation_OperationType.Local,
            displayName: (_c = config === null || config === void 0 ? void 0 : config.addActionLabel) !== null && _c !== void 0 ? _c : Helpers_Format/* Format.action */.E.action("add-item", this.itemsSource.displayName),
            executeAsync: async () => await this.addAsync()
        });
        if (this.value)
            this.beginEditAsync(this.value);
    }
    /********************************************/
    async loadAsyncWork() {
        const awaiters = [];
        for (const item of this.content)
            awaiters.push(item.loadAsync());
        await Promise.all(awaiters);
    }
    /********************************************/
    clear() {
        this.content.clear();
    }
    /********************************************/
    clearErrors() {
        for (const item of this.content)
            item.clearErrors();
    }
    /********************************************/
    insert() {
    }
    /********************************************/
    async addAsync() {
        const item = this.newItem();
        this.attachItem(item, true);
        const itemView = this.createItem(this.itemToValue(item), item);
        itemView.item = item;
        itemView.status = "added";
        if (await itemView.editAsync()) {
            if ((0,Linq/* linq */.k)(this.content).any(a => this.itemsSource.itemComparer(a.item, itemView.item)))
                return;
            this.content.add(itemView);
            await this.notifyEditValueChangedAsync();
        }
    }
    /********************************************/
    openItem(item) {
    }
    /********************************************/
    attachItem(item, isNew) {
    }
    /********************************************/
    isCapable(selector, item) {
        if (typeof selector == "boolean")
            return selector;
        return selector(item);
    }
    /********************************************/
    createItem(value, item) {
        const result = new ItemsEditorItemView({
            value: value,
            item: item,
            addTitle: Helpers_Format/* Format.title */.E.title("add-item", this.itemsSource.displayName),
            editTitle: "",
            itemsSource: this.itemsSource,
            editActionsPriority: this.editActionsPriority,
            editActionLabel: this.editActionLabel,
            removeActionLabel: this.removeActionLabel,
            itemActions: this.itemActions,
            canRemove: this.isCapable(this.canRemove, item),
            canEdit: this.isCapable(this.canEdit, item),
            canOpen: this.isCapable(this.canOpen, item),
            open: () => this.openItem(result.item)
        });
        result.parentView = this;
        result.isConfirmRemove = this.isConfirmRemove;
        result.createAddEditor = () => this.createItemAddEditor(result.item);
        result.createUpdateEditor = () => this.createItemUpdateEditor(result.item);
        result.executeAddAsync = item => this.itemsSource.addItemAsync(item);
        result.executeUpdateAsync = editItem => this.itemsSource.updateItemAsync(editItem, result.item);
        result.loadAsync = async () => {
            if (!result.item) {
                result.item = await this.valueToItemAsync(result.value);
                result.canOpen = this.isCapable(this.canOpen, result.item);
                result.editTitle = Helpers_Format/* Format.title */.E.title("edit-item", this.itemsSource.getItemText(result.item));
                this.attachItem(result.item, result.status != "added");
            }
            result.view = this.createItemView(result.item);
            result.updateView();
        };
        result.updateValueAsync = async () => {
            result.canOpen = this.isCapable(this.canOpen, result.item);
            result.value = this.itemToValue(result.item);
            result.view = this.createItemView(result.item);
            result.editTitle = Helpers_Format/* Format.title */.E.title("edit-item", this.itemsSource.getItemText(result.item));
            result.updateView();
            await this.notifyEditValueChangedAsync();
        };
        result.removeAsync = async () => {
            if (result.status == "added")
                this.content.remove(result);
            else {
                if (this.isConfirmRemove) {
                    if (!await Interaction.confirmAsync(Helpers_Format/* Format.message */.E.message("msg-remove-confirm", this.itemsSource.displayName)))
                        return;
                }
                if (this.status == "none")
                    this.status = "loaded";
                result.status = "removed";
                await this.notifyEditValueChangedAsync();
            }
        };
        result.value = value;
        if (this.status != "none")
            result.loadAsync();
        return result;
    }
    /********************************************/
    itemToValue(item) {
        return item;
    }
    /********************************************/
    valueToItemAsync(value) {
        return Promise.resolve(value);
    }
    /********************************************/
    onItemChanged(oldValue, newValue) {
        this._needValidation = true;
        if (this._isUpdating) {
            this._changesCount++;
            return;
        }
        this.notifyEditValueChangedAsync();
    }
    /********************************************/
    set editValue(value) {
        if (!this.content || this._isUpdating)
            return;
        this._isUpdating++;
        this._changesCount = 0;
        this.content.clear();
        try {
            if (value) {
                for (const itemValue of value)
                    this.content.add(this.createItem(itemValue));
            }
        }
        finally {
            this._isUpdating--;
        }
        if (this._changesCount > 0)
            this.notifyEditValueChangedAsync();
    }
    /********************************************/
    get editValue() {
        const result = [];
        for (const item of this.content) {
            if (item.status == "removed")
                continue;
            result.push(item.value);
        }
        return result;
    }
    /********************************************/
    async validateAsyncWork(force) {
        let isValid = true;
        for (const item of this.content) {
            if (!await item.validateAsync(force))
                isValid = false;
        }
        return isValid;
    }
    /********************************************/
    async commitAsyncWork(force) {
        let isValid = true;
        let isChanged = false;
        /*
        for (var item of this.content) {
            if (item.isEdit) {
                if (!await item.commitAsync())
                    isValid = false;
            }
        }
        */
        if (!isValid)
            return false;
        for (let i = this.content.count - 1; i >= 0; i--) {
            const item = this.content.get(i);
            item.clearErrors();
            if (item.status == "removed") {
                if (await this.itemsSource.removeItemAsync(item.item))
                    this.content.removeAt(i);
                else {
                    this.error = "";
                    isValid = false;
                }
                isChanged = true;
            }
            else if (item.status == "modified" && !isAsyncEditor(item.editor)) {
                const updateItem = await this.itemsSource.updateItemAsync(item.editor.value, item.item);
                if (updateItem) {
                    item.item = updateItem;
                    item.status = "unchanged";
                    item.updateView();
                }
                else {
                    this.error = "";
                    isValid = false;
                }
                isChanged = true;
            }
            else if (item.status == "added" && !isAsyncEditor(item.editor)) {
                const addItem = await this.itemsSource.addItemAsync(item.editor.value);
                if (addItem) {
                    item.item = addItem;
                    item.status = "unchanged";
                    item.updateView();
                }
                else {
                    this.error = "";
                    isValid = false;
                }
                isChanged = true;
            }
        }
        if (isValid) {
            if (isChanged)
                this.onValueChanged(this.editValue);
        }
        return isValid;
    }
    /********************************************/
    newItem() {
        return this.itemsSource.newItem();
    }
    /********************************************/
    getItemViewContent(item) {
        return this.itemsSource ? this.itemsSource.getItemText(item) : item.toString();
    }
    /********************************************/
    createItemView(item) {
        return new TextView_TextView({ content: this.getItemViewContent(item) });
    }
    /********************************************/
    createItemUpdateEditor(item) {
        throw "Not Supported";
    }
    /********************************************/
    createItemAddEditor(item) {
        throw "Not Supported";
    }
}
registerType(ItemsEditor_ItemsEditor, "ItemsEditor");
registerType(ItemsEditorItemView, "ItemsEditorItemView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/MediaEditor.js







/****************************************/
class MediaEditor_MediaEditor extends BaseEditor {
    constructor(config) {
        super(Object.assign({ template: "MediaEditor" }, config));
        /****************************************/
        this.fileUpload = null;
        this.mediaView = null;
        this.noMediaUrl = null;
        this.maxFileSize = null;
        this.validMedias = ["video", "image"];
        this.bindConfig("noMediaUrl", config);
        this.bindConfig("maxFileSize", config);
        this.bindConfig("validMedias", config);
        if (config) {
            if (config.getUploadUrl)
                this.getUploadUrl = config.getUploadUrl;
            if (config.getMediaUrl)
                this.getMediaUrl = () => config.getMediaUrl(this.editValue);
        }
        this.mediaView = new MediaView_MediaView(Object.assign({ image: { template: "ImageInline" }, video: { template: "VideoViewInline" } }, config === null || config === void 0 ? void 0 : config.mediaView));
        this.fileUpload = new FileUploadView_FileUploadView({
            onChanged: () => this.notifyEditValueChangedAsync()
        });
        this.fileUpload.visible = false;
        this.mediaView.content = {
            type: "empty"
        };
    }
    /********************************************/
    getUploadUrl(fileName) {
        throw "Not implemented";
    }
    /********************************************/
    validateAsyncWork(force) {
        if (this.fileUpload.status == "selected") {
            if (this.validMedias.indexOf("image") != -1 && this.fileUpload.file.type.startsWith("image/"))
                this.mediaView.content.type = "image";
            else if (this.validMedias.indexOf("video") != -1 && this.fileUpload.file.type.startsWith("video/"))
                this.mediaView.content.type = "video";
            else
                this.error = Helpers_Format/* Format.message */.E.message("msg-invalid-media");
            if (this.maxFileSize && this.fileUpload.file.size > this.maxFileSize)
                this.error = Helpers_Format/* Format.message */.E.message("msg-max-size", (this.maxFileSize / 1024 / 1024).toString());
        }
        return Promise.resolve(!this.error);
    }
    /********************************************/
    async commitAsyncWork(force) {
        if (this.fileUpload.status == "selected") {
            const result = await this.fileUpload.uploadAsync(this.getUploadUrl(this.fileUpload.file.name));
            this.editValue.id = result;
            this.editValue.status = "new";
            this.editValue.type = this.mediaView.content.type;
            this.mediaView.content = {
                src: this.getMediaUrl(),
                type: this.mediaView.content.type
            };
            this.notifyEditValueChangedAsync();
        }
        return true;
    }
    /********************************************/
    getMediaUrl() {
        throw "Not Implemented";
    }
    /********************************************/
    async beginEditAsync(value) {
        await super.beginEditAsync(value);
        if (!this.editValue)
            this.editValue = {
                id: null,
                type: "empty",
                status: "empty"
            };
        if (this.editValue.status == "empty")
            this.mediaView.content = {
                type: "image",
                src: this.noMediaUrl
            };
        else {
            this.mediaView.content = {
                type: this.editValue.type,
                src: this.getMediaUrl()
            };
        }
    }
    /****************************************/
    change() {
        this.fileUpload.visible = true;
        this.fileUpload.select();
    }
    /****************************************/
    remove() {
        this.editValue.status = "deleted";
        this.mediaView.content = {
            type: "image",
            src: this.noMediaUrl
        };
        this.notifyEditValueChangedAsync();
    }
    /****************************************/
    showMenu() {
        const menu = new ContextMenu_ContextMenu();
        if (this.editValue.status == "new" || this.editValue.id) {
            menu.addAction({
                name: "remove-item",
                icon: "fas fa-trash",
                displayName: "delete",
                executeAsync: async () => this.remove()
            });
        }
        menu.addAction({
            name: "edit-item",
            icon: "fas fa-edit",
            displayName: "change",
            executeAsync: async () => this.change()
        });
        menu.showAsync(undefined, window.event);
    }
}
registerType(MediaEditor_MediaEditor, "MediaEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/MultiItemPicker.js









/****************************************/
class MultiItemPicker_MultiItemPicker extends BasePicker {
    constructor(config) {
        super(config);
        /****************************************/
        this.selector = null;
        this.items = ObservableList_observableListOf();
    }
    /****************************************/
    async selectAsync() {
        let mustRefresh = false;
        if (this.selector == null) {
            this.selector = new SelectMultipleItemsActivity({
                createItemEditor: () => this.createItemEditor(),
                createItemContentView: item => this.createItemView(item),
                createItemListView: item => this.createItemListView(item),
                itemsSource: this.itemsSource,
                addLabel: this.addLabel,
                searchMode: this.searchMode,
                tooltip: this.pickLabel,
                canAdd: this.canAdd
            });
            this.selector.filters = this.filters;
        }
        else
            mustRefresh = true;
        this.selector.setSelectedItems((0,Linq/* linq */.k)(this.items).select(a => a.item).toArray());
        if (mustRefresh)
            await this.selector.refreshAsync();
        const result = await (await Actions_Actions.loadPageAsync(this.selector)).result;
        if (result != null) {
            const newValue = (0,Linq/* linq */.k)(result).select(a => this.itemsSource.getItemValue(a)).toArray();
            if (!equalsArray(newValue, this.editValue))
                this.editValue = newValue;
        }
    }
    /********************************************/
    valueToEdit(value) {
        return value ? value.slice() : [];
    }
    /********************************************/
    editToValue(value) {
        return value ? value.slice() : [];
    }
    /****************************************/
    async updateViewAsync() {
        if (this.status == "loading")
            return;
        this.items.clear();
        if (this.editValue) {
            this.status = "loading";
            try {
                for (const value of this.editValue) {
                    const item = await this.itemsSource.getItemByValueAsync(value);
                    if (!item)
                        continue;
                    const itemView = new RemovableItemView_RemovableItemView({
                        item: item,
                        content: this.createItemView(item),
                        removeAsync: async () => {
                            this.items.remove(itemView);
                            const value = this.itemsSource.getItemValue(itemView.item);
                            const index = (0,Linq/* linq */.k)(this.editValue).indexOf(a => this.itemsSource.equals(a, value));
                            this.editValue.splice(index, 1);
                            await this.notifyEditValueChangedAsync();
                        }
                    });
                    this.items.add(itemView);
                }
            }
            finally {
                this.status = "loaded";
            }
        }
    }
}
registerType(MultiItemPicker_MultiItemPicker, "MultiItemPicker");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/ObjectEditor.js




/********************************************/
class ObjectEditor extends BaseEditor {
    constructor(config) {
        super(Object.assign({ template: "ItemsViewForm", validationMode: "always", commitMode: "manual" }, config));
        this._changesCount = 0;
        this._isUpdating = 0;
        /********************************************/
        this.properties = {};
        this.defaultProperty = null;
        this.propertyTemplateName = "PropertyView";
        this.emptyView = null;
        this.content = ObservableList_observableListOf();
        this.bindConfig("propertyTemplateName", config);
        this.bindConfig("defaultProperty", config);
        this.bindConfig("emptyView", config);
        this.prop("content");
        if (config) {
            this._onPropertyChanged = config.onPropertyChanged;
            if (config.properties) {
                for (const propName in config.properties) {
                    config.properties[propName].name = propName;
                    this.addProperty(config.properties[propName]);
                }
            }
        }
        this.createProxy();
        if (!isEmpty(this.value))
            this.beginEditAsync(this.value);
    }
    /********************************************/
    addProperty(config) {
        const item = new PropertyView_PropertyView(Object.assign(Object.assign({ name: config.name, template: this.prop("propertyTemplateName") }, config), { host: this }));
        this.properties[config.name] = item;
        return item;
    }
    /********************************************/
    async beginEditWorkAsync(value) {
        if (!this.value)
            this.value = {};
        this.isDirty = true;
        for (const propName in this.properties) {
            const prop = this.properties[propName];
            if (prop.value != undefined)
                await prop.editor.beginEditAsync(prop.value);
        }
    }
    /********************************************/
    clearErrors() {
        for (const propName in this.properties)
            this.properties[propName].error = null;
    }
    /********************************************/
    async validateAsyncWork(force) {
        let isValid = true;
        const curValue = this.editValue;
        for (const propName in this.properties) {
            const prop = this.properties[propName];
            if (!await prop.validateAsync(curValue, force)) {
                this.isValid = false;
                isValid = false;
            }
        }
        return isValid;
    }
    /********************************************/
    createProxy() {
        this._proxy = {};
        this.content.clear();
        for (const propName in this.properties) {
            const curProp = this.properties[propName];
            curProp.prop("value").subscribe((value, oldValue) => this.onPropertyValueChanged(propName, value, oldValue));
            curProp.prop("isValid").subscribe(value => {
                if (!value)
                    this.isValid = false;
            });
            curProp.prop("isDirty").subscribe(value => {
                if (value)
                    this.isDirty = true;
            });
            this.content.add(curProp);
            Object.defineProperty(this._proxy, propName, {
                enumerable: true,
                get: () => curProp.value,
                set: value => curProp.value = value
            });
        }
    }
    /********************************************/
    activateAsync() {
        if (this.defaultProperty)
            return this.editor(this.defaultProperty).activateAsync();
        return Promise.resolve();
    }
    /********************************************/
    async loadAsyncWork() {
        const awaiters = [];
        for (const propName in this.properties)
            awaiters.push(this.properties[propName].loadAsync());
        await Promise.all(awaiters);
    }
    /********************************************/
    clear() {
        this._isUpdating++;
        try {
            for (const propName in this.properties)
                this.property(propName).clear();
        }
        finally {
            this._isUpdating--;
        }
    }
    /********************************************/
    editToValue(value) {
        return undefined;
    }
    /********************************************/
    async commitAsyncWork(force) {
        let isChanged = false;
        let isValid = true;
        if (!this.value)
            this.value = {};
        for (const propName in this.properties) {
            const commitResult = await this.commitPropertyAsync(propName, false);
            if (!commitResult.isValid)
                isValid = false;
            if (!commitResult.isChanged)
                isChanged = true;
        }
        if (isValid) {
            if (isChanged)
                this.onValueChanged(this.value);
        }
        return isValid;
    }
    /********************************************/
    async commitPropertyAsync(propName, validate) {
        const result = {
            isValid: true,
            isChanged: false
        };
        const prop = this.property(propName);
        if (validate && !await prop.validateAsync(this.editValue, false))
            result.isValid = false;
        else if (!await prop.editor.commitAsync())
            result.isValid = false;
        else {
            if (!equals(prop.value, this.value[propName])) {
                this.value[propName] = prop.value;
                result.isChanged = true;
            }
        }
        return result;
    }
    /********************************************/
    editor(propName) {
        return this.properties[propName].editor;
    }
    /********************************************/
    property(propName) {
        return this.properties[propName];
    }
    /********************************************/
    async onPropertyValueChanged(propName, value, oldValue) {
        this._needValidation = true;
        if (this._isUpdating || this._isEditing) {
            this._changesCount++;
            return;
        }
        if (this.commitMode == "onchange") {
            const commitResult = await this.commitPropertyAsync(propName, true);
            if (commitResult.isChanged) {
                this._needValidation = true;
                this.isDirty = true;
            }
        }
        else
            await this.notifyEditValueChangedAsync();
        if (this._onPropertyChanged)
            this._onPropertyChanged(propName, value, oldValue, this._proxy);
    }
    /********************************************/
    set editValue(value) {
        if (this._isUpdating)
            return;
        this._isUpdating++;
        this._changesCount = 0;
        try {
            if (isEmpty(value))
                this.clear();
            else {
                for (const propName in this.properties)
                    this._proxy[propName] = value[propName];
            }
        }
        finally {
            this._isUpdating--;
        }
        if (this._changesCount > 0)
            this.notifyEditValueChangedAsync();
    }
    /********************************************/
    get editValue() {
        return this._proxy;
    }
}
registerType(ObjectEditor, "ObjectEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/RichTextEditor.js



/****************************************/
class RichTextEditor extends BaseTextEditor {
    constructor(config) {
        super(Object.assign({ template: "Attach" }, config));
    }
    /****************************************/
    attach(element) {
        this.editor = new Quill(element, {
            theme: "snow",
        });
        this.editor.root.innerHTML = this.value;
        this.editor.on("text-change", () => this.notifyEditValueChangedAsync());
    }
    /****************************************/
    set editValue(value) {
        if (this.editor)
            this.editor.root.innerHTML = value;
    }
    get editValue() {
        if (this.editor)
            return this.editor.root.innerHTML;
        return this.value;
    }
}
registerType(RichTextEditor, "RichTextEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/SectionEditor.js







/********************************************/
class SectionEditorView extends ViewComponent {
    constructor(config) {
        super(config);
        /********************************************/
        this.title = null;
        this.bindConfig("editor", config);
        this.bindConfigString("title", config);
    }
}
/********************************************/
class SectionEditor_SectionEditor extends BaseEditor {
    constructor(config) {
        super(Object.assign({ template: "SectionEditor" }, config));
        /********************************************/
        this.sections = ObservableList_observableListOf();
        this.activeSectionName = null;
        this.navBar = new NavBar_NavBar({
            styles: ["tab-view", "surface"],
            itemTemplate: "TextView",
            itemBehavoirs: ["ripple"],
            selectedItem: this.prop("activeSectionName")
        });
        if (config) {
            if (config.sections)
                config.sections.forEach(a => this.addSection(a));
        }
        if (this.sections.count > 0)
            this.activeSectionName = this.sections.get(0).name;
        this.createEditValueProp();
    }
    /********************************************/
    async loadAsyncWork() {
        for (const section of this.sections) {
            if (section.editor)
                await section.editor.loadAsync();
        }
    }
    /********************************************/
    async beginEditWorkAsync(value) {
        for (const section of this.sections) {
            if (section.editor)
                await section.editor.beginEditAsync(value);
        }
    }
    /********************************************/
    async validateAsyncWork(force) {
        let isValid = true;
        for (const section of this.sections) {
            if (section.editor)
                if (!await section.editor.validateAsync(force)) {
                    isValid = false;
                    this.activeSectionName = section.name;
                }
        }
        return isValid;
    }
    /********************************************/
    async commitAsyncWork(force) {
        let isValid = true;
        for (const section of this.sections) {
            if (section.editor)
                if (!await section.editor.commitAsync(force))
                    isValid = false;
        }
        return isValid;
    }
    /********************************************/
    getSection(name) {
        return (0,Linq/* linq */.k)(this.sections).first(a => a.name == name);
    }
    /********************************************/
    addSection(config) {
        const item = new SectionEditorView(config);
        this.sections.add(item);
        this.navBar.addItem({
            text: item.prop("title"),
            name: item.name,
            content: item
        });
        return item;
    }
}
registerType(SectionEditorView, "SectionEditorView");
registerType(SectionEditor_SectionEditor, "SectionEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/SingleItemPicker.js






/****************************************/
class SingleItemPicker_SingleItemPicker extends BasePicker {
    constructor(config) {
        super(config);
        /****************************************/
        this.selector = null;
        this.contentView = null;
        this.clearAction = null;
        this.clearAction = ActionView_ActionView.fromActionIcon({
            name: "clear",
            icon: "fas fa-times",
            displayName: "clear",
            executeAsync: () => Promise.resolve(this.clear())
        });
    }
    /****************************************/
    async selectAsync() {
        let mustRefresh = false;
        if (this.selector == null) {
            this.selector = new SelectSingleItemActivity({
                itemsSource: this.itemsSource,
                createItemEditor: () => this.createItemEditor(),
                createItemContentView: item => this.createItemListView(item),
                pageSize: this.pageSize,
                addLabel: this.addLabel,
                tooltip: this.pickLabel,
                canAdd: this.canAdd
            });
            this.selector.filters = this.filters;
        }
        else
            mustRefresh = true;
        this.selector.selectedValue = this.editValue;
        if (mustRefresh)
            await this.selector.refreshAsync();
        const result = await (await Actions_Actions.loadPageAsync(this.selector)).result;
        if (result != null)
            this.editValue = this.itemsSource.getItemValue(result);
    }
    /****************************************/
    createItemEditor() {
        throw "Not Supported";
    }
    /****************************************/
    async updateViewAsync() {
        if (this.status == "loading")
            return;
        if (this.editValue) {
            this.status = "loading";
            try {
                const item = await this.itemsSource.getItemByValueAsync(this.editValue);
                this.contentView = this.createItemView(item);
            }
            finally {
                this.status = "loaded";
            }
        }
        else
            this.contentView = null;
    }
}
registerType(SingleItemPicker_SingleItemPicker, "SingleItemPicker");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/MultiItemSelector.js








/****************************************/
class MultiItemSelector extends BaseEditor {
    constructor(config) {
        super(Object.assign({ template: "SelectEditor" }, config));
        /****************************************/
        this.itemTemplate = "SelectableItemView";
        this.placeholder = null;
        this.itemsSource = null;
        this.items = ObservableList_observableListOf();
        this.bindConfig("itemsSource", config);
        this.bindConfig("itemTemplate", config);
        this.bindConfigString("placeholder", config);
        if (config === null || config === void 0 ? void 0 : config.createItemView)
            this.createItemViewWork = config === null || config === void 0 ? void 0 : config.createItemView;
        if (config === null || config === void 0 ? void 0 : config.items) {
            config.items.forEach(a => this.items.add(this.createItemView(a)));
            this.status = "loaded";
        }
    }
    /********************************************/
    async selectAsync() {
        const editor = new PopupEditor_PopUpEditor({
            editor: new MultiItemSelector({
                template: "MultiItemSelectorList",
                itemsSource: this.itemsSource,
                styles: ["no-padding-items-h"]
            }),
            saveOnCommit: true,
            saveLabel: "select",
            closeLabel: "cancel",
            title: "select-an-item",
            styles: [""]
        });
        const result = await editor.editAsync(this.value);
        if (result !== null)
            this.editValue = result;
    }
    /********************************************/
    findItemByValue(value) {
        if (this.itemsSource)
            return (0,Linq/* linq */.k)(this.items).first(a => this.itemsSource.equals(a.item, value));
        return (0,Linq/* linq */.k)(this.items).first(a => a.item == value);
    }
    /********************************************/
    set editValue(value) {
        for (const item of this.items) {
            item.isSelected = value && (0,Linq/* linq */.k)(value).any(a => Item.getValue(a) == Item.getValue(item.item));
        }
    }
    get editValue() {
        return (0,Linq/* linq */.k)(this.items).where(a => a.isSelected).select(a => a.item).toArray();
    }
    /****************************************/
    async loadAsyncWork() {
        if (this.itemsSource) {
            this.items.clear();
            const items = await this.itemsSource.getItemsAsync(this.itemsSource.getFilter());
            if (items)
                items.forEach(a => this.items.add(this.createItemView(a)));
        }
        this.isDirty = true;
    }
    /****************************************/
    createItemViewWork(item) {
        if (this.itemsSource)
            return new SelectableItemView_SelectableItemView({
                item: this.itemsSource.getItemValue(item),
                content: this.itemsSource.getItemText(item),
                template: this.itemTemplate
            });
    }
    /****************************************/
    createItemView(item) {
        const itemView = this.createItemViewWork(item);
        itemView.prop("isSelected").subscribe(value => {
            if (value)
                this.notifyEditValueChangedAsync();
        });
        return itemView;
    }
}
registerType(MultiItemSelector, "MultiItemSelector");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/TextEditor.js




/********************************************/
class TextEditor_TextEditor extends BaseTextEditor {
    constructor(config) {
        super(Object.assign({ template: "TextEditor" }, config));
        /********************************************/
        this.placeholder = null;
        this.lineCount = 1;
        this.maxLength = null;
        this.bindConfigString("placeholder", config, DynamicString/* StringUsage.Tooltip */.Fq.Tooltip);
        this.bindConfig("lineCount", config);
        this.bindConfig("maxLength", config);
        this.bindConfig("trackMode", config);
        this.createEditValueProp();
    }
}
registerType(TextEditor_TextEditor, "TextEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Editors/TimeEditor.js



/********************************************/
class TimeEditor extends BaseTextEditor {
    constructor(config) {
        super(Object.assign({ template: "TimeEditor" }, config));
        /********************************************/
        this.placeholder = null;
        this.bindConfig("placeholder", config);
        this.createEditValueProp();
    }
    /********************************************/
    valueToEdit(value) {
        return value === null || value === undefined ? "" : value.format("{hh}:{mm}");
    }
    /********************************************/
    editToValue(value) {
        if (value === undefined || value === null)
            return null;
        const parts = value.split(':');
        if (parts.length != 2)
            return null;
        return TimeSpan_TimeSpan.fromMinutes(parseInt(parts[0]) * 60 + parseInt(parts[1]));
    }
}
registerType(TimeEditor, "TimeEditor");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/Components.js

var Components;
(function (Components) {
    function sections(config) {
        return new SectionsView_SectionsView(config);
    }
    Components.sections = sections;
})(Components || (Components = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/Decorators.js
function observable() {
    return function (target, propertyKey) {
    };
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/Editors.js









var Editors;
(function (Editors) {
    function richText() {
        return new RichTextEditor();
    }
    Editors.richText = richText;
    /****************************************/
    function currency() {
        return new NumberEditor({
            allowNull: false,
            min: 0.01,
        });
    }
    Editors.currency = currency;
    /****************************************/
    function converter(editor, itemToEdit, editToItem) {
        return new ItemEditorConverter({
            editor: editor,
            editToItem: editToItem,
            itemToEdit: itemToEdit
        });
    }
    Editors.converter = converter;
    /****************************************/
    function items(config) {
        return new ItemsEditor_ItemsEditor(Object.assign({}, config));
    }
    Editors.items = items;
    /****************************************/
    function text(config) {
        return new TextEditor_TextEditor(Object.assign({}, config));
    }
    Editors.text = text;
    /****************************************/
    function textMultiLine(config) {
        return new TextEditor_TextEditor(Object.assign({ template: "TextEditorMultiLine" }, config));
    }
    Editors.textMultiLine = textMultiLine;
    /****************************************/
    function number(config) {
        return new NumberEditor(Object.assign({}, config));
    }
    Editors.number = number;
    /****************************************/
    function boolean(config) {
        return new BooleanEditor_BooleanEditor(Object.assign({}, config));
    }
    Editors.boolean = boolean;
    /****************************************/
    function password(config) {
        return new TextEditor_TextEditor(Object.assign({ template: "PasswordEditor" }, config));
    }
    Editors.password = password;
    /****************************************/
    function object(config) {
        return new ObjectEditor(config);
    }
    Editors.object = object;
    /****************************************/
    function address(config) {
        return new TextEditor_TextEditor(Object.assign({ template: "TextEditorMultiLine" }, config));
    }
    Editors.address = address;
    /****************************************/
    function birthDate(minAge, config) {
        return new DateEditorCombo_DateEditorCombo({ maxYear: new Date().getFullYear() - (minAge !== null && minAge !== void 0 ? minAge : 0), minYear: new Date().getFullYear() - 100 });
    }
    Editors.birthDate = birthDate;
    /****************************************/
    function singleItemSelector(config) {
        return new SingleItemSelector_SingleItemSelector(config);
    }
    Editors.singleItemSelector = singleItemSelector;
})(Editors || (Editors = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/ItemsSources.js



function repositoryItems(repo, config) {
    return new ItemsSource_ItemsSource(Object.assign({ getItemsAsync: async (filter) => Array.from(await repo.listAsync(filter)), getItemByValueAsync: value => repo.getByIdAsync(value) }, config));
}
/****************************************/
function staticItems(items, allowZero = false) {
    return new ItemsSource_ItemsSource({
        typeName: "WebApp.ISimpleItem",
        getItemValue: a => a.value,
        getItemText: a => Helpers_Format/* Format.title */.E.title(a.text),
        getItemsAsync: () => Promise.resolve(items),
        getItemByValueAsync: value => Promise.resolve((0,Linq/* linq */.k)(items).first(a => a.value == value)),
        allowZero: allowZero
    });
}
/****************************************/
function arrayItems(items) {
    return new ItemsSource_ItemsSource({
        getItemsAsync: () => Promise.resolve(items)
    });
}
/****************************************/
function actionItems(items) {
    return new ItemsSource_ItemsSource({
        typeName: "WebApp.IAction",
        getItemText: a => Helpers_Format/* Format.text */.E.text(a.displayName),
        getItemsAsync: () => Promise.resolve(items),
        allowZero: false
    });
}

// EXTERNAL MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/Loaders.js
var Loaders = __webpack_require__(2501);
;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Helpers/Validators.js

var Validators;
(function (Validators) {
    const EMAIL_REGEXP = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    const PHONE_REGEXP = /^[+]*[(]{0,1}[0-9]{1,4}[)]{0,1}[-\s\./0-9]*$/;
    Validators.required = {
        validateAsync: ctx => Promise.resolve({
            isValid: ctx.value != null && ctx.value != "" && (!Array.isArray(ctx.value) || ctx.value.length > 0),
            error: Helpers_Format/* Format.message */.E.message("msg-specify-value", ctx.fieldName)
        })
    };
    /****************************************/
    function minValue(value) {
        return {
            validateAsync: ctx => Promise.resolve(({
                isValid: ctx.value >= value,
                error: Helpers_Format/* Format.message */.E.message("msg-insert-greater-than", value.toString())
            }))
        };
    }
    Validators.minValue = minValue;
    ;
    /****************************************/
    function maxValue(value) {
        return {
            validateAsync: ctx => Promise.resolve(({
                isValid: ctx.value <= value,
                error: Helpers_Format/* Format.message */.E.message("msg-insert-less-than", value.toString()),
            }))
        };
    }
    Validators.maxValue = maxValue;
    ;
    /****************************************/
    Validators.integer = {
        validateAsync: ctx => Promise.resolve(({
            isValid: Math.round(ctx.value) == ctx.value,
            error: Helpers_Format/* Format.message */.E.message("msg-insert-int-number"),
        }))
    };
    /****************************************/
    Validators.phone = {
        validateAsync: ctx => Promise.resolve(({
            isValid: ctx.value && ctx.value.length >= 9 && PHONE_REGEXP.test(ctx.value.toLowerCase()),
            error: Helpers_Format/* Format.message */.E.message("msg-invalid-phone", ctx.value)
        }))
    };
    /****************************************/
    Validators.email = {
        validateAsync: ctx => Promise.resolve(({
            isValid: ctx.value && EMAIL_REGEXP.test(ctx.value.toLowerCase()),
            error: Helpers_Format/* Format.message */.E.message("msg-invalid-email", ctx.value)
        }))
    };
    /****************************************/
    function custom(validator) {
        return {
            validateAsync: async (ctx) => await validator(ctx)
        };
    }
    Validators.custom = custom;
    ;
})(Validators || (Validators = {}));

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Items/CachedEditableItemsSource.js




/****************************************/
class CachedEditableItemsSource extends EditableItemsSource_EditableItemsSource {
    constructor(config) {
        super();
        /****************************************/
        this.source = null;
        this.cache = null;
        this.filter = null;
        if (config) {
            this.source = config.source;
            this.cache = config.cache;
            if (config.filterItem)
                this.filterItem = (filter, item) => config.filterItem(filter, item, this.items);
            if (config.finalize)
                this.finalize = config.finalize;
        }
        if (!this.cache)
            this.cache = {
                key: new Date().getTime().toString(),
                lastUpdateTime: null,
                value: null
            };
        if (!this.cache.updateComplete)
            this.cache.updateComplete = new Signal_Signal(true);
        if (!this.cache.value)
            this.cache.value = new Map();
        else if (this.cache.value.size > 0)
            this.cache.lastUpdateTime = new Date();
    }
    /****************************************/
    getItemText(item) {
        return this.source.getItemText(item);
    }
    /****************************************/
    getItemValue(item, bindItem) {
        return this.source.getItemValue(item, bindItem);
    }
    /****************************************/
    getFilter(text, offset, pageSize) {
        return this.source.getFilter(text, offset, pageSize);
    }
    /****************************************/
    equals(a, b) {
        return this.source.equals(a, b);
    }
    /********************************************/
    newItem() {
        return this.source.newItem();
    }
    /****************************************/
    finalize(filter, items) {
    }
    /****************************************/
    async countAsync(filter) {
        return (0,Linq/* linq */.k)(this.items.entries()).select(a => a[1]).where(a => this.filterItem(filter, a)).count();
    }
    /****************************************/
    async getItemsAsync(filter) {
        await this.updateCacheAsync(false);
        const items = await (0,Linq/* linq */.k)(this.items.entries()).select(a => a[1]).where(a => this.filterItem(filter, a)).toArrayAsync(10);
        this.finalize(filter, items);
        return items;
    }
    /****************************************/
    async getItemByValueAsync(value) {
        await this.updateCacheAsync(false);
        if (value == null)
            return null;
        if (typeof value == "object" && typeof value["valueOf"] == "function")
            value = value["valueOf"]();
        return Promise.resolve(this.items.get(value));
    }
    /********************************************/
    async addItemAsync(item) {
        const newItem = await this.source.addItemAsync(item);
        if (newItem != null)
            this.items.set(this.getItemValue(newItem, false), newItem);
        return newItem;
    }
    /********************************************/
    async updateItemAsync(item) {
        const newItem = await this.source.updateItemAsync(item);
        if (newItem != null)
            this.items.set(this.getItemValue(newItem, false), newItem);
        return newItem;
    }
    /********************************************/
    async removeItemAsync(item) {
        const result = await this.source.removeItemAsync(item);
        if (result)
            this.items.delete(this.getItemValue(item, false));
        return result;
    }
    /****************************************/
    filterItem(filter, item) {
        return true;
    }
    /****************************************/
    async readCacheAsync() {
        if (this.cache.key)
            return await Global/* Services.dbStorage.getItem */.K9.dbStorage.getItem(this.cache.key);
    }
    /****************************************/
    async writeCacheAsync(items) {
        if (this.cache.key)
            await Global/* Services.dbStorage.setItem */.K9.dbStorage.setItem(this.cache.key, items);
    }
    /****************************************/
    async updateCacheAsync(force) {
        if (this.cache.lastUpdateTime && !force)
            return;
        if (!this.cache.updateComplete.isSet) {
            await this.cache.updateComplete.waitFor();
            return;
        }
        this.cache.updateComplete.reset();
        try {
            let newItems;
            try {
                newItems = await this.source.getItemsAsync(this.filter);
            }
            catch (ex) {
                console.error(ex);
            }
            let mustUpdate = true;
            if (newItems == null) {
                newItems = await this.readCacheAsync();
                mustUpdate = false;
            }
            if (newItems != null) {
                this.items.clear();
                for (const item of newItems)
                    this.items.set(this.getItemValue(item, false), item);
                this.cache.lastUpdateTime = new Date();
                if (mustUpdate)
                    await this.writeCacheAsync(newItems);
            }
        }
        finally {
            this.cache.updateComplete.set();
        }
    }
    /****************************************/
    get typeName() {
        return this.source.typeName;
    }
    get allowZero() {
        return this.source.allowZero;
    }
    get itemComparer() {
        return this.source.itemComparer;
    }
    get items() {
        return this.cache.value;
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Services/AppContentManager.js

class AppContentManager {
    constructor(contents) {
        this.contents = contents;
    }
    /****************************************/
    get(name) {
        return (0,Linq/* linq */.k)(this.contents).first(a => a.name == name);
    }
    /****************************************/
    actionFor(name) {
        const content = this.get(name);
        return {
            executeAsync: content.openAsync,
            name: content.name,
            displayName: content.displayName,
            icon: content.icon
        };
    }
}

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/View/Services/PermissionManager.js










/****************************************/
class PermissionManager_PermissionRequestItemView extends ViewComponent {
    constructor(request) {
        super();
        /****************************************/
        this.request = null;
        this.switchView = null;
        this.isShowInfo = false;
        this.request = request;
        this.switchView = new BooleanEditor_BooleanEditor({
            label: this.request.permission.name,
            template: "Switch",
            styles: ["primary"]
        });
        this.switchView.beginEditAsync(request.granted);
    }
}
/****************************************/
class PermissionEditor extends BindableObject_BindableObject {
    constructor() {
        super(...arguments);
        this._listView = null;
        /****************************************/
        this.view = null;
        this.value = null;
        this.isValid = true;
    }
    beginEditAsync(item) {
        const panel = new Panel_Panel({
            styles: ["vertical"]
        });
        this._listView = panel.addView(new ListView_ListView({
            styles: ["surface"],
            items: ObservableList_observableListOf(item),
            isAutoLoad: true,
            createItemView: item => new PermissionManager_PermissionRequestItemView(item)
        }));
        panel.addView(new IconTextView_IconTextView({ text: "msg-permission-request", styles: ["message warning"] }));
        this.view = panel;
        this.value = item;
        return Promise.resolve();
    }
    /****************************************/
    commitAsync(force) {
        for (const item of this._listView.content)
            item.request.granted = item.switchView.editValue;
        return Promise.resolve(true);
    }
}
/****************************************/
class PermissionManager {
    constructor() {
        /****************************************/
        this.geolocation = {
            name: "geolocation",
            ask: () => new Promise(res => {
                function setResult(result) {
                    localStorage.setItem("geolocation", result ? "granted" : "denied");
                    res(result);
                }
                navigator.geolocation.getCurrentPosition(() => setResult(true), error => setResult(error.code != error.PERMISSION_DENIED), { maximumAge: Infinity, timeout: 2000 });
            }),
            isGranted: async () => {
                if ("permissions" in navigator)
                    return (await navigator.permissions.query({ name: "geolocation" })).state == "granted";
                return localStorage.getItem("geolocation") == "granted";
            }
        };
        /****************************************/
        this.notification = {
            name: "notification",
            ask: () => new Promise(res => {
                if (!("Notification" in window)) {
                    console.warn("Notification not supported");
                    res(false);
                }
                Notification.requestPermission(p => {
                    res(p == "granted");
                });
            }),
            isGranted: () => Promise.resolve(!("Notification" in window) ? true : Notification.permission == "granted")
        };
    }
    /****************************************/
    async requireAsync(...permissions) {
        const toAsk = [];
        const result = {};
        for (const perm of permissions) {
            if (!(await perm.permission.isGranted()))
                toAsk.push(perm);
            else {
                result[perm.permission.name] = true;
                perm.granted = true;
            }
        }
        if (toAsk.length > 0) {
            const editor = new PopupEditor_PopUpEditor({
                editor: new PermissionEditor(),
                saveLabel: "accept",
                savePriority: IAction_ActionPriority.Evidence,
                title: "permission-request",
            });
            const editResult = await editor.editAsync(toAsk);
            if (editResult) {
                for (const item of editResult) {
                    if (item.granted)
                        item.granted = await item.permission.ask();
                    result[item.permission.name] = item.granted;
                }
            }
        }
        return result;
    }
}
registerType(PermissionManager_PermissionRequestItemView, "PermissionRequestItemView");

;// CONCATENATED MODULE: ../../Eusoft/WebApp/src/Eusoft.WebApp/obj/js/index.js
/**
 * @file Automatically generated by barrelsby.
 */






































































































































































































































;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/WebApp.js


;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Application.js

class GeoPlotApplication {
    handleError(source, error, message) {
    }
    runAsync(args) {
        Global/* Services.httpClient */.K9.httpClient = new XHRHttpClient_XHRHttpClient();
        this.baseUrl = args.baseUrl;
        return Promise.resolve();
    }
    startupArgs;
    appName;
    baseUrl;
    isDev;
    language;
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Api.js

var Api;
(function (Api) {
    async function saveState(id, state) {
        let result = await Http/* Http.postJsonAsync */.e.postJsonAsync("~/SaveState/" + id, state);
        if (!result.isSuccess)
            throw result.error;
        return result.data;
    }
    Api.saveState = saveState;
    /****************************************/
    async function loadState(id) {
        let result = await Http/* Http.getJsonAsync */.e.getJsonAsync("~/LoadState/" + id);
        if (!result.isSuccess)
            throw result.error;
        return result.data;
    }
    Api.loadState = loadState;
    /****************************************/
    async function loadStudioData() {
        return await Http/* Http.getJsonAsync */.e.getJsonAsync("~/StudioData");
    }
    Api.loadStudioData = loadStudioData;
})(Api || (Api = {}));

// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/StringTable.js
var Scripts_Core_StringTable = __webpack_require__(168);
// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Types/DynamicString.js
var Types_DynamicString = __webpack_require__(3163);
;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Language/IT.js


Scripts_Core_StringTable/* StringTable.add */.M.add({
    "msg-upgrading": "aggiornamento alla nuova versione",
    "confirm": "conferma",
    "yes": "si",
    "no": "no",
    "close": "chiudi",
    "day-label": "[Giorno]",
    "month-label": "[Mese]",
    "year-label": "[Anno]",
    "msg-specify-value": Types_DynamicString/* DynamicString.complex */.wI.complex("specificare un valore per '{0}'"),
    "msg-insert-greater-than": Types_DynamicString/* DynamicString.complex */.wI.complex("inserire un valore maggiore o uguale a {0}"),
    "msg-invalid-email": "email non valida",
    "msg-insert-less-than": Types_DynamicString/* DynamicString.complex */.wI.complex("inserire un valore minore o uguale a {0}"),
}, { language: "IT" });

// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Global.js
var Core_Global = __webpack_require__(1923);
// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Linq.js
var Core_Linq = __webpack_require__(81);
;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Abstraction/IOperation.js
var Abstraction_IOperation_OperationType;
(function (OperationType) {
    OperationType[OperationType["Global"] = 0] = "Global";
    OperationType[OperationType["Local"] = 1] = "Local";
})(Abstraction_IOperation_OperationType || (Abstraction_IOperation_OperationType = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Abstraction/IOperationManager.js

async function IOperationManager_execAsync(action, operation = "Executing") {
    const op = Services.operation.begin(operation);
    try {
        return await action(op);
    }
    catch (ex) {
        Services.application.handleError(action, ex);
    }
    finally {
        op.end();
    }
}

// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Helpers/Format.js
var Core_Helpers_Format = __webpack_require__(1691);
// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Helpers/Http.js
var Helpers_Http = __webpack_require__(6615);
// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Helpers/Uri.js
var Core_Helpers_Uri = __webpack_require__(7985);
;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Utils/StringUtils.js
function Utils_StringUtils_randomString(length, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") {
    let result = "";
    for (let i = 0; i < length; i++)
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    return result;
}
/****************************************/
function StringUtils_isUpperCase(value) {
    return value.toUpperCase() === value;
}
/****************************************/
function StringUtils_repeatString(value, count) {
    let result = "";
    for (let i = 0; i < count; i++)
        result += value;
    return result;
}
/****************************************/
function StringUtils_padLeft(value, count, char) {
    if (value == null)
        return;
    if (value.length >= count)
        return value;
    return StringUtils_repeatString(char, count - value.length) + value;
}
/****************************************/
function StringUtils_padRight(value, count, char) {
    if (value == null)
        return;
    if (value.length >= count)
        return value;
    return value + StringUtils_repeatString(char, count - value.length);
}
/****************************************/
function StringUtils_uuidv4() {
    if ("crypto" in window && "randomUUID" in crypto)
        return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Types/TimeSpan.js


var TimeSpan_TimePart;
(function (TimePart) {
    TimePart[TimePart["Milliseconds"] = 0] = "Milliseconds";
    TimePart[TimePart["Seconds"] = 1] = "Seconds";
    TimePart[TimePart["Minutes"] = 2] = "Minutes";
    TimePart[TimePart["Hours"] = 3] = "Hours";
    TimePart[TimePart["Days"] = 4] = "Days";
})(TimeSpan_TimePart || (TimeSpan_TimePart = {}));
class Types_TimeSpan_TimeSpan {
    constructor(ticks = 0) {
        this.ticks = ticks;
    }
    /****************************************/
    get totalDays() {
        return this.ticks / (1000 * 60 * 60 * 24);
    }
    /****************************************/
    get totalHours() {
        return this.ticks / (1000 * 60 * 60);
    }
    /****************************************/
    get totalMinutes() {
        return this.ticks / (1000 * 60);
    }
    /****************************************/
    get totalSeconds() {
        return this.ticks / (1000);
    }
    /****************************************/
    get totalMilliseconds() {
        return this.ticks;
    }
    /****************************************/
    get days() {
        return Math.floor(this.ticks / (1000 * 60 * 60 * 24));
    }
    /****************************************/
    get hours() {
        return Math.floor(this.ticks / (1000 * 60 * 60)) % 24;
    }
    /****************************************/
    get minutes() {
        return Math.floor(this.ticks / (1000 * 60)) % 60;
    }
    /****************************************/
    get seconds() {
        return Math.floor(this.ticks / (1000)) % 60;
    }
    /****************************************/
    get milliseconds() {
        return this.ticks % 1000;
    }
    /****************************************/
    format(format) {
        return Core_Helpers_Format/* Format.replaceArgs */.E.replaceArgs(format, arg => Types_TimeSpan_TimeSpan.formatArgument(this, arg));
    }
    /****************************************/
    toString() {
        return this.format("{hh}:{mm}:{ss}");
    }
    /****************************************/
    static zero() {
        return new Types_TimeSpan_TimeSpan(0);
    }
    /****************************************/
    static fromMilliseconds(value) {
        return new Types_TimeSpan_TimeSpan(value);
    }
    /****************************************/
    static fromSeconds(value) {
        return new Types_TimeSpan_TimeSpan(value * 1000);
    }
    /****************************************/
    static fromMinutes(value) {
        return new Types_TimeSpan_TimeSpan(value * 1000 * 60);
    }
    /****************************************/
    static fromHours(value) {
        return new Types_TimeSpan_TimeSpan(value * 1000 * 60 * 60);
    }
    /****************************************/
    static fromDays(value) {
        return new Types_TimeSpan_TimeSpan(value * 1000 * 60 * 60 * 24);
    }
    /****************************************/
    static create(days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0) {
        return new Types_TimeSpan_TimeSpan((days * 1000 * 60 * 60 * 24) +
            (hours * 1000 * 60 * 60) +
            (minutes * 1000 * 60) +
            (seconds * 1000) +
            (milliseconds));
    }
    /****************************************/
    static formatArgument(value, arg) {
        switch (arg) {
            case "d":
                return value.days.toString();
            case "dd":
                return StringUtils_padLeft(value.days.toString(), 2, "0");
            case "h":
                return value.hours.toString();
            case "hh":
                return StringUtils_padLeft(value.hours.toString(), 2, "0");
            case "m":
                return value.minutes.toString();
            case "mm":
                return StringUtils_padLeft(value.minutes.toString(), 2, "0");
            case "s":
                return value.seconds.toString();
            case "ss":
                return StringUtils_padLeft(value.seconds.toString(), 2, "0");
            case "f":
                return (value.milliseconds / 100).toString();
            case "ff":
                return (value.milliseconds / 10).toString();
            case "fff":
                return value.milliseconds.toString();
        }
        return arg;
    }
    /****************************************/
    ticks;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Utils/DateUtils.js



const DateUtils_WEEK_DAYS = ["Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato", "Domenica"];
const DateUtils_MONTHS = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"];
/****************************************/
function DateUtils_parseDate(value) {
    if (value instanceof Date)
        return value;
    return new Date(value);
}
/****************************************/
function DateUtils_addDays(date, value) {
    return DateUtils_dateAdd(date, TimeSpan.fromDays(value));
}
/****************************************/
function DateUtils_dateAdd(date, value) {
    date = DateUtils_parseDate(date);
    return new Date(date.getTime() + value.ticks);
}
/****************************************/
function DateUtils_dateDiff(date1, date2) {
    return new TimeSpan(DateUtils_parseDate(date1).getTime() - DateUtils_parseDate(date2).getTime());
}
/****************************************/
function Utils_DateUtils_now() {
    return new Date();
}
/****************************************/
function DateUtils_isSameDay(dateA, dateB) {
    return DateUtils_truncateTime(dateA).getTime() == DateUtils_truncateTime(dateB).getTime();
}
/****************************************/
function DateUtils_today() {
    return DateUtils_truncateTime(Utils_DateUtils_now());
}
/****************************************/
function DateUtils_truncateTime(date) {
    date = DateUtils_parseDate(date);
    return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}
/****************************************/
function DateUtils_timeOfDay(date) {
    date = DateUtils_parseDate(date);
    return new TimeSpan(date.getTime() - DateUtils_truncateTime(date).getTime());
}
/****************************************/
function DateUtils_formatDate(date, format) {
    date = DateUtils_parseDate(date);
    return Core_Helpers_Format/* Format.replaceArgs */.E.replaceArgs(Core_Helpers_Format/* Format.text */.E.text(format), arg => DateUtils_formatDateArgument(date, arg));
}
/****************************************/
function DateUtils_formatDateArgument(value, arg) {
    value = DateUtils_parseDate(value);
    switch (arg) {
        case "D":
            return value.getDate().toString();
        case "DD":
            return StringUtils_padLeft(value.getDate().toString(), 2, "0");
        case "W":
            return DateUtils_WEEK_DAYS[(value.getDay() + 6) % 7].substr(0, 3);
        case "WW":
            return DateUtils_WEEK_DAYS[(value.getDay() + 6) % 7];
        case "M":
            return value.getMonth().toString();
        case "MM":
            return StringUtils_padLeft((value.getMonth() + 1).toString(), 2, "0");
        case "MMM":
            return DateUtils_MONTHS[value.getMonth()].substr(0, 3);
        case "MMMM":
            return DateUtils_MONTHS[value.getMonth()];
        case "YY":
            return value.getFullYear().toString().substr(2);
        case "YYYY":
            return value.getFullYear().toString();
        case "h":
            return value.getHours().toString();
        case "hh":
            return StringUtils_padLeft(value.getHours().toString(), 2, "0");
        case "m":
            return value.getMinutes().toString();
        case "mm":
            return StringUtils_padLeft(value.getMinutes().toString(), 2, "0");
        case "s":
            return value.getSeconds().toString();
        case "ss":
            return StringUtils_padLeft(value.getSeconds().toString(), 2, "0");
        case "f":
            return (value.getMilliseconds() / 100).toString();
        case "ff":
            return (value.getMilliseconds() / 10).toString();
        case "fff":
            return value.getMilliseconds().toString();
    }
    return arg;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Services/LocalStorageCache.js

class Services_LocalStorageCache_LocalStorageCache {
    read(key) {
        const entryJson = localStorage.getItem("cache:" + key);
        if (entryJson) {
            const entry = JSON.parse(entryJson);
            entry.readCount++;
            entry.lastReadTime = now();
            localStorage.setItem("cache:" + key, JSON.stringify(entry));
            return entry;
        }
        return null;
    }
    /****************************************/
    update(key, value) {
        let entry = this.read(key);
        if (!entry) {
            entry = {
                creationTime: now(),
                key: key,
                lastReadTime: null,
                lastWriteTime: null,
                value: value,
                readCount: 0,
                writeCount: 0
            };
        }
        else {
            entry.writeCount++;
            entry.lastWriteTime = now();
            entry.value = value;
        }
        localStorage.setItem("cache:" + key, JSON.stringify(entry));
        return entry;
    }
    /****************************************/
    remove(key) {
        localStorage.removeItem("cache:" + key);
    }
    /****************************************/
    clear() {
        for (let i = localStorage.length - 1; i >= 0; i--) {
            const key = localStorage.key(i);
            if (key.startsWith("cache:"))
                localStorage.removeItem(key);
        }
    }
    /****************************************/
    contains(key) {
        return localStorage.getItem("cache:" + key) != null;
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Types/Exception.js
class Types_Exception_Exception extends Error {
    constructor(message, innerException) {
        super();
        this.message = message;
        this.innerException = innerException;
    }
    /****************************************/
    innerException;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Services/XHRHttpClient.js




class XHRHttpClient_HttpException extends (/* unused pure expression or super */ null && (Exception)) {
    constructor(request, status, innerException) {
        super("HTTP error, status code: " + status, innerException);
        this.request = request;
    }
    request;
}
/****************************************/
class Services_XHRHttpClient_XHRHttpClient {
    onNewRequest(config) {
    }
    /****************************************/
    requestAsync(config) {
        this.onNewRequest(config);
        return new Promise((resolve, reject) => {
            const xmlhttp = new XMLHttpRequest();
            let curOperation;
            if (Services.operation) {
                curOperation = Services.operation.begin({
                    message: config.method + " " + config.url,
                    type: OperationType.Local
                });
            }
            xmlhttp.onreadystatechange = ev => {
                if (xmlhttp.readyState == XMLHttpRequest.DONE) {
                    if (curOperation)
                        curOperation.end();
                    if (xmlhttp.status == 200) {
                        let data = xmlhttp.responseText;
                        const isJson = config.responseType == "application/json";
                        if (isJson)
                            data = JSON.parse(data);
                        resolve(data);
                    }
                    else
                        reject(new XHRHttpClient_HttpException(config, xmlhttp.status));
                }
            };
            if (config.onProgress)
                xmlhttp.upload.onprogress = ev => {
                    const result = config.onProgress(ev);
                    if (!result)
                        xmlhttp.abort();
                };
            xmlhttp.open(config.method, Uri.absolute(config.url), true);
            let contentType = config.dataType;
            let data = config.data;
            if (config.data) {
                const isJson = contentType == "application/json" || typeof config.data == "object";
                const isObj = contentType == "application/octet-stream";
                if (isJson && !isObj) {
                    contentType = "application/json";
                    if (data && typeof config.data != "string")
                        data = JSON.stringify(data);
                }
            }
            if (contentType)
                xmlhttp.setRequestHeader("Content-type", contentType);
            if (config.headers) {
                for (const header in config.headers)
                    xmlhttp.setRequestHeader(header, config.headers[header]);
            }
            xmlhttp.send(data);
        });
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Utils/DomUtils.js


class DomUtils_LinqNode {
    constructor(node) {
        this.node = node;
    }
    /****************************************/
    get childNodes() {
        return (0,Core_Linq/* linq */.k)(this.node.childNodes).select(a => new DomUtils_LinqNode(a));
    }
    /****************************************/
    descendsFrom(target) {
        let curItem = this.node;
        while (curItem != null) {
            if (curItem == target)
                return true;
            curItem = curItem.parentNode;
        }
        return false;
    }
    /****************************************/
    hasClass(className) {
        if ("classList" in this.node)
            return this.node.classList.contains(className);
        return false;
    }
    /****************************************/
    get discendants() {
        function* iterator(node) {
            for (const child of this.node.childNodes) {
                yield new DomUtils_LinqNode(child);
                for (const innerChild of iterator(child))
                    yield innerChild;
            }
            ;
        }
        return (0,Core_Linq/* linq */.k)(iterator(this.node));
    }
    /****************************************/
    get parentNodesOrSelf() {
        function* iterator(node) {
            let curItem = node;
            while (curItem != null) {
                yield new DomUtils_LinqNode(curItem);
                curItem = curItem.parentNode;
            }
        }
        return (0,Core_Linq/* linq */.k)(iterator(this.node));
    }
    /****************************************/
    get parentNodes() {
        return this.parentNodesOrSelf.skip(1);
    }
    /****************************************/
    get name() {
        return this.node.nodeName;
    }
    /****************************************/
    node;
}
/****************************************/
function DomUtils_parentOfClass(src, className) {
    return DomUtils_linqNode(src).parentNodes.where(a => a.hasClass(className)).select(a => a.node).first();
}
/****************************************/
function DomUtils_linqNode(src) {
    return new DomUtils_LinqNode(src);
}
/****************************************/
function DomUtils_isParentOrSelf(element, parent) {
    let curElement = element;
    while (curElement) {
        if (curElement == parent)
            return true;
        curElement = curElement.parentElement;
    }
    return false;
}
/****************************************/
function DomUtils_generateNodeId(base = "id_") {
    while (true) {
        const curId = base + randomString(8);
        if (!document.getElementById(curId))
            return curId;
    }
}
/****************************************/
function Utils_DomUtils_removeClass(element, className) {
    if (element.classList.contains(className))
        element.classList.remove(className);
}
/****************************************/
function Utils_DomUtils_addClass(element, className) {
    if (!element.classList.contains(className))
        element.classList.add(className);
}
/****************************************/
function DomUtils_isTouchDevice() {
    return ("ontouchstart" in window) ||
        (navigator.maxTouchPoints > 0);
}
/****************************************/
function DomUtils_isSmallDevice() {
    return window.innerWidth < 610;
}
/****************************************/
async function DomUtils_copyText(value) {
    if (navigator["clipboard"])
        await navigator.clipboard.writeText(value);
    else {
        const input = document.createElement("textarea");
        document.body.appendChild(input);
        input.value = value;
        input.select();
        //input.setSelectionRange(0, input.value.length);
        document.execCommand("copy");
        document.body.removeChild(input);
    }
}
/****************************************/
function DomUtils_getScrollParent(element) {
    if (!element)
        return null;
    if (element.scrollHeight > element.clientHeight)
        return element;
    return DomUtils_getScrollParent(element.parentElement);
}
/****************************************/
function DomUtils_isScrolledIntoView(element) {
    const scrollParent = DomUtils_getScrollParent(element);
    if (!scrollParent)
        return true;
    const scrollTop = scrollParent.scrollTop;
    const scrollBottom = scrollTop + scrollParent.clientHeight;
    const elemTop = element.offsetTop;
    const elemBottom = element.clientHeight + elemTop;
    return elemTop < scrollBottom && elemBottom > scrollTop;
}
/****************************************/
function DomUtils_centerElement(element, always = true) {
    const topOfPage = document.documentElement.scrollTop;
    const heightOfPage = window.innerHeight;
    let elY = 0;
    let elH = 0;
    for (let p = element; p && p != document.body; p = p.offsetParent)
        elY += p.offsetTop;
    elH = element.offsetHeight;
    if (always || elY + elH > topOfPage + heightOfPage || elY < topOfPage)
        document.documentElement.scrollTop = Math.max(0, elY - (heightOfPage - elH) / 2);
    return elY - document.documentElement.scrollTop;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Utils/Identifier.js
const Identifier_idMap = {};
function Identifier_generateId(base) {
    if (!base)
        base = "item";
    if (Identifier_idMap[base] === undefined)
        Identifier_idMap[base] = 0;
    Identifier_idMap[base]++;
    if (Identifier_idMap[base] == 1)
        return base;
    return base + Identifier_idMap[base];
}

// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Utils/PromiseUtils.js
var Utils_PromiseUtils = __webpack_require__(6196);
// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Helpers/TypeCheck.js
var Helpers_TypeCheck = __webpack_require__(2696);
;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Utils/ArrayUtils.js


function ArrayUtils_equalsArray(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b))
        return false;
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (!ObjectUtils_equals(a[i], b[i]))
            return false;
    }
    return true;
}
/****************************************/
async function ArrayUtils_forEachAsync(items, chunkSize, action) {
    let index = 0;
    for (const item of items) {
        action(item, index);
        if (index % chunkSize == 0)
            await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        index++;
    }
}
/****************************************/
function ArrayUtils_mergeArrays(...args) {
    const result = [];
    for (const item of args) {
        if (!item)
            continue;
        result.push(...item);
    }
    return result;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Utils/ObjectUtils.js


function ObjectUtils_isEmpty(value) {
    return value === undefined || value === null || (Array.isArray(value) && value.length == 0);
}
/****************************************/
function ObjectUtils_equals(valueA, valueB) {
    if (Array.isArray(valueA) || Array.isArray(valueB))
        return ArrayUtils_equalsArray(valueA, valueB);
    return valueA == valueB;
}
/****************************************/
function ObjectUtils_createInstance(typeName, ...args) {
    const parts = typeName.split(".");
    let curType = window;
    for (const part of parts)
        curType = curType[part];
    return new curType(...args);
}
/****************************************/
function ObjectUtils_hasProp(obj, propName) {
    return (propName in obj);
}
/****************************************/
function ObjectUtils_isInstanceOf(obj, type) {
    if (!obj)
        return;
    let curType = ObjectUtils_getType(obj);
    while (curType != null) {
        if (curType == type)
            return true;
        curType = ObjectUtils_getBaseType(curType);
    }
    return false;
}
/****************************************/
function ObjectUtils_getOrCreateProperty(obj, propName, value) {
    const desc = Object.getOwnPropertyDescriptor(obj, propName);
    if (!desc) {
        ObjectUtils_createProperty(obj, propName, value);
        return value;
    }
    return ObjectUtils_get(obj, propName);
}
/****************************************/
function ObjectUtils_createProperty(obj, propName, value) {
    if (propName.substr(0, 1) == "@") {
        Object.defineProperty(obj, propName, {
            writable: true,
            enumerable: false,
            value: value
        });
    }
    else {
        Object.defineProperty(obj, propName, {
            value: value
        });
    }
}
/****************************************/
function ObjectUtils_get(obj, propName, defValue) {
    if (!obj)
        return defValue;
    const value = obj[propName];
    if (value === undefined || value === null)
        return defValue;
    return value;
}
/****************************************/
function ObjectUtils_set(obj, propName, value) {
    if (propName.substr(0, 1) == "@") {
        const desc = Object.getOwnPropertyDescriptor(obj, propName);
        if (!desc)
            ObjectUtils_createProperty(obj, propName, value);
        else
            obj[propName] = value;
    }
    else
        obj[propName] = value;
}
/****************************************/
function ObjectUtils_setTypeName(obj, name) {
    if ((0,Helpers_TypeCheck/* isObject */.Kn)(obj))
        ObjectUtils_set(obj, "@typeName", name);
    else
        ObjectUtils_set(Object.getPrototypeOf(obj), "@typeName", name);
}
/****************************************/
function ObjectUtils_getTypeName(obj) {
    if (!obj)
        return undefined;
    let name = obj["@typeName"];
    if (!name) {
        name = typeof obj;
        if (name == "function")
            return ObjectUtils_getFunctionName(obj);
        if (name == "object") {
            const constFunc = obj.constructor;
            if (constFunc)
                return ObjectUtils_getTypeName(constFunc);
        }
    }
    return name;
}
function ObjectUtils_getBaseType(objOrFun) {
    let proto;
    if ((0,Helpers_TypeCheck/* isFunction */.mf)(objOrFun))
        proto = objOrFun.prototype;
    else
        proto = Object.getPrototypeOf(objOrFun);
    return Object.getPrototypeOf(proto).constructor;
}
function ObjectUtils_getType(typeOrName) {
    if ((0,Helpers_TypeCheck/* isString */.HD)(typeOrName)) {
        const parts = typeOrName.split(".");
        let curObj = self;
        parts.forEach(part => {
            curObj = curObj[part];
            if (!curObj)
                return null;
        });
        return curObj;
    }
    return typeOrName.constructor;
}
/****************************************/
function ObjectUtils_getFunctionName(func) {
    let curName = func.name;
    if (!curName) {
        const funcNameRegex = /function\s([^(]{1,})\(/;
        const results = (funcNameRegex).exec(func.toString());
        curName = (results && results.length > 1) ? results[1].trim() : "";
    }
    return curName;
}
/****************************************/
function ObjectUtils_clone(obj) {
    if (isCloneable(obj))
        return obj.clone();
    return JSON.parse(JSON.stringify(obj));
}
/****************************************/
function ObjectUtils_registerType(type, name) {
    ObjectUtils_set(type, "@typeName", name);
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/ComputedProperty.js

class ComputedProperty_ComputedProperty {
    _handlers;
    /****************************************/
    constructor(getter, name) {
        this.get = getter;
        this.name = name;
    }
    /****************************************/
    get() {
        throw "Not implemented";
    }
    /****************************************/
    set(value) {
        //throw "Not supported";
    }
    /****************************************/
    notifyChanged() {
        const value = this.get();
        Binder_forEachRev(this._handlers, handler => handler(value, undefined));
    }
    /****************************************/
    subscribe(handler) {
        if (!this._handlers)
            this._handlers = [];
        const index = this._handlers.indexOf(handler);
        if (index == -1)
            this._handlers.push(handler);
        return handler;
    }
    /****************************************/
    unsubscribe(handler) {
        if (!this._handlers)
            return;
        const index = this._handlers.indexOf(handler);
        if (index != -1)
            this._handlers.splice(index, 1);
    }
    /****************************************/
    name;
    isReadOnly = true;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/ObservableProperty.js

class Templating_ObservableProperty_ObservableProperty {
    _handlers;
    _descriptor;
    /****************************************/
    constructor(desc, name) {
        this._descriptor = desc;
        this.name = name;
    }
    /****************************************/
    get() {
        if (this._descriptor.get)
            return this._descriptor.get();
        return this._descriptor.value;
    }
    /****************************************/
    set(value) {
        const oldValue = this.get();
        if (this._descriptor.set)
            this._descriptor.set(value);
        else
            this._descriptor.value = value;
        if (oldValue != value && this._handlers) {
            Binder_forEachRev(this._handlers, handler => handler(value, oldValue));
        }
    }
    /****************************************/
    notifyChanged() {
        const value = this.get();
        Binder_forEachRev(this._handlers, handler => handler(value, undefined));
    }
    /****************************************/
    subscribe(handler) {
        if (!this._handlers)
            this._handlers = [];
        const index = this._handlers.indexOf(handler);
        if (index == -1)
            this._handlers.push(handler);
        return handler;
    }
    /****************************************/
    unsubscribe(handler) {
        if (!this._handlers)
            return;
        const index = this._handlers.indexOf(handler);
        if (index != -1)
            this._handlers.splice(index, 1);
    }
    /****************************************/
    name;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/Properties.js



/****************************************/
function Properties_newProp(name, value, onChanged) {
    const result = new ObservableProperty({
        value: value
    }, name);
    if (onChanged)
        result.subscribe(onChanged);
    return result;
}
/****************************************/
var Templating_Properties_Properties;
(function (Properties) {
    function converter(obj, propName, convert, convertBack) {
        let conValue;
        return {
            get: () => {
                if (conValue == undefined)
                    conValue = convert(obj[propName]);
                return conValue;
            },
            set: value => {
                conValue = value;
                if (convertBack)
                    obj[propName] = convertBack(value);
            },
            name: propName
        };
    }
    Properties.converter = converter;
    /****************************************/
    function create(obj, propName, property) {
        let desc = Object.getOwnPropertyDescriptor(obj, propName);
        if (!desc) {
            console.warn("'", propName, "' not defined in ", ObjectUtils_getTypeName(obj));
            desc = {};
        }
        if (!property)
            property = new Templating_ObservableProperty_ObservableProperty(desc, propName);
        const props = ObjectUtils_getOrCreateProperty(obj, "@props", {});
        props[propName] = property;
        Object.defineProperty(obj, propName, {
            get: () => property.get(),
            set: (newValue) => property.set(newValue)
        });
        return property;
    }
    Properties.create = create;
    /****************************************/
    function createAll(obj) {
        const props = Object.getOwnPropertyNames(obj);
        props.forEach(propName => {
            if (propName[0] == "_" || propName[0] == "$")
                return;
            const propDesc = Object.getOwnPropertyDescriptor(obj, propName);
            if (propDesc && !propDesc.writable)
                return;
            create(obj, propName);
        });
        return obj;
    }
    Properties.createAll = createAll;
    /****************************************/
    function get(obj, propName) {
        if (ObjectUtils_hasProp(obj, "@props")) {
            const prop = obj["@props"][propName];
            if (prop)
                return prop;
        }
        return undefined;
    }
    Properties.get = get;
    /****************************************/
    function getOrCreate(obj, propName, property) {
        const prop = get(obj, propName);
        if (prop)
            return prop;
        return create(obj, propName, property);
    }
    Properties.getOrCreate = getOrCreate;
    /****************************************/
    function isProperty(obj) {
        return (obj && typeof obj == "object" && typeof obj["get"] == "function" && obj["get"].length == 0 && typeof obj["set"] == "function" && obj["set"].length == 1);
    }
    Properties.isProperty = isProperty;
    /****************************************/
    function isObservableProperty(obj) {
        //TODO improve this check
        return obj instanceof Templating_ObservableProperty_ObservableProperty || obj instanceof ComputedProperty_ComputedProperty;
    }
    Properties.isObservableProperty = isObservableProperty;
    /****************************************/
    function bind(dest, src, converter) {
        let value;
        if (isProperty(src)) {
            if (isObservableProperty(src)) {
                src.subscribe(value => {
                    if (converter)
                        dest.set(converter.convertTo(value));
                    else
                        dest.set(value);
                });
            }
            dest.subscribe(value => {
                if (converter)
                    src.set(converter.convertFrom(value));
                else
                    src.set(value);
            });
            value = src.get();
        }
        else
            value = src;
        if (converter)
            dest.set(converter.convertTo(value));
        else
            dest.set(value);
        return undefined;
    }
    Properties.bind = bind;
})(Templating_Properties_Properties || (Templating_Properties_Properties = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/Binder.js


/****************************************/
class Binder_Binder {
    _bindings = [];
    _modelBinders = [];
    _depBinders = [];
    /****************************************/
    constructor(model) {
        this.model = model;
    }
    /****************************************/
    register(binder) {
        this._modelBinders.push(binder);
    }
    /****************************************/
    registerDependant(binder) {
        this._depBinders.push(binder);
    }
    /****************************************/
    unregisterDependant(binder) {
        const index = this._depBinders.indexOf(binder);
        if (index != -1)
            this._depBinders.splice(index, 1);
    }
    /****************************************/
    getBindValue(value) {
        if (typeof value == "function")
            return value(this.model);
        return value;
    }
    /****************************************/
    bind(value, action) {
        if (typeof value == "function") {
            const binding = {
                value: value,
                action: action,
                subscriptions: [],
                lastValue: undefined
            };
            this._bindings.push(binding);
            binding.value(this.createProxy(this.model, (obj, propName) => {
                this.subscribe(obj, propName, binding);
                return true;
            }));
            const bindValue = binding.value(this.model);
            binding.action(bindValue, undefined, false);
            binding.lastValue = bindValue;
        }
        else
            action(value, undefined, false);
    }
    /****************************************/
    unsubscribe(binding, cleanValue) {
        binding.subscriptions.forEach(sub => {
            if ((0,Helpers_TypeCheck/* isObservableList */.Ex)(sub.source))
                sub.source.unsubscribe(sub.handler);
            else
                sub.property.unsubscribe(sub.handler);
        });
        if (cleanValue && binding.lastValue) {
            binding.action(null, binding.lastValue, true, true);
            binding.lastValue = null;
        }
        binding.subscriptions = [];
    }
    /****************************************/
    subscribe(obj, propName, binding) {
        for (let i = 0; i < binding.subscriptions.length; i++) {
            const sub = binding.subscriptions[i];
            if (sub.source == obj && sub.property.name == propName)
                return;
        }
        if ((0,Helpers_TypeCheck/* isObservableList */.Ex)(obj)) {
            const handler = {
                onChanged: () => {
                    const bindValue = binding.value(this.model);
                    if (bindValue == binding.lastValue)
                        return;
                    binding.action(bindValue, binding.lastValue, true);
                    binding.lastValue = bindValue;
                }
            };
            obj.subscribe(handler);
            binding.subscriptions.push({
                source: obj,
                property: null,
                handler: handler
            });
        }
        else {
            const propDesc = Object.getOwnPropertyDescriptor(obj, propName);
            if (!propDesc || (!propDesc.writable && !propDesc.set)) {
                console.warn("Property ", propName, " for object ", obj, " not exists or is not writeable.");
                return;
            }
            const prop = Templating_Properties_Properties.getOrCreate(obj, propName);
            const handler = (value, oldValue) => {
                const bindValue = binding.value(this.model);
                if (bindValue == binding.lastValue)
                    return;
                this.unsubscribe(binding, false);
                binding.value(this.createProxy(this.model, (obj, propName) => {
                    this.subscribe(obj, propName, binding);
                    return true;
                }));
                binding.action(bindValue, binding.lastValue, true);
                binding.lastValue = bindValue;
            };
            prop.subscribe(handler);
            binding.subscriptions.push({
                source: obj,
                property: prop,
                handler: handler
            });
        }
    }
    /****************************************/
    getBindingProperty(value) {
        if (typeof value != "function")
            return null;
        let lastProp;
        value(this.createProxy(this.model, (obj, propName) => {
            lastProp = {
                obj: obj,
                propName: propName
            };
            return true;
        }));
        if (lastProp && lastProp.obj)
            return Templating_Properties_Properties.getOrCreate(lastProp.obj, lastProp.propName);
    }
    /****************************************/
    createProxy(obj, action) {
        if (!obj || typeof (obj) != "object")
            return obj;
        const propList = [];
        const proxy = {};
        if ((0,Helpers_TypeCheck/* isObservableList */.Ex)(obj)) {
            const listProxy = proxy;
            propList.push("count");
            listProxy._innerProxies = {};
            listProxy.get = (index) => {
                if (!(index in listProxy._innerProxies)) {
                    if (action(obj, index.toString()))
                        listProxy._innerProxies[index] = this.createProxy(obj.get(index), action);
                    else
                        listProxy._innerProxies[index] = obj.get(index);
                }
                return listProxy._innerProxies[index];
            };
        }
        else {
            for (const propName in obj)
                propList.push(propName);
        }
        for (const propName of propList) {
            let innerProxy;
            let isInit = false;
            let lastValueSet;
            Object.defineProperty(proxy, propName, {
                get: () => {
                    if (!isInit) {
                        if (action(obj, propName))
                            innerProxy = this.createProxy(obj[propName], action);
                        else
                            innerProxy = obj[propName];
                        isInit = true;
                    }
                    return innerProxy;
                },
                set: value => {
                    if (lastValueSet == value)
                        return;
                    if (action(obj, propName))
                        innerProxy = this.createProxy(value, action);
                    else
                        innerProxy = value;
                    lastValueSet = value;
                    isInit = true;
                }
            });
        }
        return proxy;
    }
    /****************************************/
    cleanBindings(cleanValue) {
        this._bindings.forEach(binding => this.unsubscribe(binding, cleanValue));
        this._modelBinders.forEach(binder => binder.cleanBindings(cleanValue));
        this._depBinders.forEach(binder => binder.cleanBindings(cleanValue));
        this._modelBinders = [];
        this._bindings = [];
        this._depBinders = [];
    }
    /****************************************/
    updateModel(model) {
        this.model = model;
        Binder_forEachRev(this._bindings, binding => {
            const value = binding.value(model);
            if (binding.lastValue == value)
                return;
            binding.action(value, binding.lastValue, true);
            binding.lastValue = value;
        });
        Binder_forEachRev(this._modelBinders, binder => binder.updateModel(model));
    }
    /****************************************/
    model;
}
/****************************************/
function Binder_forEachRev(items, action) {
    if (!items || items.length == 0)
        return;
    for (let i = items.length - 1; i >= 0; i--)
        action(items[i]);
}
/****************************************/
async function Binder_forEachRevAsync(items, action) {
    if (!items || items.length == 0)
        return;
    for (let i = items.length - 1; i >= 0; i--)
        await action(items[i]);
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/BindableObject.js




class Templating_BindableObject_BindableObject {
    _computedBinder;
    prop(propName) {
        return Templating_Properties_Properties.getOrCreate(this, propName);
    }
    /****************************************/
    static bindValue(value) {
        if (Templating_Properties_Properties.isProperty(value))
            return value.get();
        return value;
    }
    /****************************************/
    bindConfig(propName, config, converter, onValueChanged) {
        this.bind(propName, config && propName in config ? config[propName] : undefined, converter, onValueChanged);
    }
    /****************************************/
    bindConfigString(propName, config, configOrUsage, onValueChanged) {
        this.bindString(propName, config && propName in config ? config[propName] : undefined, configOrUsage, onValueChanged);
    }
    /****************************************/
    computed(propName, compute) {
        return Templating_Properties_Properties.create(this, propName, this.createComputed(compute, propName));
    }
    /****************************************/
    createComputed(compute, name) {
        if (!this._computedBinder)
            this._computedBinder = new Binder_Binder(this);
        const prop = new ComputedProperty_ComputedProperty(() => compute(this), name);
        this._computedBinder.bind(compute, () => prop.notifyChanged());
        return prop;
    }
    /****************************************/
    bind(propName, value, converter, onValueChanged) {
        const prop = Templating_Properties_Properties.getOrCreate(this, propName);
        if (onValueChanged)
            prop.subscribe(onValueChanged);
        if (value !== undefined)
            Templating_Properties_Properties.bind(prop, value, converter);
    }
    /****************************************/
    bindString(propName, value, configOrUsage, onValueChanged) {
        return this.bind(propName, value, {
            convertTo: a => Types_DynamicString/* DynamicString.getValue */.wI.getValue(a, configOrUsage),
            convertFrom: a => a
        }, onValueChanged);
    }
    /****************************************/
    apply(block) {
        block(this);
        return this;
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Abstraction/IMapManager.js
var Abstraction_IMapManager_MapShapeType;
(function (MapShapeType) {
    MapShapeType[MapShapeType["None"] = 0] = "None";
    MapShapeType[MapShapeType["Circle"] = 1] = "Circle";
})(Abstraction_IMapManager_MapShapeType || (Abstraction_IMapManager_MapShapeType = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Maps/BingMapManager.js
/// <reference path="../../node_modules/bingmaps/types/microsoftmaps/microsoft.maps.all.d.ts" />
/*******************************
*  BingMapItem
*******************************/




class BingMapManager_BingMapItem {
    constructor(manager, options) {
        this.id = options.id;
        this.title = options.title;
        this.description = options.description;
        this.location = options.location;
        this.shape = options.shape;
        this.icon = options.icon;
        this.color = options.color;
    }
    /*******************************/
    openInfo() {
        this.infoWindow.setOptions({
            visible: true,
            location: this.marker.getLocation()
        });
    }
    /*******************************/
    closeInfo() {
        this.infoWindow.setOptions({
            visible: false
        });
    }
    /*******************************/
    id;
    title;
    description;
    icon;
    color;
    shape;
    location;
    infoWindow;
    marker;
    shapeObj;
}
/*******************************
 *  BingMapManager
 *******************************/
class BingMapManager_BingMapManager extends (/* unused pure expression or super */ null && (BindableObject)) {
    _items = [];
    _map;
    _searchManager;
    _apiKey;
    _isShowPostion;
    _curPosItem;
    _curPosPrecision;
    _posLayer;
    /*******************************/
    constructor(apiKey) {
        super();
        this._apiKey = apiKey;
        this.prop("selectedItem").subscribe((newVal, oldVal) => {
            if (newVal)
                newVal.marker.setOptions({ color: this.selectionColor });
            if (oldVal)
                oldVal.marker.setOptions({ color: oldVal.color });
            this.onSelectionChanged();
        });
    }
    /*******************************/
    updateSize() {
        const currentCenter = this._map.getCenter();
        this._map.setView({
            center: currentCenter
        });
    }
    /*******************************/
    staticMap(options) {
        let result = "https://dev.virtualearth.net/REST/v1/Imagery/Map/Road";
        if (options.center) {
            result += "/" + options.center.latitude + "," + options.center.longitude;
            result += "/" + (options.zoomLevel ? options.zoomLevel : 15);
        }
        result += "?";
        if (options.size)
            result += "mapSize=" + options.size.width + "," + options.size.height + "&";
        if (options.pins) {
            options.pins.forEach(pin => {
                result += "pushpin=" + pin.center.latitude + "," + pin.center.longitude + ";";
                result += (pin.icon ? pin.icon : 5) + ";";
                if (pin.name)
                    result += encodeURIComponent(pin.name);
                result += "&";
            });
        }
        result += "format=PNG&key=" + encodeURIComponent(this._apiKey);
        return result;
    }
    /*******************************/
    attach(element) {
        this.loadModuleAsync("Microsoft.Maps.SpatialMath");
        this._map = new Microsoft.Maps.Map(element, {
            credentials: this._apiKey,
            zoom: 16,
            showMapTypeSelector: false,
            showLocateMeButton: true,
            liteMode: true
        });
        this._posLayer = new Microsoft.Maps.Layer();
        this._map.layers.insert(this._posLayer);
        this.isReady = true;
        this.onAttached();
    }
    /*******************************/
    onAttached() {
    }
    /*******************************/
    onSelectionChanged() {
    }
    /*******************************/
    zoomToItems() {
        if (this._items.length == 1) {
            this.centerTo(this._items[0].location);
        }
        else if (this._items.length > 1) {
            const locations = [];
            this._items.forEach(item => locations.push(new Microsoft.Maps.Location(item.location.latitude, item.location.longitude)));
            this._map.setView({
                bounds: Microsoft.Maps.LocationRect.fromLocations(locations)
            });
        }
    }
    /*******************************/
    centerToCurrent() {
        if (!navigator.geolocation)
            return;
        navigator.geolocation.getCurrentPosition(pos => {
            this.centerTo({
                latitude: pos.coords.latitude,
                longitude: pos.coords.longitude
            });
        });
    }
    /*******************************/
    getZoomLevel(radiusInKilometer, latitude) {
        const widthOfMapInPixels = this.map.getRootElement().clientWidth;
        const heightOfMapInPixels = this.map.getRootElement().clientHeight;
        const rangeInMeters = radiusInKilometer * 1000;
        const limitBoundPixels = Math.min(heightOfMapInPixels, widthOfMapInPixels);
        const zoom = Math.floor(Math.log(156543.03392 * Math.cos(latitude * Math.PI / 180) / (rangeInMeters / limitBoundPixels)) / Math.log(2));
        return zoom;
    }
    /*******************************/
    centerTo(location, radiusMeters) {
        this._map.setView({
            center: new Microsoft.Maps.Location(location.latitude, location.longitude),
            zoom: radiusMeters ? this.getZoomLevel(radiusMeters / 1000, location.latitude) : undefined
        });
    }
    /*******************************/
    async getSearchManagerAsync() {
        if (!this._searchManager) {
            await this.loadModuleAsync("Microsoft.Maps.Search");
            this._searchManager = new Microsoft.Maps.Search.SearchManager(this._map);
        }
        return this._searchManager;
    }
    /*******************************/
    async getAddressAsync(location) {
        const sm = await this.getSearchManagerAsync();
        return new Promise((res, rej) => {
            sm.reverseGeocode({
                location: new Microsoft.Maps.Location(location.latitude, location.longitude),
                callback: r => {
                    if (r && r.address)
                        res(r.address.formattedAddress);
                    else
                        res(undefined);
                }
            });
        });
    }
    /*******************************/
    async getLocationAsync(address) {
        const sm = await this.getSearchManagerAsync();
        return new Promise((res, rej) => {
            sm.geocode({
                where: address,
                bounds: this._map.getBounds(),
                callback: r => {
                    if (r && r.results && r.results.length > 0)
                        res({ latitude: r.results[0].location.latitude, longitude: r.results[0].location.longitude });
                    else
                        res(undefined);
                }
            });
        });
    }
    /*******************************/
    async showCurrentPositionAsync(value) {
        if (value == this._isShowPostion)
            return;
        this._isShowPostion = value;
        if (value) {
            if (await Services.permissionManager.geolocation.isGranted())
                this.updatePositionAsyc();
        }
        this._posLayer.setVisible(value);
    }
    /*******************************/
    async updatePositionAsyc(pos) {
        if (!pos)
            pos = await new Promise(res => navigator.geolocation.getCurrentPosition(res));
        const location = new Microsoft.Maps.Location(pos.coords.latitude, pos.coords.longitude);
        const path = Microsoft.Maps.SpatialMath.getRegularPolygon(location, pos.coords.accuracy, 36, Microsoft.Maps.SpatialMath.DistanceUnits.Meters);
        console.log(pos.coords.heading);
        const rotation = pos.coords.heading - 180;
        const transform = `rotate(${rotation} 77 77)`;
        const scaleFactor = 154 / 24;
        const width = 380 / scaleFactor;
        const height = 446 / scaleFactor;
        const svgIcon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-154 -223 380 446" width="${width}" height="${height}"><defs><clipPath id="id_377bbc1f_2559_44c8_a0ba_6bf58d6c86bf" role="canvas"><rect width="154.00000" height="223.00000" x="0.00000" y="0.00000"></rect></clipPath><linearGradient x1="387.48379" y1="146.66474" x2="193.95144" y2="235.10915" gradientUnits="userSpaceOnUse" id="id_b4527e8c_865b_4f93_a70e_92dd29ceed6a"><stop offset="0.0%" style="stop-color: rgb(3, 169, 244); stop-opacity: 1;"></stop><stop offset="100.0%" style="stop-color: rgb(255, 255, 255); stop-opacity: 0.368627;"></stop></linearGradient></defs><g id="id_b1da7e8c_0f77_4801_a9e9_d3df1cffa865" transform="${transform}" name="ArtProjectItems"><g fill="#ffffff" id="id_26d8e2e5_6f5c_4be3_a4e4_a1dc17c2cbfa" name="ArtGeometry" transform="matrix(1, 0, 0, 1, -171.15539470071286, -72.25095774122973)"><circle r="75.61522" cx="248.01568" cy="149.22398" name="geometry" id="id_26d8e2e5_6f5c_4be3_a4e4_a1dc17c2cbfa_main" role="main"></circle><use href="#id_26d8e2e5_6f5c_4be3_a4e4_a1dc17c2cbfa_main" fill="none" stroke="#000000" stroke-width="1.00000"></use></g><g fill="#03a9f4" id="id_6b0e97c8_13a8_474f_b76a_b8b8120d5d24" name="ArtGeometry" transform="matrix(1, 0, 0, 1, -157.81934710884875, -58.308758751842205)"><circle r="60.47326" cx="234.67963" cy="135.28178" name="geometry" id="id_6b0e97c8_13a8_474f_b76a_b8b8120d5d24_main" role="main"></circle></g><g fill="none" id="id_ba6838f0_76d9_4faf_9e41_9845f139ba0f" name="ArtGeometry" transform="matrix(0.40060806370973984, -0.9162495180302699, 0.9162495180302938, 0.4006080637097503, -214.48539209923712, 389.6257066762629)"><path d="M243.16623,141.34362h160l-109.87824,116.27396z" name="geometry" id="id_ba6838f0_76d9_4faf_9e41_9845f139ba0f_main" role="main" fill="url(#id_b4527e8c_865b_4f93_a70e_92dd29ceed6a)"></path></g></g></svg>`;
        if (!this._curPosItem) {
            this._curPosItem = new Microsoft.Maps.Pushpin(location, {
                icon: svgIcon,
                anchor: new Microsoft.Maps.Point((154 + 77) / scaleFactor, (223 + 77) / scaleFactor),
                enableClickedStyle: false,
                draggable: false,
                color: "#03a9f4"
            });
            this._posLayer.add(this._curPosItem);
        }
        if (!this._curPosPrecision) {
            this._curPosPrecision = new Microsoft.Maps.Polygon(path, {
                fillColor: "#03a9f450"
            });
            this._posLayer.add(this._curPosPrecision);
        }
        this._curPosItem.setOptions({ icon: svgIcon });
        this._curPosItem.setLocation(location);
        this._curPosPrecision.setLocations(path);
        if (this._isShowPostion)
            setTimeout(() => this.updatePositionAsyc(), 1000);
    }
    /*******************************/
    addItems(itemsOptions) {
        const items = [];
        const entities = [];
        itemsOptions.forEach(options => {
            const item = new BingMapManager_BingMapItem(this, options);
            item.marker = new Microsoft.Maps.Pushpin(new Microsoft.Maps.Location(options.location.latitude, options.location.longitude), {
                title: options.title,
                icon: options.icon,
                color: options.color
            });
            if (options.shape) {
                if (options.shape.type == MapShapeType.Circle) {
                    const shape = Microsoft.Maps.SpatialMath.getRegularPolygon(new Microsoft.Maps.Location(options.location.latitude, options.location.longitude), options.shape.radius ? options.shape.radius : 1, 36, Microsoft.Maps.SpatialMath.DistanceUnits.Meters);
                    let stroke, fill;
                    if (options.shape.style) {
                        stroke = options.shape.style.strokeColor ? Microsoft.Maps.Color.fromHex(options.shape.style.strokeColor) : undefined;
                        if (stroke && options.shape.style.opacity)
                            stroke.a = options.shape.style.opacity * 255;
                        fill = options.shape.style.fillColor ? Microsoft.Maps.Color.fromHex(options.shape.style.fillColor) : undefined;
                        if (fill && options.shape.style.opacity)
                            fill.a = options.shape.style.opacity * 255;
                    }
                    const poly = new Microsoft.Maps.Polygon(shape, {
                        strokeColor: stroke,
                        fillColor: fill,
                        strokeThickness: options.shape.style && options.shape.style.strokeSize ? options.shape.style.strokeSize : undefined,
                    });
                    item.shapeObj = poly;
                }
            }
            /*
            item.infoWindow = new Microsoft.Maps.Infobox(item.marker.getLocation(), {

                title: options.title,
                description: options.description,
                visible: false
            });

            item.infoWindow.setMap(this._map);
            */
            Microsoft.Maps.Events.addHandler(item.marker, "click", () => {
                this.selectedItem = item;
            });
            entities.push(item.marker);
            if (item.shapeObj)
                entities.push(item.shapeObj);
            this._items.push(item);
            items.push(item);
        });
        this._map.entities.add(entities);
        return items;
    }
    /*******************************/
    clear() {
        this._items = [];
        this.map.entities.clear();
    }
    /*******************************/
    getItemById(id) {
        return linq(this._items).first(a => a.id == id);
    }
    /*******************************/
    removeItem(item) {
        this._items.splice(this._items.indexOf(item), 1);
        this._map.entities.remove(item.marker);
        if (item.infoWindow)
            item.infoWindow.setMap(null);
        if (item.shapeObj)
            this._map.entities.remove(item.shapeObj);
    }
    /*******************************/
    loadModuleAsync(name) {
        return new Promise((res, rej) => Microsoft.Maps.loadModule(name, () => res()));
    }
    /*******************************/
    get map() {
        return this._map;
    }
    isReady = false;
    selectedItem = null;
    selectionColor = "#000000";
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/TypeCheck.js
function TypeCheck_isAsyncEditor(value) {
    return value && typeof value == "object" && "editAsync" in value && typeof value["editAsync"] == "function";
}
/****************************************/
function TypeCheck_isView(value) {
    return value && typeof value == "object" && "parentView" in value && "template" in value;
}
/****************************************/
function TypeCheck_isActivable(value) {
    return value && typeof value == "object" && typeof value["activateAsync"] == "function" && value["activateAsync"].length == 0;
}
/****************************************/
function TypeCheck_isSelectable(value) {
    return value && typeof value == "object" && "isSelected" in value && "select" in value && typeof value["select"] == "function";
}
/****************************************/
function TypeCheck_isSingleItemSelector(value) {
    return value && typeof value == "object" && "selectedItem" in value;
}
/****************************************/
function TypeCheck_isAsyncLoad(value) {
    return value && typeof value == "object" && typeof value["loadAsync"] == "function" && value["loadAsync"].length == 0;
}
/****************************************/
function TypeCheck_isValidable(value) {
    return value && typeof value == "object" && typeof value["validateAsync"] == "function" && value["validateAsync"].length < 2;
}
/****************************************/
function TypeCheck_isHTMLContainer(value) {
    return value && typeof value == "object" && "nodes" in value;
}
/****************************************/
function TypeCheck_isEditable(value) {
    return value && typeof value == "object" && "createEditor" in value && typeof value.createEditor == "function";
}
/****************************************/
function TypeCheck_isHTMLAttach(value) {
    return typeof value == "object" && "attach" in value && typeof value["attach"] == "function";
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/Abstraction/IBehavoir.js
/****************************************/
var Abstraction_IBehavoir_behavoirCatalog = {};

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/TemplateBuilder.js





/****************************************/
const TemplateBuilder_TemplateCatalog = {};
function TemplateBuilder_defineTemplate(name, template) {
    TemplateBuilder_TemplateCatalog[name] = template;
}
window["__defineTemplate"] = TemplateBuilder_defineTemplate;
/****************************************/
class Templating_TemplateBuilder_TemplateBuilder extends Binder_Binder {
    _endElement;
    _startElement;
    _lastElement;
    _childCount = 0;
    _updateCount = 0;
    _updateNode = null;
    /****************************************/
    constructor(model, element, parent) {
        super(model);
        this.parent = parent;
        this.element = element;
        if (element.namespaceURI && element.namespaceURI != "http://www.w3.org/1999/xhtml")
            this.namespace = element.namespaceURI;
    }
    /****************************************/
    beginTemplate(model, refNode, refNodePos = "after", marker) {
        const innerBuilder = new Templating_TemplateBuilder_TemplateBuilder(model, this.element, this);
        innerBuilder._lastElement = this._lastElement;
        innerBuilder.begin(refNode, refNodePos, marker);
        if (this.inlineMode == "explicit") {
            innerBuilder.isInline = this.isInline;
            innerBuilder.inlineMode = "inherit";
        }
        return innerBuilder;
    }
    /****************************************/
    endTemplate(childBuilder) {
        childBuilder.end();
        if (childBuilder.element == this.element)
            this._lastElement = childBuilder._lastElement;
    }
    /****************************************/
    beginUpdate() {
        if (this._updateCount == 0 && this.element.parentNode) {
            this._updateNode = document.createTextNode("");
            this.element.parentNode.replaceChild(this._updateNode, this.element);
        }
        this._updateCount++;
    }
    /****************************************/
    endUpdate() {
        this._updateCount--;
        if (this._updateCount == 0 && this._updateNode) {
            this._updateNode.parentNode.replaceChild(this.element, this._updateNode);
            this._updateNode = null;
        }
    }
    /****************************************/
    begin(refNode, refNodePos, marker) {
        this._startElement = marker ? document.createComment("begin-" + marker) : document.createTextNode("");
        if (refNode) {
            if (refNodePos == "after") {
                if (!refNode.nextSibling)
                    refNode.parentNode.appendChild(this._startElement);
                else
                    refNode.parentNode.insertBefore(this._startElement, refNode.nextSibling);
            }
            else if (refNodePos == "before")
                refNode.parentNode.insertBefore(this._startElement, refNode);
            else if (refNodePos == "inside")
                refNode.appendChild(this._startElement);
        }
        else
            this.appendChild(this._startElement);
        this._lastElement = this._startElement;
        return this;
    }
    /****************************************/
    end() {
        if (this._endElement)
            return;
        if (this._startElement.nodeType == Node.COMMENT_NODE)
            this._endElement = document.createComment(this._startElement.textContent.replace("begin-", "end-"));
        else
            this._endElement = document.createTextNode("");
        this.appendChild(this._endElement);
        return this;
    }
    /****************************************/
    clear(remove = false) {
        this._childCount = 0;
        if (!this._endElement) {
            console.warn("Missing end element: " + this.model);
            this.end();
        }
        let curNode = this._endElement;
        while (true) {
            let mustDelete = true;
            if ((curNode == this._startElement || curNode == this._endElement) && !remove)
                mustDelete = false;
            const prev = curNode.previousSibling;
            if (mustDelete) {
                if (mustDelete)
                    curNode.parentNode.removeChild(curNode);
            }
            if (curNode == this._startElement)
                break;
            curNode = prev;
        }
        if (remove) {
            this._endElement = null;
            this._startElement = null;
            this._lastElement = null;
        }
        else
            this._lastElement = this._startElement;
        this.cleanBindings(true);
        return this;
    }
    /****************************************/
    appendChild(node) {
        if (!this._lastElement || !this._lastElement.parentNode) //TODO this || didn't exists
            this.element.appendChild(node);
        else {
            if (this._lastElement.nextSibling)
                this._lastElement.parentNode.insertBefore(node, this._lastElement.nextSibling);
            else
                this._lastElement.parentNode.appendChild(node);
        }
        //TODO this line was inside else
        this._lastElement = node;
        //
        return this;
    }
    /****************************************/
    foreach(selector, templateOrName) {
        const value = this.getBindValue(selector);
        if (Array.isArray(value) || !value)
            this.foreachArray(selector, templateOrName);
        else
            this.foreachList(selector, templateOrName);
        return this;
    }
    /****************************************/
    foreachList(selector, templateOrName) {
        let itemsBuilders = [];
        const template = this.loadTemplate(templateOrName);
        const marker = document.createTextNode("");
        this.appendChild(marker);
        const handler = {
            onClear: () => {
                itemsBuilders.forEach(a => a.clear(true));
                itemsBuilders = [];
            },
            onItemRemoved: (item, index, reason) => {
                if (reason == "replace" || reason == "clear")
                    return;
                itemsBuilders[index].clear(true);
                itemsBuilders.splice(index, 1);
            },
            onItemSwap: (index, newIndex) => {
            },
            onItemReplaced: (newItem, oldItem, index) => {
                itemsBuilders[index].updateModel(newItem);
            },
            onItemAdded: (item, index, reason) => {
                if (reason == "replace")
                    return;
                let itemBuilder;
                if (index == itemsBuilders.length) {
                    if (index == 0)
                        itemBuilder = this.beginTemplate(item, marker, "after", this.createMarker(item));
                    else
                        itemBuilder = this.beginTemplate(item, itemsBuilders[index - 1]._endElement, "after", this.createMarker(item));
                    itemsBuilders.push(itemBuilder);
                }
                else {
                    itemBuilder = this.beginTemplate(item, itemsBuilders[index]._startElement, "before", this.createMarker(item));
                    itemsBuilders.splice(index, 0, itemBuilder);
                }
                itemBuilder.index = index;
                template(itemBuilder);
                this.endTemplate(itemBuilder);
            }
        };
        this.bind(selector, (value, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            this.beginUpdate();
            if (isUpdate)
                handler.onClear();
            if (oldValue)
                oldValue.unsubscribe(handler);
            if (value) {
                value.subscribe(handler);
                for (let i = 0; i < value.count; i++)
                    handler.onItemAdded(value.get(i), i, "add");
            }
            this.endUpdate();
        });
        return this;
    }
    /****************************************/
    foreachArray(selector, templateOrName) {
        let itemsBuilders = [];
        const template = this.loadTemplate(templateOrName);
        const marker = document.createTextNode("");
        this.appendChild(marker);
        this.bind(selector, (value, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            if (isUpdate) {
                itemsBuilders.forEach(a => a.clear());
                itemsBuilders = [];
            }
            if (value) {
                this._lastElement = marker;
                this.beginUpdate();
                value.forEach(item => {
                    const itemBuilder = this.beginTemplate(item);
                    itemBuilder.index = itemsBuilders.length;
                    template(itemBuilder);
                    this.endTemplate(itemBuilder);
                    itemsBuilders.push(itemBuilder);
                });
                this.endUpdate();
            }
        });
        return this;
    }
    /****************************************/
    if(condition, trueTemplate, falseTemplate) {
        const childBuilder = this.beginTemplate(this.model);
        this.register(childBuilder);
        this.bind(condition, (value, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            if (isUpdate)
                childBuilder.clear();
            if (value)
                childBuilder.template(trueTemplate);
            else if (falseTemplate)
                childBuilder.template(falseTemplate);
        });
        this.endTemplate(childBuilder);
        return this;
    }
    /****************************************/
    replaceContent(nodes) {
        if (this.isInline)
            throw "'replaceContent' not supported in inline elements";
        this.clear();
        for (const node of nodes)
            this.appendChild(node);
    }
    /****************************************/
    extractContent() {
        const result = [];
        for (const child of (0,Core_Linq/* linq */.k)(this.element.childNodes)) {
            if (child != this._startElement && child != this._endElement)
                result.push(child);
        }
        return result;
    }
    /****************************************/
    content(content, inline = false) {
        const childBuilder = this.beginTemplate(undefined, undefined, undefined, this.createMarker(content));
        childBuilder.isInline = inline;
        childBuilder.inlineMode = "explicit";
        this.bind(content, (value, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            this.beginUpdate();
            if (!childBuilder.isInline && TypeCheck_isHTMLContainer(value) && value.nodes && value.isCacheEnabled === true)
                childBuilder.replaceContent(value.nodes);
            else {
                if (oldValue && value && oldValue.template == value.template)
                    childBuilder.updateModel(value);
                else {
                    if (isUpdate)
                        childBuilder.clear();
                    if (value) {
                        const template = this.templateFor(value);
                        if (!template)
                            throw "Template '" + value.template + "' not found.";
                        childBuilder.updateModel(value);
                        template(childBuilder);
                    }
                }
                if (TypeCheck_isHTMLContainer(value) && value.isCacheEnabled === true)
                    value.nodes = this.extractContent();
            }
            this.endUpdate();
        });
        this.endTemplate(childBuilder);
        return this;
    }
    /****************************************/
    templateFor(value) {
        if (typeof value == "string" || typeof value == "number")
            return this.loadTemplate("Text");
        if (typeof value == "object" && "template" in value)
            return this.loadTemplate(value.template);
        throw "cannot determine template for model";
    }
    /****************************************/
    loadTemplate(templateOrName) {
        if (typeof templateOrName == "string") {
            const result = TemplateBuilder_TemplateCatalog[templateOrName];
            if (!result)
                console.error("Template ", templateOrName, " not found.");
            return result;
        }
        return templateOrName;
    }
    template(templateOrName, model) {
        const template = this.loadTemplate(templateOrName);
        if (model) {
            const childBuilder = this.beginTemplate(undefined, undefined, undefined, this.createMarker(model, "template"));
            this.bind(model, (value, oldValue, isUpdate, isClear) => {
                if (isClear)
                    return;
                childBuilder.updateModel(value);
                if (!isUpdate)
                    template(childBuilder);
            });
            this.endTemplate(childBuilder);
        }
        else
            template(this);
        return this;
    }
    /****************************************/
    exec(action) {
        action(this);
        return this;
    }
    /****************************************/
    beginChild(name, namespace) {
        if (this.isInline && this._childCount > 0)
            throw "In inline mode you must have a single root element for your template";
        const childElement = this.isInline && name.toUpperCase() == this.element.tagName ? this.element : this.createElement(name, namespace);
        const childBuilder = new TemplateBuilder_ChildTemplateBuilder(this.model, childElement, this);
        if (childElement == this.element)
            childBuilder._lastElement = this._lastElement;
        this.register(childBuilder);
        this._childCount++;
        return childBuilder;
    }
    child(name, builderOrAttributes, namespace) {
        const childBuilder = new Templating_TemplateBuilder_TemplateBuilder(this.model, this.createElement(name, namespace), this);
        this.register(childBuilder);
        if (typeof builderOrAttributes == "function")
            builderOrAttributes(childBuilder);
        else
            childBuilder.attribs(builderOrAttributes);
        this.appendChild(childBuilder.element);
        return this;
    }
    /****************************************/
    set(attribute, value) {
        this.bind(value, a => {
            if (a !== null && a !== undefined) {
                if (a instanceof Promise) {
                    a.then(newValue => this.element.setAttribute(attribute, newValue));
                }
                else
                    this.element.setAttribute(attribute, a);
            }
            else
                this.element.removeAttribute(attribute);
        });
        return this;
    }
    /****************************************/
    on(event, handler) {
        this.element.addEventListener(event, ev => handler(this.model, ev));
        return this;
    }
    class(name, condition) {
        if (condition) {
            const nameParts = name ? name.split(" ") : [];
            this.bind(condition, value => {
                if (value)
                    nameParts.forEach(a => this.element.classList.add(a));
                else
                    nameParts.forEach(a => this.element.classList.remove(a));
            });
        }
        else
            this.bind(name, (value, oldValue) => {
                if (oldValue)
                    oldValue.split(" ").forEach(item => this.element.classList.remove(item));
                if (value)
                    value.split(" ").forEach(item => this.element.classList.add(item));
            });
        return this;
    }
    /****************************************/
    visible(value) {
        this.bind(value, (newValue, oldValue, isUpdate, isClear) => {
            if (isClear)
                return;
            if (newValue) {
                this.element.classList.add("visible");
                this.element.classList.remove("hidden");
            }
            else {
                this.element.classList.add("hidden");
                this.element.classList.remove("visible");
            }
        });
        return this;
    }
    /****************************************/
    text(value) {
        const textNode = document.createTextNode("");
        this.appendChild(textNode);
        this.bind(value, a => textNode.textContent = a);
        return this;
    }
    /****************************************/
    html(value) {
        this.bind(value, a => this.element.innerHTML = a);
        return this;
    }
    /****************************************/
    focus(value) {
        const valueProp = this.getBindingProperty(value);
        if (valueProp) {
            this.element.addEventListener("focus", ev => valueProp.set(true));
            this.element.addEventListener("focusout", ev => valueProp.set(false));
        }
        this.bind(value, a => {
            if (a && document.activeElement != this.element)
                this.element.focus();
        });
        return this;
    }
    /****************************************/
    value(value) {
        const element = this.element;
        const valueProp = this.getBindingProperty(value);
        if (valueProp) {
            if (element.tagName == "INPUT" || element.tagName == "TEXTAREA") {
                if (element.type == "checkbox" || element.type == "radio")
                    element.addEventListener("change", ev => {
                        valueProp.set(element.checked);
                    });
                else {
                    element.addEventListener("keyup", ev => {
                        valueProp.set(element.value);
                    });
                    element.addEventListener("change", ev => {
                        valueProp.set(element.value);
                    });
                }
            }
            else if (element.tagName == "SELECT") {
                element.addEventListener("change", ev => {
                    valueProp.set(element.value);
                });
            }
        }
        if (element.tagName == "INPUT" || element.tagName == "TEXTAREA" || element.tagName == "SELECT") {
            if (element.type == "checkbox" || element.type == "radio")
                this.bind(value, (a) => element.checked = a);
            else
                this.bind(value, (a) => a ? element.value = a : element.value = null);
        }
        return this;
    }
    /****************************************/
    style(name, value) {
        this.bind(value, a => this.element.style[name] = a);
        return this;
    }
    behavoir(nameOrValue) {
        if (typeof nameOrValue == "string")
            Abstraction_IBehavoir_behavoirCatalog[nameOrValue]().attach(this.element, this.model);
        else
            nameOrValue.attach(this.element, this.model);
        return this;
    }
    /****************************************/
    styles(value) {
        for (const name in value)
            this.bind(value[name], a => this.element.style[name] = a);
        return this;
    }
    /****************************************/
    attribs(value) {
        for (const name in value)
            this.set(name, value[name]);
        return this;
    }
    /****************************************/
    debugger() {
        debugger;
        return this;
    }
    /****************************************/
    createElement(name, namespace) {
        if (!namespace)
            namespace = this.namespace;
        if (namespace)
            return document.createElementNS(namespace, name);
        return document.createElement(name);
    }
    /****************************************/
    createMarker(obj, baseName = "") {
        return undefined;
        if (typeof obj == "function")
            return this.createMarker(obj(this.model), baseName);
        if (typeof obj == "string")
            return baseName + obj;
        if (obj == null)
            return baseName + "null";
        return this.createMarker(ObjectUtils_getTypeName(obj), baseName);
    }
    /****************************************/
    namespace = null;
    element = null;
    parent = null;
    isInline = false;
    inlineMode = "never";
    index = 0;
}
/****************************************/
class TemplateBuilder_ChildTemplateBuilder extends Templating_TemplateBuilder_TemplateBuilder {
    constructor(model, element, parent) {
        super(model, element, parent);
    }
    /****************************************/
    endChild() {
        if (this.parent.element != this.element)
            this.parent.appendChild(this.element);
        else {
            if (this._lastElement)
                this.parent["_lastElement"] = this._lastElement;
        }
        return this.parent;
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/Functions.js



function Functions_model(obj) {
    Properties.createAll(obj);
    return obj;
}
/****************************************/
function Templating_Functions_template(root, template, model) {
    root.innerHTML = "";
    const builder = new TemplateBuilder(model, root);
    builder.begin();
    builder.loadTemplate(template)(builder);
    builder.end();
}
/****************************************/
function Functions_setEnumerable(obj, propName) {
    let curType = ObjectUtils_getType(obj);
    while (true) {
        const desc = Object.getOwnPropertyDescriptor(curType.prototype, propName);
        if (desc) {
            if (!desc.enumerable) {
                desc.enumerable = true;
                Object.defineProperty(obj, propName, desc);
            }
            return;
        }
        curType = ObjectUtils_getBaseType(curType);
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Templating/ObservableList.js
class ObservableList_ObservableList {
    _items = [];
    _handlers;
    /****************************************/
    constructor(items, equalityComparer) {
        this._items = items || [];
        this.equalityComparer = equalityComparer;
    }
    /****************************************/
    add(item) {
        this._items.push(item);
        this.invoke(a => a.onItemAdded ? a.onItemAdded(item, this._items.length - 1, "add") : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
        return item;
    }
    /****************************************/
    addRange(items) {
        for (const item of items) {
            this._items.push(item);
            this.invoke(a => a.onItemAdded ? a.onItemAdded(item, this._items.length - 1, "add") : undefined);
        }
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
    }
    /****************************************/
    insert(index, item) {
        this._items.splice(index, 0, item);
        this.invoke(a => a.onItemAdded ? a.onItemAdded(item, index, "insert") : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
        return item;
    }
    /****************************************/
    remove(item) {
        const index = this.indexOf(item);
        if (index != -1)
            this.removeAt(index);
    }
    /****************************************/
    removeWhen(condition) {
        for (let i = this._items.length - 1; i >= 0; i--) {
            if (condition(this._items[i]))
                this.removeAt(i);
        }
    }
    /****************************************/
    removeRange(startIndex, count) {
        const items = this._items.splice(startIndex, count);
        let isChanged = false;
        for (let i = items.length - 1; i >= 0; i--) {
            this.invoke(a => a.onItemRemoved ? a.onItemRemoved(items[i], startIndex + i, "remove") : undefined);
            isChanged = true;
        }
        if (isChanged)
            this.invoke(a => a.onChanged ? a.onChanged() : undefined);
        return items;
    }
    /****************************************/
    removeAt(index) {
        const item = this._items.splice(index, 1)[0];
        this.invoke(a => a.onItemRemoved ? a.onItemRemoved(item, index, "remove") : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
        return item;
    }
    /****************************************/
    clear() {
        if (this._items.length == 0)
            return;
        for (let i = this._items.length - 1; i >= 0; i--)
            this.invoke(a => a.onItemRemoved ? a.onItemRemoved(this._items[i], i, "clear") : undefined);
        this._items.splice(0, this._items.length);
        this.invoke(a => a.onClear ? a.onClear() : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
    }
    /****************************************/
    contains(item) {
        return this.indexOf(item) != -1;
    }
    /****************************************/
    indexOf(item) {
        if (this.equalityComparer) {
            for (let i = 0; i < this._items.length; i++) {
                if (this.equalityComparer(item, this._items[i]))
                    return i;
            }
            return -1;
        }
        return this._items.indexOf(item);
    }
    /****************************************/
    *[Symbol.iterator]() {
        for (const item of this._items)
            yield item;
    }
    /****************************************/
    toArray() {
        return this._items;
    }
    /****************************************/
    get(index) {
        return this._items[index];
    }
    /****************************************/
    set(index, value) {
        const oldItem = this._items[index];
        if (oldItem == value)
            return;
        this.invoke(a => a.onItemRemoved ? a.onItemRemoved(oldItem, index, "replace") : undefined);
        this._items[index] = value;
        this.invoke(a => a.onItemAdded ? a.onItemAdded(value, index, "replace") : undefined);
        this.invoke(a => a.onItemReplaced ? a.onItemReplaced(value, oldItem, index) : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
    }
    /****************************************/
    swap(index, newIndex) {
        const temp = this._items[newIndex];
        this._items[newIndex] = this._items[index];
        this._items[index] = temp;
        this.invoke(a => a.onItemSwap ? a.onItemSwap(index, newIndex) : undefined);
        this.invoke(a => a.onChanged ? a.onChanged() : undefined);
    }
    /****************************************/
    subscribe(handler) {
        if (!this._handlers)
            this._handlers = [];
        const index = this._handlers.indexOf(handler);
        if (index == -1)
            this._handlers.push(handler);
        return handler;
    }
    /****************************************/
    unsubscribe(handler) {
        if (!this._handlers)
            return;
        const index = this._handlers.indexOf(handler);
        if (index != -1)
            this._handlers.splice(index, 1);
    }
    /****************************************/
    forEach(action) {
        let index = 0;
        for (const item of this) {
            action(item, index);
            index++;
        }
    }
    /****************************************/
    invoke(action) {
        if (!this._handlers)
            return;
        this._handlers.forEach(handler => action(handler));
    }
    /****************************************/
    get first() {
        return this._items[0];
    }
    get last() {
        return this._items[this._items.length - 1];
    }
    get count() {
        return this._items.length;
    }
    toJSON() {
        return this._items;
    }
    /****************************************/
    equalityComparer;
}
/****************************************/
function Templating_ObservableList_listOf(items) {
    return new ObservableList_ObservableList(items);
}
/****************************************/
function Templating_ObservableList_observableListOf(items, equalityComparer) {
    return new ObservableList_ObservableList(items, equalityComparer);
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/BaseSearch.js

/****************************************/
class BaseSearch_BaseSearch {
    searchAsync(query, chunkSize = 25) {
        if (!query)
            query = "";
        const queryParts = linq(query.toLowerCase().split(" ")).select(a => a.trim()).where(a => a != "").toArray();
        const result = [];
        if (queryParts.length > 0)
            this.doSearch(queryParts, result);
        return linq(result).orderByDesc(a => a.rank).select(a => a.value).toArrayAsync(chunkSize);
    }
    /****************************************/
    macthWeight(keyword, text) {
        if (!text)
            return 0;
        if (typeof text != "string")
            text = text.toString();
        text = text.toLowerCase();
        const index = text.indexOf(keyword);
        if (index == -1)
            return 0;
        return (text.length == keyword.length ? 1 : (text.length - keyword.length - index) / (text.length - keyword.length)) +
            (text.length - keyword.length) / text.length;
    }
    /****************************************/
    matchValue(value, queryParts) {
        if (queryParts.length == 0)
            return 1;
        let totWeight = 0;
        for (const qPart of queryParts) {
            let partWeight = 0;
            for (const valuePart of this.getSearchParts(value))
                partWeight += this.macthWeight(qPart, valuePart.text) * valuePart.weight ?? 1;
            if (partWeight == 0)
                return 0;
            totWeight += partWeight;
        }
        return totWeight;
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/HIstoryPageHost.js





class View_HIstoryPageHost_HistoryPageHost {
    _startHistoryIndex;
    _isSyncing = 0;
    _sessionId;
    _backSignal = new Signal();
    _isFirstPage = true;
    constructor(innerHost) {
        this.innerHost = innerHost;
        this._startHistoryIndex = window.history.length;
        this._sessionId = new Date().getTime().toString();
        window.addEventListener("popstate", ev => this.onPopState(ev.state));
    }
    /****************************************/
    async onPopState(state) {
        console.debug("begin popState: ", state, " isSyncing: ", this._isSyncing);
        if (this._isSyncing)
            return;
        if (state)
            await this.goToAsync(state.index);
        this._backSignal.set();
        console.debug("end popState: ", state);
    }
    /****************************************/
    onStateChanged(page) {
        if (this._isSyncing)
            return;
        if (page == this.current)
            this.updateState();
    }
    /****************************************/
    updateState(isNew = false) {
        if (!this.current) {
            window.history.replaceState(window.history.state, "", "/");
            document.title = "";
            return;
        }
        const title = App.formatTitle(this.current.title);
        const url = this.current.url ? Uri.absolute(Format.replaceArgs(this.current.url, App.startupArgs)) : null;
        this.registerPageView();
        if (isNew) {
            const curState = {
                sessionId: this._sessionId,
                index: this.currentIndex
            };
            window.history.pushState(curState, title, url);
        }
        else
            window.history.replaceState(window.history.state, title, url);
        document.title = title;
    }
    /****************************************/
    registerPageView() {
        const url = this.current.url ? Uri.absolute(Format.replaceArgs(this.current.url, App.startupArgs)) : null;
        if ((url != document.location.href || this._isFirstPage) && this.current.url) {
            const relUrl = Format.replaceArgs(this.current.url, App.startupArgs).replace("~/", "");
            if (Services.analytics)
                Services.analytics.pageView(relUrl);
        }
    }
    /****************************************/
    async clearAsync() {
        await this.innerHost.clearAsync();
        await this.syncHistoryAsync();
        this._isSyncing++;
        window.history.pushState(null, null, null);
        window.history.go(-1);
        this._isSyncing--;
    }
    /****************************************/
    get(index) {
        return this.innerHost.get(index);
    }
    /****************************************/
    async goBackAsync() {
        if (this.currentIndex > 0) {
            console.debug("begin goBack");
            this._backSignal.reset();
            window.history.back();
            const waitRes = await this._backSignal.waitFor(TimeSpan.fromMilliseconds(500));
            console.debug("end goBack: ", waitRes);
        }
        else {
            await this.clearAsync();
            await App.mainAsync();
        }
    }
    /****************************************/
    goForwardAsync() {
        window.history.forward();
        return Promise.resolve();
    }
    /****************************************/
    async goToAsync(index) {
        await this.innerHost.goToAsync(index);
        this.updateState();
    }
    /****************************************/
    async syncHistoryAsync() {
        if (this._isSyncing)
            return;
        this._isSyncing++;
        try {
            let curState = window.history.state;
            while (curState && curState.sessionId == this._sessionId && curState.index > 0) {
                this._backSignal.reset();
                window.history.back();
                await this._backSignal.waitFor(TimeSpan.fromMilliseconds(500));
                curState = window.history.state;
            }
            let curIndex = 0;
            while (curIndex < this.pageCount) {
                const curPage = this.get(curIndex);
                const title = App.formatTitle(curPage.title);
                const url = curPage.url ? Uri.absolute(Format.replaceArgs(curPage.url, App.startupArgs)) : null;
                curState = {
                    sessionId: this._sessionId,
                    index: curIndex
                };
                if (curIndex == 0)
                    window.history.replaceState(curState, title, url);
                else
                    window.history.pushState(curState, title, url);
                if (curIndex == this.currentIndex)
                    document.title = title;
                curIndex++;
            }
            const delta = this.currentIndex - (this.pageCount - 1);
            if (delta < 0)
                window.history.go(delta);
        }
        finally {
            this._isSyncing--;
        }
    }
    /****************************************/
    async loadAsync(page, options) {
        const curState = window.history.state;
        const inSync = curState && curState.sessionId == this._sessionId && curState.index == this.currentIndex;
        await this.innerHost.loadAsync(page, options);
        page.prop("title").subscribe(a => this.onStateChanged(page));
        page.prop("url").subscribe(a => this.onStateChanged(page));
        page.host = this;
        if (inSync)
            this.updateState(true);
        else {
            await this.syncHistoryAsync();
            this.registerPageView();
        }
        this._isFirstPage = false;
        return page;
    }
    find(nameOrType) {
        return this.innerHost.find(nameOrType);
    }
    /****************************************/
    async bringFrontAsync(page) {
        await this.innerHost.bringFrontAsync(page);
        await this.syncHistoryAsync();
    }
    /****************************************/
    get currentIndex() {
        return this.innerHost.currentIndex;
    }
    set setCurrentIndex(value) {
        this.innerHost.currentIndex = value;
        this.syncHistoryAsync();
    }
    /****************************************/
    get current() {
        return this.innerHost.current;
    }
    /****************************************/
    get pageCount() {
        return this.innerHost.pageCount;
    }
    /****************************************/
    get canGoBack() {
        return this.innerHost.canGoBack || App.hasMain;
    }
    /****************************************/
    innerHost;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/View.js


/********************************************/
class Components_View_View extends Templating_BindableObject_BindableObject {
    constructor(config) {
        super();
        this.bindConfig("template", config);
        if (!this.template)
            this.template = ObjectUtils_getTypeName(this);
        if (config) {
            if (config.parentView)
                this.parentView = config.parentView;
        }
        this.debugTypeName();
    }
    /********************************************/
    debugTypeName() {
        const curName = this.constructor.name;
        const regName = this.constructor["@typeName"];
        if (!regName)
            console.warn("Type '" + curName + "' is not registered.");
    }
    /********************************************/
    template = null;
    parentView = null;
    element;
}
ObjectUtils_registerType(Components_View_View, "View");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Utils/MathUtils.js
function MathUtils_discretize(value, steps) {
    if (MathUtils_isNaNOrNull(value))
        return undefined;
    return Math.round(value * steps) / steps;
}
/****************************************/
function MathUtils_round(value, digits) {
    if (MathUtils_isNaNOrNull(value))
        return undefined;
    return Math.round(value * Math.pow(10, digits)) / Math.pow(10, digits);
}
/****************************************/
function MathUtils_exponential(value, weight = 2) {
    if (MathUtils_isNaNOrNull(value))
        return undefined;
    return 1 - Math.pow(1 - value, weight);
}
/****************************************/
function MathUtils_isNaNOrNull(a) {
    return isNaN(a) || a === null;
}
/****************************************/
function MathUtils_sumNull(a, b) {
    if (MathUtils_isNaNOrNull(a) && MathUtils_isNaNOrNull(b))
        return undefined;
    if (MathUtils_isNaNOrNull(b))
        return a;
    if (MathUtils_isNaNOrNull(a))
        return b;
    return a + b;
}
/****************************************/
function MathUtils_divideNull(a, b) {
    if (MathUtils_isNaNOrNull(a) || MathUtils_isNaNOrNull(b) || b == 0)
        return undefined;
    return a / b;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Operation.js










/****************************************/
class View_Operation_OperationView extends Components_View_View {
    _progress;
    _type;
    /****************************************/
    constructor(config) {
        super(config);
        this.bindConfig("message", config);
        if (!config.type)
            this._type = Abstraction_IOperation_OperationType.Global;
        else
            this._type = config.type;
        this.parentOperation = config.parentOperation;
    }
    /****************************************/
    end() {
        Core_Global/* Services.operation.end */.K9.operation.end(this);
    }
    /****************************************/
    get type() {
        return this._type;
    }
    /****************************************/
    get progress() {
        return this._progress;
    }
    /****************************************/
    set progress(value) {
        this._progress = value;
        if (this._progress) {
            console.log(this.getProgressDescription(this._progress));
            if (this._progress.message)
                this.message = Core_Helpers_Format/* Format.text */.E.text(this._progress.message);
        }
        else
            this.message = undefined;
    }
    /****************************************/
    addSubOperation(operation) {
        this.subOperations.add(operation);
    }
    /****************************************/
    removeSubOperation(operation) {
        this.subOperations.remove(operation);
    }
    /****************************************/
    getProgressDescription(value) {
        let msg = "Progress: ";
        if (value.message)
            msg += "'" + value.message + "'";
        if (value.current != null && value.totCount != null)
            msg += " - " + value.current + "/" + value.totCount + " (" + MathUtils_round(100 / value.totCount * value.current, 1) + "%)";
        return msg;
    }
    /****************************************/
    subOperations = Templating_ObservableList_listOf();
    message = null;
    parentOperation = null;
}
/****************************************/
class View_Operation_ViewOperationManager {
    progress(progress) {
        if (isString(progress))
            progress = { message: progress };
        if (this.current) {
            this.current.progress = progress;
            this.onProgress.raise(this, {
                operation: this.current,
                progress: progress
            });
        }
    }
    /****************************************/
    begin(configOrMessge) {
        if (!isObject(configOrMessge))
            configOrMessge = { message: configOrMessge };
        const operation = new View_Operation_OperationView(configOrMessge);
        console.group("Begin operation: ", operation.message);
        operation.progress = configOrMessge;
        if (operation.parentOperation === undefined)
            operation.parentOperation = this.current;
        this.operations.add(operation);
        if (operation.parentOperation)
            operation.parentOperation.addSubOperation(operation);
        if (operation.type != OperationType.Local) {
            const view = configOrMessge.showProgress ? new View({
                template: t => t.template("OperationView", operation)
            }) : undefined;
            App.block(view);
        }
        return operation;
    }
    /****************************************/
    end(operation) {
        console.groupEnd();
        console.log("End operation: ", operation.message);
        this.operations.remove(operation);
        if (operation.parentOperation)
            operation.parentOperation.removeSubOperation(operation);
        if (operation.type != OperationType.Local)
            App.unblock();
    }
    /****************************************/
    get current() {
        return this.operations.count > 0 ? this.operations.get(this.operations.count - 1) : null;
    }
    /****************************************/
    operations = listOf();
    onBegin = event();
    onEnd = event();
    onProgress = event();
}
/****************************************/
ObjectUtils_registerType(View_Operation_OperationView, "OperationView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/ViewUtils.js



async function ViewUtils_loadAllAsync(items) {
    const loaders = (0,Core_Linq/* linq */.k)(items).ofType(a => TypeCheck_isAsyncLoad(a)).select(a => a.loadAsync()).toArray();
    return await Promise.all(loaders);
}
/****************************************/
function Helpers_ViewUtils_formatForCss(name) {
    let s = 0;
    let result = "";
    for (let i = 0; i < name.length; i++) {
        const c = name.charAt(i);
        switch (s) {
            //upper mode or begin 
            case 0:
                result += c.toLowerCase();
                if (!StringUtils_isUpperCase(c) || c == "-")
                    s = 1;
                break;
            //first-mode
            case 1:
                if (StringUtils_isUpperCase(c) && c != "-") {
                    result += "-";
                    s = 0;
                }
                result += c.toLowerCase();
                break;
        }
    }
    return result;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ViewComponent.js



/****************************************/
class ViewComponent_ViewComponent extends Components_View_View {
    constructor(config) {
        super(config);
        this.bindConfig("enabled", config);
        this.bindConfig("visible", config);
        if (config) {
            if (config.styles)
                this.styles = config.styles;
            if (config.name)
                this.name = config.name;
        }
        this.prop("styles").subscribe(() => this.buildStyles());
        this.buildStyles();
    }
    /****************************************/
    addStyle(value) {
        if (this.styles.indexOf(value) != -1)
            return;
        this.styles.push(value);
        this.buildStyles();
    }
    /****************************************/
    removeStyle(value) {
        const index = this.styles.indexOf(value);
        if (index == -1)
            return;
        this.styles.splice(index, 1);
        this.buildStyles();
    }
    /****************************************/
    buildStyles() {
        let result = "";
        let curType = ObjectUtils_getType(this);
        while (curType != ViewComponent_ViewComponent) {
            const typeName = ObjectUtils_getTypeName(curType);
            result += Helpers_ViewUtils_formatForCss(typeName) + " ";
            curType = ObjectUtils_getBaseType(curType);
        }
        if (this.name)
            result += Helpers_ViewUtils_formatForCss(this.name) + " ";
        if (this.styles)
            result += this.styles.join(" ");
        this.className = result.trim();
    }
    /****************************************/
    get debugName() {
        return ObjectUtils_getTypeName(this) + ": " + this.name;
    }
    /****************************************/
    enabled = true;
    visible = true;
    styles = [];
    name = null;
    nodes = null;
    isCacheEnabled = false;
    className;
    status = "";
}
ObjectUtils_registerType(ViewComponent_ViewComponent, "ViewComponent");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ContentView.js



/********************************************/
class ContentView_ContentView extends ViewComponent_ViewComponent {
    constructor(config) {
        super(config);
        this.bindConfig("content", config, null, () => this.onContentChanged());
        this.bindConfig("contentTemplate", config);
        if (this.contentTemplate)
            this.template = t => t.template(t.model.contentTemplate, t.model.content);
    }
    /********************************************/
    onContentChanged() {
        if (TypeCheck_isView(this.content))
            this.content.parentView = this;
    }
    /********************************************/
    content = null;
    contentTemplate = null;
}
ObjectUtils_registerType(ContentView_ContentView, "ContentView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ContextMenu.js







/****************************************/
class Components_ContextMenu_ContextMenu extends Templating_BindableObject_BindableObject {
    _menuContainer;
    _clickHandler;
    /****************************************/
    constructor(config) {
        super();
        if (config) {
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
        }
        this._menuContainer = document.createElement("DIV");
        this._menuContainer.className = "popup-container";
        this._clickHandler = this.onClick.bind(this);
    }
    /****************************************/
    addAction(action) {
        this.actions.add(Components_ActionView_ActionView.fromAction(action));
    }
    /****************************************/
    async showAsync(element, event) {
        const curOfs = { x: 0, y: 0 };
        if (!element && event) {
            if (event instanceof MouseEvent) {
                element = event.srcElement;
                curOfs.x = event.offsetX;
                curOfs.y = event.offsetY;
            }
            else {
                curOfs.x = event.touches[0].clientX;
                curOfs.y = event.touches[0].clientY;
            }
        }
        const builder = new Templating_TemplateBuilder_TemplateBuilder(this, this._menuContainer);
        builder.template("ContextMenu", a => a);
        document.body.appendChild(this._menuContainer);
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        window.addEventListener("pointerdown", this._clickHandler);
        if (element) {
            let curEl = element;
            let offsetEl = element;
            while (curEl) {
                if (curEl == offsetEl) {
                    curOfs.y += curEl.offsetTop;
                    curOfs.x += curEl.offsetLeft;
                    offsetEl = curEl.offsetParent;
                }
                curOfs.y -= curEl.scrollTop;
                curOfs.x -= curEl.scrollLeft;
                curEl = curEl.parentElement;
            }
        }
        let xTrans = "";
        let yTrans = "";
        if (curOfs.x + this._menuContainer.clientWidth > document.body.clientWidth) {
            curOfs.x -= this._menuContainer.clientWidth;
            xTrans = "right";
        }
        else
            xTrans = "left";
        if (curOfs.y + this._menuContainer.clientHeight > document.body.clientHeight) {
            curOfs.y -= this._menuContainer.clientHeight;
            yTrans = "bottom";
        }
        else
            yTrans = "top";
        this._menuContainer.style.top = curOfs.y + "px";
        this._menuContainer.style.left = curOfs.x + "px";
        this._menuContainer.style.transformOrigin = xTrans + " " + yTrans;
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        this._menuContainer.classList.add("visible");
    }
    /****************************************/
    hide() {
        this._menuContainer.classList.remove("visible");
        window.removeEventListener("pointerdown", this._clickHandler);
        setTimeout(() => document.body.removeChild(this._menuContainer), 500);
    }
    /****************************************/
    onClick(e) {
        setTimeout(() => this.hide(), 200);
    }
    /****************************************/
    actions = Templating_ObservableList_observableListOf();
    className = "context-menu";
}
ObjectUtils_registerType(Components_ContextMenu_ContextMenu, "ContextMenu");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/IconTextView.js




/****************************************/
class Components_IconTextView_IconTextView extends ViewComponent_ViewComponent {
    constructor(config) {
        super(config);
        this.bindConfig("icon", config);
        this.bindConfigString("text", config);
        this.bindConfigString("badge", config);
    }
    /****************************************/
    icon = null;
    text = null;
    badge = null;
}
ObjectUtils_registerType(Components_IconTextView_IconTextView, "IconTextView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ActionView.js












/****************************************/
var ActionView_AggregationMode;
(function (AggregationMode) {
    AggregationMode[AggregationMode["None"] = 0] = "None";
    AggregationMode[AggregationMode["Parallel"] = 1] = "Parallel";
    AggregationMode[AggregationMode["Serial"] = 2] = "Serial";
})(ActionView_AggregationMode || (ActionView_AggregationMode = {}));
/****************************************/
class Components_ActionView_ActionView extends ContentView_ContentView {
    constructor(config) {
        super({ template: "ActionLink", ...config });
        this.bindConfigString("tooltip", config, Types_DynamicString/* StringUsage.Tooltip */.Fq.Tooltip);
        this.bindConfig("operation", config);
        this.bindConfig("canAggregate", config);
        if (config) {
            if (config.executeAsync)
                this.executeWorkAsync = () => config.executeAsync(this);
            if (config.subActions)
                config.subActions.forEach(sub => this.subActions.add(new Components_ActionView_ActionView(sub)));
        }
    }
    /****************************************/
    async executeAsync() {
        if (window.event)
            window.event.stopPropagation();
        if (Core_Global/* Services.analytics */.K9.analytics)
            Core_Global/* Services.analytics.action */.K9.analytics.action(this.name);
        const op = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Executing " + this.name, type: this.operation });
        this.status = "executing";
        try {
            await this.executeWorkAsync();
            if (this.subActions.count > 0) {
                const menu = new Components_ContextMenu_ContextMenu();
                this.subActions.forEach(a => menu.actions.add(a));
                menu.showAsync(window.event.srcElement);
            }
        }
        catch (ex) {
            Core_Global/* App.handleError */.gV.handleError(this, ex);
            throw ex;
        }
        finally {
            this.status = "";
            op.end();
        }
    }
    /****************************************/
    executeWorkAsync() {
        return Promise.resolve();
    }
    /****************************************/
    static fromAction(action, config) {
        const actionViewConfig = (a) => ({
            name: a.name,
            operation: a.operation,
            styles: a.styles,
            template: "ActionLink",
            subActions: a.subActions ? (0,Core_Linq/* linq */.k)(a.subActions).select(b => actionViewConfig(b)).toArray() : undefined,
            content: new Components_IconTextView_IconTextView({
                template: "IconTextViewInline",
                text: Core_Helpers_Format/* Format.action */.E.action(a.displayName ?? a.name),
                icon: a.icon,
                badge: a.badge
            }),
            executeAsync: a.executeAsync,
            ...config
        });
        const result = new Components_ActionView_ActionView(actionViewConfig(action));
        if (action.canExecute)
            Templating_Properties_Properties.converter(result, "visible", () => action.canExecute());
        return result;
    }
    /****************************************/
    static fromItemAction(action, getItem, config) {
        const result = new Components_ActionView_ActionView({
            name: action.name,
            operation: action.operation,
            styles: action.styles,
            content: new Components_IconTextView_IconTextView({
                template: "IconTextViewInline",
                text: Core_Helpers_Format/* Format.action */.E.action(action.displayName ?? action.name),
                icon: action.icon,
                badge: action.badge
            }),
            executeAsync: () => action.executeAsync(getItem()),
            ...config
        });
        if (action.canExecute)
            result.bind("visible", result.createComputed(() => action.canExecute(getItem())));
        return result;
    }
    /****************************************/
    static fromActionIcon(action, config) {
        const result = new Components_ActionView_ActionView({
            name: action.name,
            styles: action.styles,
            operation: action.operation,
            template: "ActionIcon",
            content: action.icon,
            tooltip: action.displayName ?? action.name,
            executeAsync: action.executeAsync,
            ...config
        });
        if (action.canExecute)
            result.bind("visible", result.createComputed(() => action.canExecute()));
        return result;
    }
    /****************************************/
    tooltip = null;
    operation = Abstraction_IOperation_OperationType.Global;
    canAggregate = ActionView_AggregationMode.None;
    subActions = Templating_ObservableList_observableListOf();
}
ObjectUtils_registerType(Components_ActionView_ActionView, "ActionView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/SelectionManager.js




class SelectionManager_SelectionManager extends Templating_BindableObject_BindableObject {
    constructor() {
        super();
        this.selectedItems.subscribe({
            onChanged: () => {
                this.updateView();
                if (this.selectedItems.count == 0)
                    this.close();
            }
        });
    }
    /****************************************/
    close() {
        this.isActive = false;
        for (var i = this.selectedItems.count - 1; i >= 0; i--)
            this.selectedItems.get(i).isSelected = false;
        this.selectedItems.clear();
        this.actions.clear();
        this.updateView();
    }
    /****************************************/
    open() {
        this.isActive = true;
    }
    /****************************************/
    addAction(action) {
        const result = Components_ActionView_ActionView.fromItemAction(action, () => this.selectedItems.toArray());
        this.actions.add(result);
        return result;
    }
    /****************************************/
    updateView() {
        this.selectionText = Types_DynamicString/* DynamicString.getValue */.wI.getValue("selection-count", { params: [this.selectedItems.count.toString()], cardinality: this.selectedItems.count });
    }
    /****************************************/
    selectedItems = Templating_ObservableList_observableListOf();
    actions = Templating_ObservableList_observableListOf();
    selectionText = null;
    isActive = false;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Behavoirs/AttachBehavoir.js
class Behavoirs_AttachBehavoir_AttachBehavoir {
    attach(element, viewModel) {
        if ("attach" in viewModel) {
            setTimeout(() => viewModel.attach(element));
        }
    }
    /****************************************/
    detach(element, viewModel) {
    }
    /****************************************/
    static instance = new Behavoirs_AttachBehavoir_AttachBehavoir();
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Behavoirs/RippleClickBehavoir.js

class Behavoirs_RippleClickBehavoir_RippleClickBehavoir {
    attach(element) {
        element.addEventListener("pointerdown", this.onClick, { passive: true });
        element.classList.add("ripple");
    }
    /****************************************/
    detach(element) {
        element.removeEventListener("pointerdown", this.onClick);
    }
    /****************************************/
    async onClick(e) {
        const curTarget = e.currentTarget;
        curTarget.classList.remove("activated");
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        curTarget.classList.add("activated");
        await (0,Utils_PromiseUtils/* delayAsync */.$)(500);
        if (curTarget.classList.contains("activated"))
            curTarget.classList.remove("activated");
    }
    /****************************************/
    static instance = new Behavoirs_RippleClickBehavoir_RippleClickBehavoir();
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Behavoirs/ScrollCheckBehavoir.js


class Behavoirs_ScrollCheckBehavoir_ScrollCheckBehavoir {
    async attach(element, viewModel) {
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        const scrollParent = element.classList.contains("scroll") || element.classList.contains("scroll-v") ? element : DomUtils_parentOfClass(element, "scroll");
        let isRequested = false;
        function computeScroll() {
            if (!viewModel.isScrollCheckActive || isRequested)
                return;
            isRequested = true;
            requestAnimationFrame(() => {
                let found = false;
                if (scrollParent != document.scrollingElement) {
                    let curItem = element;
                    found = false;
                    while (curItem != null) {
                        if (curItem == scrollParent) {
                            found = true;
                            break;
                        }
                        curItem = curItem.parentNode;
                    }
                }
                else
                    found = true;
                if (!found)
                    scrollParent.removeEventListener("scroll", computeScroll);
                else {
                    viewModel.onScroll({
                        offsetTop: scrollParent.scrollTop,
                        offsetBottom: scrollParent.scrollHeight - (scrollParent.scrollTop + scrollParent.clientHeight),
                        pageBottom: (scrollParent.scrollHeight - (scrollParent.scrollTop + scrollParent.clientHeight)) / scrollParent.clientHeight,
                        pageTop: scrollParent.scrollTop / scrollParent.clientHeight,
                        totPages: scrollParent.scrollHeight / scrollParent.clientHeight
                    });
                }
                isRequested = false;
            });
        }
        if (scrollParent != null) {
            if (scrollParent == document.scrollingElement)
                window.addEventListener("scroll", computeScroll, { passive: true });
            else
                scrollParent.addEventListener("scroll", computeScroll, { passive: true });
        }
    }
    /****************************************/
    detach(element, viewModel) {
    }
    /****************************************/
    static instance = new Behavoirs_ScrollCheckBehavoir_ScrollCheckBehavoir();
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Behavoirs/VibrateClickBehavoir.js
class Behavoirs_VibrateClickBehavoir_VibrateClickBehavoir {
    attach(element) {
        element.addEventListener("click", this.onClick);
    }
    /****************************************/
    detach(element) {
        element.removeEventListener("click", this.onClick);
    }
    /****************************************/
    onClick(e) {
        if ("vibrate" in navigator)
            navigator.vibrate(50);
    }
    /****************************************/
    static instance = new Behavoirs_VibrateClickBehavoir_VibrateClickBehavoir();
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/Blocker.js






class Components_Blocker_Blocker extends ContentView_ContentView {
    constructor() {
        super({
            template: "ContentViewNested",
            content: new Components_View_View({ template: "Spinner" }),
        });
        this.status = "hide";
        const builder = new Templating_TemplateBuilder_TemplateBuilder(this, document.body);
        builder.content(this);
    }
    /****************************************/
    attach(element) {
        this.element = element;
        element.addEventListener("mousedown", e => e.preventDefault(), { passive: true });
        element.addEventListener("touchstart", e => e.preventDefault(), { passive: true });
        if (this.status == "hide")
            this.element.style.display = "none";
    }
    /****************************************/
    async showAsync(content) {
        if (this.element)
            this.element.style.removeProperty("display");
        this.status = "showing";
        if (content)
            this.content = content;
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        if (this.status == "showing")
            this.status = "show";
    }
    /****************************************/
    async hideAsync() {
        this.content = new Components_View_View({ template: "Spinner" }),
            this.status = "hiding";
        await (0,Utils_PromiseUtils/* delayAsync */.$)(500);
        if (this.status == "hiding") {
            this.status = "hide";
            if (this.element)
                this.element.style.display = "none";
        }
    }
}
ObjectUtils_registerType(Components_Blocker_Blocker, "Blocker");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/SelfHostedPageHost.js



/****************************************/
class Components_SelfHostedPageHost_SelfHostedPageHost extends Components_View_View {
    _parentHost;
    /****************************************/
    constructor(config) {
        super({ template: "SinglePageHost", ...config });
        this._parentHost = window.parent["WebApp"]["app"]["pageHost"];
    }
    /****************************************/
    get(index) {
        return this._parentHost.get(index);
    }
    /****************************************/
    clearAsync() {
        this.current = null;
        return Promise.resolve();
    }
    /****************************************/
    goBackAsync() {
        return this._parentHost.goBackAsync();
    }
    /****************************************/
    goForwardAsync() {
        return this._parentHost.goForwardAsync();
    }
    /****************************************/
    bringFrontAsync(page) {
        if (page == this.current)
            return Promise.resolve();
        return this._parentHost.bringFrontAsync(page);
    }
    /****************************************/
    loadAsync(page, options) {
        if (!this.current) {
            page.host = this;
            this.current = page;
            page.loadAsync();
            page.status = "active";
            return Promise.resolve(page);
        }
        return this._parentHost.loadAsync(page, options);
    }
    /****************************************/
    find(nameOrType) {
        if (this.current) {
            if ((0,Helpers_TypeCheck/* isString */.HD)(nameOrType) && nameOrType == ObjectUtils_getTypeName(this.current))
                return this.current;
            if (ObjectUtils_getType(this.current) == nameOrType)
                return this.current;
        }
        return this._parentHost.find(nameOrType);
    }
    /****************************************/
    async goToAsync(index) {
        this._parentHost.currentIndex = index;
        return Promise.resolve();
    }
    /****************************************/
    get canGoBack() {
        return this._parentHost.canGoBack;
    }
    /****************************************/
    get currentIndex() {
        return this._parentHost.currentIndex;
    }
    set currentIndex(value) {
        this._parentHost.currentIndex = value;
    }
    /****************************************/
    get pageCount() {
        return this._parentHost.pageCount;
    }
    /****************************************/
    current;
}
ObjectUtils_registerType(Components_SelfHostedPageHost_SelfHostedPageHost, "SelfHostedPageHost");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/Page.js



/****************************************/
class Page_Page extends Templating_BindableObject_BindableObject {
    constructor(config) {
        super();
        this.bindConfig("url", config);
        this.bindConfigString("title", config);
        this.bindConfigString("subTitle", config);
        this.bindConfig("view", config);
        if (config) {
            if (config.name)
                this.name = config.name;
        }
    }
    /****************************************/
    getState() {
        return {};
    }
    /****************************************/
    setState(state) {
    }
    /****************************************/
    handleError(source, error) {
        Core_Global/* App.handleError */.gV.handleError(source, error);
    }
    /****************************************/
    async loadAsync() {
        if (this.status == "notloaded" || this.status == "error") {
            const op = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading page: " + (this.title ? this.title : (this.url ? this.url : ObjectUtils_getTypeName(this))) });
            this.status = "loading";
            try {
                await this.loadWorkAsync();
            }
            catch (e) {
                this.status = "error";
                Core_Global/* App.handleError */.gV.handleError(this, e);
            }
            finally {
                op.end();
                this.status = "loaded";
            }
        }
    }
    /****************************************/
    loadWorkAsync() {
        return Promise.resolve();
    }
    /****************************************/
    refreshAsync() {
        return Promise.resolve();
    }
    /****************************************/
    async closeAsync(result) {
        if ("goBackAsync" in this.host)
            await this.host.goBackAsync();
        this.status = "closed";
        return true;
    }
    /****************************************/
    url = null;
    host = null;
    view = null;
    title = null;
    subTitle = null;
    name = null;
    status = "notloaded";
    args = null;
}
ObjectUtils_registerType(Page_Page, "Page");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ItemsView.js




/********************************************/
class Components_ItemsView_ItemsView extends ContentView_ContentView {
    _updateCount = 0;
    constructor(config) {
        super({ content: Templating_ObservableList_observableListOf(), ...config });
        this.content.subscribe({
            onItemAdded: (item) => {
                if (this._updateCount == 0)
                    this.onItemAdded(item);
            },
            onItemRemoved: (item) => {
                if (this._updateCount == 0)
                    this.onItemRemoved(item);
            }
        });
        this.bindConfig("emptyView", config);
    }
    /********************************************/
    initItems() {
        if (this.content)
            this.content.toArray().forEach(a => this.onItemAdded(a));
    }
    /********************************************/
    beginUpdate() {
        this._updateCount++;
    }
    /********************************************/
    endUpdate() {
        this._updateCount--;
    }
    /********************************************/
    onItemAdded(item) {
    }
    /********************************************/
    onItemRemoved(item) {
    }
    emptyView = null;
}
ObjectUtils_registerType(Components_ItemsView_ItemsView, "ItemsView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/Panel.js





/********************************************/
class Components_Panel_Panel extends Components_ItemsView_ItemsView {
    constructor(config) {
        super({ template: "ItemsView", ...config });
        if (config?.viewContent) {
            if (Array.isArray(config.viewContent))
                config.viewContent.forEach(a => this.addView(a));
            else
                this.addView(config.viewContent);
        }
    }
    /********************************************/
    loadAsync() {
        return ViewUtils_loadAllAsync(this.content);
    }
    /********************************************/
    clear() {
        this.content.clear();
    }
    /********************************************/
    addView(view) {
        this.content.add(view);
        return view;
    }
    /********************************************/
    removeView(view) {
        this.content.remove(view);
    }
    replaceView(oldView, newView) {
        let index;
        if ((0,Helpers_TypeCheck/* isString */.HD)(oldView))
            index = (0,Core_Linq/* linq */.k)(this.content).indexOf(a => "name" in a && a.name == oldView);
        else
            index = this.content.indexOf(oldView);
        if (index != -1)
            this.content.set(index, newView);
    }
    /********************************************/
    onItemAdded(item) {
        if (item)
            item.parentView = this;
    }
    /********************************************/
    onItemRemoved(item) {
        if (item && item.parentView == this)
            item.parentView = null;
    }
}
ObjectUtils_registerType(Components_Panel_Panel, "Panel");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Activities/Activity.js




/****************************************/
class Activity_Activity extends Page_Page {
    _viewItems = [];
    _resultResolve;
    constructor(config) {
        super(config);
        this.view = new Components_Panel_Panel({ name: Helpers_ViewUtils_formatForCss(ObjectUtils_getTypeName(this)), styles: ["vertical", "activity", "page", "relative"] });
        //this.view.isCacheEnabled = true;
        if (this.name)
            this.view.styles.push(this.name);
    }
    /****************************************/
    get result() {
        return new Promise(res => this._resultResolve = res);
    }
    /****************************************/
    activateAsync() {
        return Promise.resolve();
    }
    /****************************************/
    deactivateAsync(reason) {
        return Promise.resolve();
    }
    /****************************************/
    async closeAsync(result) {
        const closeResult = await super.closeAsync(result);
        if (this._resultResolve)
            this._resultResolve(result);
        return closeResult;
    }
    /****************************************/
    loadWorkAsync() {
        return this.createAsync();
    }
    /****************************************/
    createAsync() {
        return Promise.resolve();
    }
    /****************************************/
    static isActivity(obj) {
        return ObjectUtils_isInstanceOf(obj, Activity_Activity);
    }
}
ObjectUtils_registerType(Activity_Activity, "Activity");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/SlidePageHost.js







/****************************************/
class Components_SlidePageHost_SlidePageHost extends Components_View_View {
    _activeViewIndex = 0;
    _pageStack;
    _currentIndex;
    _hideTimerId;
    /****************************************/
    constructor(config) {
        super(config);
        this.pageViews = [{ content: null, className: null },
            { content: null, className: null }];
        this.clearAsync();
        if (config) {
            if (config.defaultTransaction)
                this.defaultTransaction = config.defaultTransaction;
        }
    }
    /****************************************/
    clearAsync() {
        this._pageStack = [];
        this._currentIndex = -1;
        this._activeViewIndex = 0;
        this.pageViews[0].content = null;
        this.pageViews[0].className = "immediate next";
        this.pageViews[1].content = null;
        this.pageViews[1].className = "immediate prev";
    }
    /****************************************/
    async goBackAsync() {
        if (this._currentIndex > 0)
            await this.goToAsync(this._currentIndex - 1);
    }
    /****************************************/
    async goForwardAsync() {
        if (this._currentIndex > 0)
            await this.goToAsync(this._currentIndex + 1);
    }
    /****************************************/
    async bringFrontAsync(page) {
        const pageIndex = (0,Core_Linq/* linq */.k)(this._pageStack).indexOf(a => a.page == page);
        if (pageIndex != -1)
            await page.host.goToAsync(pageIndex);
    }
    /****************************************/
    async loadAsync(page, options) {
        if (this.current == page) {
            await page.refreshAsync();
            return page;
        }
        this.cancelHidePrev();
        const op = Core_Global/* Services.operation.begin */.K9.operation.begin("Hosting new page");
        try {
            if (this.current && Activity_Activity.isActivity(this.current))
                await this.current.deactivateAsync("replace");
            if (options?.loadMode == "clear")
                this._currentIndex = -1;
            if (options?.loadMode == "replace" && this.currentIndex >= 0)
                this._currentIndex--;
            while (this._pageStack.length > this._currentIndex + 1)
                this._pageStack.splice(this._pageStack.length - 1, 1);
            this._pageStack.push({ page: page, options: options });
            if (options && options.transaction)
                this.activeTransaction = options.transaction;
            else
                this.activeTransaction = this.defaultTransaction;
            this._currentIndex++;
            page.host = this;
            page.view.parentView = this;
            this.pageViews[this.backIndex].className = "immediate next";
            await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
            await page.loadAsync();
            if (this._currentIndex > 0) {
                this.pageViews[this.backIndex].content = page.view;
                await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
                this.pageViews[this.frontIndex].className = "animate prev";
                this.pageViews[this.backIndex].className = "animate active";
                this._activeViewIndex = this.backIndex;
                this.hidePrev();
            }
            else {
                this.pageViews[this.frontIndex].content = page.view;
                this.pageViews[this.frontIndex].className = "active";
            }
            page.status = "active";
            if (Activity_Activity.isActivity(this.current))
                await this.current.activateAsync();
        }
        catch (e) {
            Core_Global/* App.handleError */.gV.handleError(this, e);
        }
        finally {
            op.end();
        }
        return page;
    }
    /****************************************/
    get(index) {
        return this._pageStack[index].page;
    }
    /****************************************/
    async goToAsync(index) {
        if (index < 0 || index >= this._pageStack.length || index == this._currentIndex)
            return;
        this.cancelHidePrev();
        const op = Core_Global/* Services.operation.begin */.K9.operation.begin("Going to " + index);
        try {
            if (Activity_Activity.isActivity(this.current))
                await this.current.deactivateAsync("replace");
            this.current.status = "hidden";
            const options = this._pageStack[this._currentIndex].options;
            if (options && options.transaction)
                this.activeTransaction = options.transaction;
            else
                this.activeTransaction = this.defaultTransaction;
            this._currentIndex = index;
            if (this.current.view.parentView == this)
                this.current.view.parentView = null;
            this.pageViews[this.backIndex].content = this._pageStack[this._currentIndex].page.view;
            this.pageViews[this.backIndex].className = "immmediate prev";
            await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
            this.pageViews[this.frontIndex].className = "animate next";
            this.pageViews[this.backIndex].className = "animate active";
            this._activeViewIndex = this.backIndex;
            this.current.status = "active";
            if (Activity_Activity.isActivity(this.current))
                await this.current.activateAsync();
            this.hidePrev();
        }
        catch (e) {
            Core_Global/* App.handleError */.gV.handleError(this, e);
        }
        finally {
            op.end();
        }
    }
    /****************************************/
    cancelHidePrev() {
        if (this._hideTimerId) {
            clearTimeout(this._hideTimerId);
            this._hideTimerId = null;
        }
    }
    /****************************************/
    hidePrev() {
        this._hideTimerId = window.setTimeout(() => {
            if (!this._hideTimerId)
                return;
            this.pageViews[this.backIndex].className = "prev hide";
        }, 4000);
    }
    /****************************************/
    onActivePageChanged() {
    }
    /****************************************/
    onTransactionEnd() {
    }
    find(nameOrType) {
        let curPage;
        if (typeof nameOrType == "string")
            curPage = (0,Core_Linq/* linq */.k)(this._pageStack).first(a => a.page.name == nameOrType);
        else
            curPage = (0,Core_Linq/* linq */.k)(this._pageStack).first(a => Object.getPrototypeOf(a.page).constructor == nameOrType);
        if (curPage)
            return curPage.page;
    }
    /****************************************/
    get current() {
        return this._currentIndex == -1 ? undefined : this._pageStack[this._currentIndex].page;
    }
    /****************************************/
    get canGoBack() {
        return this._currentIndex > 0;
    }
    /****************************************/
    get frontIndex() {
        return this._activeViewIndex;
    }
    /****************************************/
    get backIndex() {
        return (this._activeViewIndex + 1) % 2;
    }
    /****************************************/
    get currentIndex() {
        return this._currentIndex;
    }
    set currentIndex(value) {
        if (this._currentIndex == value)
            return;
        this.goToAsync(value);
    }
    /****************************************/
    get pageCount() {
        return this._pageStack.length;
    }
    /****************************************/
    defaultTransaction = "pop-up-down";
    activeTransaction = "none";
    pageViews;
}
ObjectUtils_registerType(Components_SlidePageHost_SlidePageHost, "SlidePageHost");

// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Services/DynamicPageManager.js
var View_Services_DynamicPageManager = __webpack_require__(8349);
;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/AllTemplates.js



















































;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Abstraction/IGestureListener.js
var Abstraction_IGestureListener_GestureType;
(function (GestureType) {
    GestureType[GestureType["SwipeLeft"] = 0] = "SwipeLeft";
})(Abstraction_IGestureListener_GestureType || (Abstraction_IGestureListener_GestureType = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Behavoirs/GestureBehavoir.js

class Behavoirs_GestureBehavoir_GesturekBehavoir {
    _onPointerUpBind = this.onPointerUp.bind(this);
    _onPointerDownBind = this.onPointerDown.bind(this);
    _onPointerMoveBind = this.onPointerMove.bind(this);
    _downPoint;
    _element;
    _listener;
    attach(element, viewModel) {
        this._element = element;
        this._listener = viewModel;
        this._element.addEventListener("pointerdown", this._onPointerDownBind, { passive: true });
    }
    /****************************************/
    onPointerUp(ev) {
        this.endGesture(ev);
    }
    /****************************************/
    onPointerDown(ev) {
        this._downPoint = this.getPoint(ev);
        this._element.addEventListener("pointerup", this._onPointerUpBind, { passive: true });
        this._element.addEventListener("pointermove", this._onPointerMoveBind, { passive: true });
        //this._element.setPointerCapture(ev.pointerId);
    }
    /****************************************/
    onPointerMove(ev) {
        const point = this.getPoint(ev);
        const angle = ((Math.atan2(point.y - this._downPoint.y, point.x - this._downPoint.x) * 180 / Math.PI) + 360) % 360;
        const distance = Math.sqrt(Math.pow(point.y - this._downPoint.y, 2) + Math.pow(point.x - this._downPoint.x, 2));
        //console.log(point, ev.button, angle, distance);
        if (distance > 70) {
            if (angle > 150 && angle < 220)
                this._listener.onGesture({ type: GestureType.SwipeLeft });
            this.endGesture(ev);
        }
    }
    /****************************************/
    getPoint(ev) {
        return {
            x: ev.screenX,
            y: ev.screenY
        };
    }
    /****************************************/
    endGesture(ev) {
        //this._element.releasePointerCapture(ev.pointerId);
        this._element.removeEventListener("pointerup", this._onPointerUpBind);
        this._element.removeEventListener("pointermove", this._onPointerMoveBind);
    }
    /****************************************/
    detach(element, viewModel) {
        element.removeEventListener("pointerdown", this._onPointerDownBind);
        element.removeEventListener("pointermove", this._onPointerMoveBind);
        element.removeEventListener("pointerup", this._onPointerUpBind);
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Behavoirs/ContextMenuBehavoir.js


/****************************************/
class Behavoirs_ContextMenuBehavoir_ContextMenuBehavoir {
    attach(element, viewModel) {
        const showMenu = (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            ev.stopImmediatePropagation();
            const items = viewModel.getContextActions();
            if (items) {
                const menu = new Components_ContextMenu_ContextMenu({ actions: items });
                menu.showAsync(null, ev);
            }
        };
        if (DomUtils_isTouchDevice())
            element.addEventListener("selectstart", ev => {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                return false;
            });
        element.addEventListener("contextmenu", ev => showMenu(ev));
    }
    /****************************************/
    detach(element) {
    }
    static instance = new Behavoirs_ContextMenuBehavoir_ContextMenuBehavoir();
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/ViewApplication.js
;
























class ViewApplication_ViewApplication extends (/* unused pure expression or super */ null && (BindableObject)) {
    _blockCount = 0;
    _blocker;
    _startupArgs;
    constructor() {
        super();
        this.prop("language").subscribe(() => this.updateLanguage());
    }
    /****************************************/
    async runAsync(args) {
        this.language = (window.navigator.language).split("-")[0].toUpperCase();
        window.addEventListener("error", ev => this.handleError(ev.srcElement, ev.error, ev.message));
        this._startupArgs = { baseUrl: "", ...args };
        if (this.baseUrl.length == 0 || this.baseUrl[this.baseUrl.length - 1] != "/")
            this.baseUrl += "/";
        this.initServices();
        await this.configureServicesAsync();
        if (this.isSelfHosted) {
            this.pageHost = new SelfHostedPageHost();
            this.view = this.pageHost;
            //window["WebApp"]["Actions"] = window.parent["WebApp"]["Actions"];
        }
        else {
            this.pageHost = new HistoryPageHost(this.createPageHost());
            this.view = this.pageHost.innerHost;
        }
        Services.pageHost = this.pageHost;
        document.title = this.appName;
        template(document.body, this.view.template, this.view);
        this.onStarted();
    }
    /****************************************/
    updateLanguage() {
        document.documentElement.lang = this.language;
        StringTable.currentConfig = {
            language: this.language
        };
    }
    /****************************************/
    onStarted() {
    }
    /****************************************/
    handleError(source, error, message) {
        console.error("Source: ", source, "Error: ", error, "Message: ", message);
    }
    /****************************************/
    formatTitle(title) {
        if (this.appName && title)
            return this.appName + " - " + title;
        if (title)
            return title;
        return this.appName;
    }
    /****************************************/
    createPageHost() {
        return new SlidePageHost();
    }
    /****************************************/
    initServices() {
        Services.application = this;
        Services.pageManager = new DynamicPageManager();
        Services.itemsObserver = new ItemsObserver();
        Services.httpClient = new XHRHttpClient();
        Services.cache = new LocalStorageCache();
        Services.dbStorage = new DbStorage();
        Services.operation = new ViewOperationManager();
        if (this.startupArgs.gaId)
            Services.analytics = new GoogleAnalytics(this.startupArgs.gaId);
        behavoirCatalog["attach"] = () => AttachBehavoir.instance;
        behavoirCatalog["ripple"] = () => RippleClickBehavoir.instance;
        behavoirCatalog["vibrate"] = () => VibrateClickBehavoir.instance;
        behavoirCatalog["scroll-check"] = () => ScrollCheckBehavoir.instance;
        behavoirCatalog["long-press"] = () => new LongPressBehavoir();
        behavoirCatalog["gesture"] = () => new GesturekBehavoir();
        behavoirCatalog["context-menu"] = () => ContextMenuBehavoir.instance;
    }
    /****************************************/
    configureServicesAsync() {
        return Promise.resolve();
    }
    /****************************************/
    block(content) {
        this._blockCount++;
        if (!this._blocker) {
            this._blocker = new Blocker();
            setTimeout(() => this.restoreBlock(content));
        }
        else
            this.restoreBlock(content);
    }
    /****************************************/
    restoreBlock(content) {
        if (this._blockCount > 0 && this._blocker.status != "show" && this._blocker.status != "showing")
            this._blocker.showAsync(content);
        else if (content)
            this._blocker.content = content;
    }
    /****************************************/
    unblock(force = false) {
        if (!this._blocker)
            return;
        if (force) {
            if (this._blocker.status == "show" || this._blocker.status == "showing")
                this._blocker.hideAsync();
        }
        else {
            if (--this._blockCount <= 0)
                this._blocker.hideAsync();
        }
    }
    /****************************************/
    mainAsync() {
        return Promise.resolve(null);
    }
    /****************************************/
    get baseUrl() {
        return this._startupArgs.baseUrl;
    }
    get isDev() {
        return this._startupArgs["env"] == "Development";
    }
    set baseUrl(value) {
        this._startupArgs.baseUrl = value;
    }
    get startupArgs() {
        return this._startupArgs;
    }
    get isSelfHosted() {
        try {
            return window.parent != window && window.parent["WebApp"] && window.parent["WebApp"]["App"];
        }
        catch (e) {
            return false;
        }
    }
    get hasMain() {
        return false;
    }
    pageHost = null;
    appName = null;
    view = null;
    language = null;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Abstraction/IAction.js
var Abstraction_IAction_ActionPriority;
(function (ActionPriority) {
    ActionPriority[ActionPriority["Primary"] = 0] = "Primary";
    ActionPriority[ActionPriority["Secondary"] = 1] = "Secondary";
    ActionPriority[ActionPriority["Evidence"] = 2] = "Evidence";
})(Abstraction_IAction_ActionPriority || (Abstraction_IAction_ActionPriority = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Abstraction/IPageHost.js
var IPageHost_PageHostMode;
(function (PageHostMode) {
    PageHostMode[PageHostMode["Default"] = 0] = "Default";
    PageHostMode[PageHostMode["WebView"] = 1] = "WebView";
})(IPageHost_PageHostMode || (IPageHost_PageHostMode = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ActionBar.js







/****************************************/
class Components_ActionBar_ActionBar extends ViewComponent_ViewComponent {
    constructor(config) {
        super(config);
        this.bindConfig("mainAction", config);
        this.bindConfig("navigationMenu", config);
        this.bindConfigString("title", config, Types_DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfig("icon", config);
        this.actions.subscribe({
            onItemAdded: this.onActionAdded.bind(this),
            onItemRemoved: this.onActionRemoved.bind(this)
        });
        if (config) {
            if (config.content)
                this.content = config.content;
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
            if (config.onBack)
                this.back = config.onBack;
        }
    }
    /****************************************/
    onActionRemoved(action) {
        if (action && action.parentView == this)
            action.parentView = null;
    }
    /****************************************/
    onActionAdded(action) {
        if (action)
            action.parentView = this;
    }
    /****************************************/
    async showNavigationMenu() {
        if (this.navigationMenu)
            this.navigationMenu.showAsync();
    }
    /****************************************/
    addAction(action) {
        this.actions.add(Components_ActionView_ActionView.fromActionIcon(action));
    }
    /****************************************/
    back() {
    }
    /****************************************/
    startSelection() {
        if (!this.selectionManager)
            this.selectionManager = new SelectionManager_SelectionManager();
        this.selectionManager.isActive = true;
        return this.selectionManager;
    }
    /****************************************/
    actions = Templating_ObservableList_observableListOf();
    mainAction = "none";
    navigationMenu = null;
    title = null;
    icon = null;
    content = null;
    selectionManager = null;
}
ObjectUtils_registerType(Components_ActionBar_ActionBar, "ActionBar");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/NavBar.js





/****************************************/
class NavBar_NavBarItem extends Components_IconTextView_IconTextView {
    constructor(config) {
        super(config);
        this.prop("status");
        this.bindConfig("badge", config);
        this.bindConfig("behavoirs", config);
        this.bindConfig("content", config);
        if (config)
            this.name = config.name;
    }
    /****************************************/
    select() {
        throw "Not implemented";
    }
    /****************************************/
    name = null;
    status = "";
    badge = null;
    behavoirs = [];
    content = null;
}
/****************************************/
class Components_NavBar_NavBar extends Components_ItemsView_ItemsView {
    constructor(config) {
        super(config);
        this.bindConfig("itemTemplate", config);
        this.bindConfig("itemBehavoirs", config);
        if (config) {
            if (config.items)
                config.items.forEach(a => this.addItem(a));
            if (config.onItemSelected) {
                this.onSelectedItemChanged = (a, b) => {
                    Components_NavBar_NavBar.prototype.onSelectedItemChanged.bind(this)(a, b);
                    config.onItemSelected(a);
                };
            }
        }
        this.bindConfig("selectedItem", config, {
            convertTo: a => this.getItem(a),
            convertFrom: a => a ? a.name : undefined
        }, this.onSelectedItemChanged);
    }
    /****************************************/
    getItem(name) {
        return (0,Core_Linq/* linq */.k)(this.content).first(a => a.name == name);
    }
    /****************************************/
    selectItem(name) {
        this.selectedItem = this.getItem(name);
    }
    /****************************************/
    addItem(config) {
        const item = this.createItem(config);
        this.content.add(item);
        return item;
    }
    /****************************************/
    createItem(config) {
        const item = new NavBar_NavBarItem({ template: this.prop("itemTemplate"), behavoirs: this.prop("itemBehavoirs"), ...config });
        item.parentView = this;
        item.select = () => this.selectedItem = item;
        return item;
    }
    /****************************************/
    onSelectedItemChanged(newItem, oldItem) {
        if (oldItem)
            oldItem.status = "";
        if (newItem)
            newItem.status = "active";
    }
    /****************************************/
    selectedItem = null;
    itemTemplate = "IconTextView";
    itemBehavoirs = [];
}
ObjectUtils_registerType(NavBar_NavBarItem, "NavBarItem");
ObjectUtils_registerType(Components_NavBar_NavBar, "NavBar");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/SearchView.js



/****************************************/
class Components_SearchView_SearchView extends Components_ActionView_ActionView {
    _lastSearchText = null;
    /****************************************/
    constructor(config) {
        super({
            name: "search",
            template: "SearchView",
            content: "fas fa-search",
            tooltip: "Ricerca",
            ...config
        });
        this.bindConfig("isExpanded", config);
        this.bindConfig("searchText", config);
        this.prop("hasFocus").subscribe(value => this.onFocusChanged(value));
        if (config) {
            if (config.poolInterval)
                this.poolInterval = config.poolInterval;
            if (config.searchAsync)
                this.doSearchAsync = config.searchAsync;
        }
    }
    /****************************************/
    onFocusChanged(value) {
        if (value) {
            this._lastSearchText = this.searchText;
            this.poolSearchTextAsync();
        }
    }
    /****************************************/
    async poolSearchTextAsync() {
        while (this.hasFocus) {
            if (this.searchText != this._lastSearchText) {
                this._lastSearchText = this.searchText;
                await this.searchAsync(this._lastSearchText);
            }
            await (0,Utils_PromiseUtils/* delayAsync */.$)(this.poolInterval);
        }
    }
    /****************************************/
    executeWorkAsync() {
        if (!this.isExpanded) {
            this.isExpanded = true;
            this.hasFocus = true;
        }
        return Promise.resolve();
    }
    /****************************************/
    async searchAsync(text) {
        this.status = "searching";
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        try {
            await this.doSearchAsync(text);
        }
        finally {
            this.status = "loaded";
        }
    }
    /****************************************/
    doSearchAsync(text) {
        return Promise.resolve();
    }
    /****************************************/
    clear() {
        this.searchText = "";
    }
    /****************************************/
    close() {
        this.isExpanded = false;
    }
    /****************************************/
    searchText = null;
    isExpanded = false;
    hasFocus = false;
    poolInterval = 200;
}
ObjectUtils_registerType(Components_SearchView_SearchView, "SearchView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Activities/ContentActivity.js












var ContentActivity_ContentSelector;
(function (ContentSelector) {
    ContentSelector[ContentSelector["Manual"] = 1] = "Manual";
    ContentSelector[ContentSelector["Tabs"] = 2] = "Tabs";
    ContentSelector[ContentSelector["BottomNav"] = 3] = "BottomNav";
})(ContentActivity_ContentSelector || (ContentActivity_ContentSelector = {}));
var ContentActivity_PrimaryActionMode;
(function (PrimaryActionMode) {
    PrimaryActionMode[PrimaryActionMode["Floating"] = 1] = "Floating";
    PrimaryActionMode[PrimaryActionMode["Button"] = 2] = "Button";
    PrimaryActionMode[PrimaryActionMode["FloatingFull"] = 3] = "FloatingFull";
})(ContentActivity_PrimaryActionMode || (ContentActivity_PrimaryActionMode = {}));
/****************************************/
class Activities_ContentActivity_ContentActivity extends Activity_Activity {
    _actionBar;
    _contentView;
    _floatingView;
    _isContentLoaded = false;
    _navBar;
    _selector = ContentActivity_ContentSelector.Tabs;
    _isDeactivating = false;
    /****************************************/
    constructor(config) {
        super({
            ...config
        });
        this.bindConfig("activeContent", config);
        if (config.providers)
            this.providers = config.providers;
        if (config.menu)
            this.menu = config.menu;
        if (config.selector)
            this._selector = config.selector;
        if (config.actions)
            this.actions = config.actions;
        this.prop("host").subscribe(() => {
            if (this._actionBar?.mainAction == "none" && this.host?.canGoBack)
                this._actionBar.mainAction = "back";
        });
    }
    /****************************************/
    async closeAsync(result) {
        await this.deactivateAsync("close");
        return await super.closeAsync(result);
    }
    /****************************************/
    activateAsync() {
        if (!this._isContentLoaded)
            return this.refreshAsync();
        if (this.activeContentProvider?.activateAsync)
            return this.activeContentProvider?.activateAsync("refresh");
        return Promise.resolve();
    }
    /****************************************/
    async deactivateAsync(reason) {
        if (this._isDeactivating)
            return;
        try {
            this._isDeactivating = true;
            if (this.activeContentProvider?.deactivateAsync)
                await this.activeContentProvider.deactivateAsync(reason);
        }
        finally {
            this._isDeactivating = false;
        }
    }
    /****************************************/
    refreshAsync() {
        if (this.activeContentProvider)
            return this.loadContentAsync(this.activeContentProvider, true);
        return this.loadActiveContentAsync(true);
    }
    /****************************************/
    notifyContentChanged(provider) {
        this.loadContentAsync(provider, true);
    }
    /****************************************/
    startSelection() {
        return this._actionBar.startSelection();
    }
    /****************************************/
    loadActiveContentAsync(force) {
        const provider = (0,Core_Linq/* linq */.k)(this.providers).first(a => a.info.name == this.activeContent);
        return this.loadContentAsync(provider, force);
    }
    /****************************************/
    async loadWorkAsync() {
        await this.createAsync();
        if (this.activeContentProvider)
            this.activeContent = this.activeContentProvider.info.name;
    }
    /****************************************/
    async loadContentAsync(provider, force) {
        const isContentChanged = this.activeContentProvider != provider;
        if (!isContentChanged && !force)
            return;
        if (isContentChanged && this.activeContentProvider?.deactivateAsync)
            this.activeContentProvider?.deactivateAsync("replace");
        this.activeContentProvider = provider;
        if (!force && (this.status == "notloaded" || this.status == "loading" || this.status == "closed")) {
            console.debug("Skip loading content: " + provider.info.name);
            return;
        }
        const op = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading content: " + provider.info.name });
        try {
            const content = await provider.getContentAsync(this);
            this.title = this.formatTitle(Core_Helpers_Format/* Format.title */.E.title(content.title));
            if (content.url)
                this.url = content.url;
            this._contentView.clear();
            this._contentView.styles = ArrayUtils_mergeArrays(content.styles ?? this.contentStyle, ["activity-content"]);
            this._contentView.name = provider.info.name;
            this._contentView.buildStyles();
            if (content.views)
                content.views.forEach(a => this._contentView.addView(a));
            this._actionBar.actions.clear();
            if (this._floatingView)
                this._floatingView.clear();
            let actionPanel;
            if (content.actions) {
                content.actions.forEach(action => {
                    if (action.priority == null || action.priority == Abstraction_IAction_ActionPriority.Secondary)
                        this._actionBar.actions.add(this.createActionView(action));
                    else if (action.priority == Abstraction_IAction_ActionPriority.Primary) {
                        if (content.actionMode === undefined || content.actionMode != ContentActivity_PrimaryActionMode.Button) {
                            this._floatingView.visible = true;
                            this._floatingView.addView(this.createActionView(action, { styles: ["floating", ...action.styles ?? []] }));
                            if (content.actionMode == ContentActivity_PrimaryActionMode.FloatingFull)
                                this._floatingView.addStyle("full");
                            else
                                this._floatingView.removeStyle("full");
                        }
                        else {
                            this._floatingView.visible = false;
                            const actionView = Components_ActionView_ActionView.fromAction(action, { template: "ActionButton" });
                            if (!actionPanel) {
                                actionPanel = new Components_Panel_Panel({
                                    name: "actions",
                                    styles: ["vertical", "margin-items-v"],
                                });
                                this._contentView.addView(actionPanel);
                            }
                            actionPanel.addView(actionView);
                        }
                    }
                });
            }
            if (content.searchAsync) {
                const searchView = new Components_SearchView_SearchView({
                    name: "search-expanded",
                    isExpanded: true,
                    searchAsync: content.searchAsync
                });
                this._actionBar.actions.add(searchView);
            }
            this._floatingView.visible = this._floatingView.content.count > 0;
            this.actions.forEach(a => this._actionBar.actions.add(a));
            await this._contentView.loadAsync();
            if (provider?.activateAsync)
                await provider.activateAsync("loading");
            this.onContentChanged(provider);
            this._isContentLoaded = true;
        }
        catch (e) {
            this.handleError(this, e);
        }
        finally {
            op.end();
        }
    }
    /****************************************/
    getAction(name) {
        return (0,Core_Linq/* linq */.k)(this._floatingView.content).first(a => a instanceof Components_ActionView_ActionView && a.name == name);
    }
    /****************************************/
    formatTitle(value) {
        return value;
    }
    /****************************************/
    createAsync() {
        if (this.menu) {
            this._actionBar = this.view.addView(new Components_ActionBar_ActionBar({
                title: this.prop("title"),
                mainAction: "menu",
                navigationMenu: this.menu
            }));
        }
        else {
            this._actionBar = this.view.addView(new Components_ActionBar_ActionBar({
                onBack: () => this.closeAsync(),
                title: this.prop("title"),
                mainAction: this.host.canGoBack ? "back" : "none"
            }));
        }
        if (this.providers.length > 1) {
            if (this._selector == ContentActivity_ContentSelector.Manual) {
                this.prop("activeContent").subscribe(() => this.loadActiveContentAsync(false));
            }
            else {
                let navStyle;
                let itemTemplate;
                let itemBehavoirs;
                switch (this._selector) {
                    case ContentActivity_ContentSelector.Tabs:
                        navStyle = "tab-view";
                        itemTemplate = "TextView";
                        itemBehavoirs = ["ripple"];
                        break;
                    case ContentActivity_ContentSelector.BottomNav:
                        navStyle = "bottom-nav";
                        itemTemplate = "IconTextView";
                        itemBehavoirs = ["ripple"];
                        break;
                }
                this._navBar = new Components_NavBar_NavBar({
                    styles: [navStyle],
                    itemTemplate: itemTemplate,
                    onItemSelected: a => this.loadContentAsync(a.content, false),
                    selectedItem: this.prop("activeContent"),
                    itemBehavoirs: itemBehavoirs,
                    items: (0,Core_Linq/* linq */.k)(this.providers).select(a => ({
                        name: a.info.name,
                        icon: a.info.icon,
                        text: a.info.displayName,
                        content: a
                    })).toArray()
                });
            }
        }
        if (this._navBar && this._selector == ContentActivity_ContentSelector.Tabs)
            this.view.addView(this._navBar);
        this._contentView = this.view.addView(new Components_Panel_Panel({ styles: this.contentStyle }));
        if (this._navBar && this._selector == ContentActivity_ContentSelector.BottomNav)
            this.view.addView(this._navBar);
        this._floatingView = this.view.addView(new Components_Panel_Panel({ name: "floating-container", template: "ItemsViewWrapped", visible: false, styles: this.floatingStyle }));
        if (this.providers.length == 1)
            this.activeContentProvider = this.providers[0];
        this.status = "created";
        return Promise.resolve();
    }
    /****************************************/
    createActionView(action, config) {
        return Components_ActionView_ActionView.fromAction(action, config);
    }
    /****************************************/
    onContentChanged(newContent) {
    }
    /****************************************/
    get actionBar() { return this._actionBar; }
    activeContent = null;
    activeContentProvider = null;
    providers = [];
    menu = null;
    actions = [];
    floatingStyle = ["vertical", "item-absolute", "bottom", "fill-h", "center-items-h"];
    contentStyle = ["vertical", "scroll"];
}
ObjectUtils_registerType(Activities_ContentActivity_ContentActivity, "ContentActivity");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Items/FulltemsLoader.js



class FulltemsLoader_FullItemsLoader {
    async loadItemsAsync(container, chunkSize) {
        container.status = "loading";
        const operation = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading items", type: Abstraction_IOperation_OperationType.Local });
        try {
            const items = await container.itemsSource.getItemsAsync(container.filter);
            container.clear();
            if (items)
                await ArrayUtils_forEachAsync(items, chunkSize, a => container.addItem(a));
        }
        finally {
            operation.end();
            container.status = "loaded";
        }
    }
    static instance = new FulltemsLoader_FullItemsLoader();
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/TextView.js



/********************************************/
class Components_TextView_TextView extends ContentView_ContentView {
    constructor(config) {
        super({ template: "TextContent", ...config });
    }
}
ObjectUtils_registerType(Components_TextView_TextView, "TextView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ListView.js









/****************************************/
class Components_ListView_ListView extends Components_ItemsView_ItemsView {
    _isLoaded = false;
    _itemViewMap = new Map();
    _listener;
    constructor(config) {
        super({ template: "ListView", styles: ["default"], ...config });
        this.bindConfig("itemsSource", config);
        this.bindConfig("items", config);
        this.bindConfig("filter", config);
        this.bindConfig("selectionMode", config);
        if (config) {
            if (config.itemsLoader)
                this.itemsLoader = config.itemsLoader;
            if (config.showSeparator !== undefined)
                this.showSeparator = config.showSeparator;
            if (config.createItemView)
                this.createItemViewWork = config.createItemView;
            if (config.header)
                this.header.addRange(config.header);
            if (config.footer)
                this.footer.addRange(config.footer);
        }
        if (!config?.items)
            this.items = Templating_ObservableList_observableListOf();
        if (!this.itemsLoader && this.itemsSource)
            this.itemsLoader = FulltemsLoader_FullItemsLoader.instance;
        if (config && config.isAutoLoad)
            this.loadAsync();
        const itemsHandler = {
            onClear: () => {
                this.selectedItem = null;
                this._itemViewMap.clear();
                this.content.clear();
            },
            onItemAdded: (item, index, reason) => {
                if (reason != "replace")
                    this.content.insert(index, this.createItemView(item));
            },
            onItemRemoved: (item, index, reason) => {
                if (reason == "remove")
                    this.content.removeAt(index);
            },
            onItemReplaced: (newItem, oldItem, index) => this.content.set(index, this.createItemView(newItem)),
            onItemSwap: (index, newIndex) => this.content.swap(index, newIndex),
        };
        this.prop("items").subscribe((value, oldValueX) => {
            if (oldValueX != null)
                oldValueX.unsubscribe(itemsHandler);
            this.content.clear();
            if (value) {
                value.subscribe(itemsHandler);
                for (const item of value)
                    this.content.add(this.createItemView(item));
                this.status = "loaded";
            }
        });
        this.prop("items").notifyChanged();
        this.prop("selectedItem").subscribe((value, oldValue) => {
            if (this.selectionMode == "single")
                this.updateItemSelection(oldValue, false);
            if (this.selectionMode != "none") {
                this.updateItemSelection(value, true);
                if (config?.onSelectdItemChanged)
                    config.onSelectdItemChanged(value);
            }
        });
        if (config?.isListenerActive)
            this.activateListener();
    }
    /****************************************/
    activateListener() {
        if (!this.itemsSource?.typeName)
            return;
        if (!this._listener)
            this._listener = {
                onItemAdded: args => this.refreshAsync(),
                onItemRemoved: args => {
                    if (args.value)
                        this.items.removeWhen(a => this.itemsSource.equals(this.itemsSource.getItemValue(a), args.value));
                },
                onItemChanged: async (args) => {
                    const index = (0,Core_Linq/* linq */.k)(this.items).indexOf(a => this.itemsSource.equals(this.itemsSource.getItemValue(a), args.value));
                    if (index != -1) {
                        const newItem = await this.itemsSource.getItemByValueAsync(args.value);
                        if (newItem)
                            this.items.set(index, newItem);
                    }
                }
            };
        Core_Global/* Services.itemsObserver.register */.K9.itemsObserver.register(this.itemsSource.typeName, this._listener);
    }
    /****************************************/
    deactivateListener() {
        if (this._listener)
            Core_Global/* Services.itemsObserver.unregister */.K9.itemsObserver.unregister(this.itemsSource.typeName, this._listener);
    }
    /****************************************/
    updateItemSelection(item, isSelected) {
        const view = this.findItemView(item);
        if (TypeCheck_isSelectable(view))
            view.isSelected = isSelected;
    }
    /****************************************/
    findItemView(item) {
        if (!item)
            return null;
        return (0,Core_Linq/* linq */.k)(this._itemViewMap.entries()).where(a => a[1] == item).select(a => a[0]).first();
    }
    /****************************************/
    removeItem(item) {
        this.items.remove(item);
    }
    /****************************************/
    addItem(item, index) {
        if (index !== undefined) {
            this.items.insert(index, item);
            return this.content.get(index);
        }
        else {
            this.items.add(item);
            return this.content.last;
        }
    }
    /****************************************/
    clear() {
        this.items.clear();
    }
    /****************************************/
    async loadAsync() {
        if (this._isLoaded)
            return;
        await this.refreshAsync(); //TODO await added on 28/09/2021
    }
    /****************************************/
    async refreshAsync() {
        let oldSelection = this.selectedItem;
        if (this.itemsLoader) {
            this.beginUpdate();
            await this.itemsLoader.loadItemsAsync(this, 25);
            if (!oldSelection && this.selectedItem)
                oldSelection = this.selectedItem;
            this.endUpdate();
        }
        this._isLoaded = true;
        if (oldSelection && this.itemsSource)
            this.selectedItem = (0,Core_Linq/* linq */.k)(this.items).first(a => this.itemsSource.itemComparer(a, oldSelection));
        else
            this.selectedItem = null;
    }
    /********************************************/
    onItemRemoved(itemView) {
        if (itemView) {
            if (itemView.parentView == this)
                itemView.parentView = null;
            const item = this._itemViewMap.get(itemView);
            if (item == this.selectedItem)
                this.selectedItem = null;
            this._itemViewMap.delete(itemView);
            //TODO remove selection
            /*
            if (ViewUtils.isSelectable(itemView))
                itemView.prop("isSelected").unsubscribe(this.selectionHandler);*/
        }
    }
    /****************************************/
    createItemView(item) {
        const itemView = this.createItemViewWork(item);
        if ((this.status == "loading" || this.status == "loaded") && TypeCheck_isAsyncLoad(itemView)) {
            itemView.loadAsync(); //Not awaited
        }
        if (itemView) {
            itemView.parentView = this;
            this._itemViewMap.set(itemView, item);
            if (TypeCheck_isSelectable(itemView))
                itemView.prop("isSelected").subscribe(value => {
                    if (value)
                        this.selectedItem = item;
                });
        }
        return itemView;
    }
    /****************************************/
    createItemViewWork(item) {
        const factory = Core_Global/* Services.views */.K9.views[ObjectUtils_getTypeName(item)];
        if (factory)
            return factory(item);
        return new Components_TextView_TextView({ content: this.itemsSource ? this.itemsSource.getItemText(item) : item.toString() });
    }
    /****************************************/
    onScroll(data) {
        if (this.itemsLoader && "onScroll" in this.itemsLoader)
            this.itemsLoader.onScroll(data);
    }
    /****************************************/
    get itemsCount() { return this.content.count; }
    get isScrollCheckActive() { return this.itemsLoader && "onScroll" in this.itemsLoader; }
    header = Templating_ObservableList_observableListOf();
    footer = Templating_ObservableList_observableListOf();
    itemsSource = null;
    itemsLoader = null;
    items = null;
    selectedItem = null;
    status = "";
    selectionMode = "none";
    showSeparator = false;
    filter = null;
}
ObjectUtils_registerType(Components_ListView_ListView, "ListView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Items/Item.js

/****************************************/
class Item_Item {
    static create(options) {
        let newValue = options.value;
        if (typeof newValue == "string")
            newValue = new String(newValue);
        else if (typeof newValue == "number")
            newValue = new Number(newValue);
        else if (typeof newValue == "boolean")
            newValue = new Boolean(newValue);
        else if (newValue instanceof Date)
            newValue = new Date(newValue.getTime());
        if (options.item) {
            options.item.valueOf = () => options.value;
            if (options.value)
                options.item["toJSON"] = () => options.value;
            if (options.text)
                options.item.toString = () => options.text;
            if (options.type)
                options.item["$type"] = () => options.type;
        }
        if (newValue) {
            if (options.text)
                newValue.toString = () => options.text;
            if (options.type)
                ObjectUtils_setTypeName(newValue, options.type);
            if (options.item !== undefined)
                ObjectUtils_set(newValue, "@item", options.item);
            newValue["toJSON"] = () => {
                if (options.value?.toJSON)
                    return options.value.toJSON();
                return options.value;
            };
        }
        if (newValue)
            return newValue;
        return options.item;
    }
    /****************************************/
    static getText(value) {
        if (value == null || value == undefined)
            return "";
        const item = this.getItem(value);
        if (item !== value)
            return item.toString();
        return value.toString();
    }
    /****************************************/
    static getType(value) {
        return ObjectUtils_getTypeName(value);
    }
    /****************************************/
    static getValue(value) {
        if (!value)
            return;
        if (value.valueOf)
            return value.valueOf();
        return value;
    }
    /****************************************/
    static getItem(value) {
        if (!value)
            return;
        const item = ObjectUtils_get(value, "@item");
        if (item)
            return item;
        return undefined;
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Items/ItemsSource.js

/****************************************/
class Items_ItemsSource_ItemsSource {
    _typeName;
    _allowZero;
    constructor(config) {
        if (config) {
            if (config.getItemsAsync)
                this.getItemsAsync = config.getItemsAsync;
            if (config.allowZero !== undefined)
                this._allowZero = config.allowZero;
            if (config.getItemValue)
                this.getItemValue = (a, bindItem) => {
                    if (bindItem === false)
                        return config.getItemValue(a);
                    if (!a && (a !== 0 || !config.allowZero))
                        return undefined;
                    const value = config.getItemValue(a);
                    if (value === null)
                        return null;
                    return Item_Item.create({ type: this.typeName, value: value, text: this.getItemText(a), item: a });
                };
            if (config.getItemText)
                this.getItemText = config.getItemText;
            if (config.getFilter)
                this.getFilter = config.getFilter;
            if (config.getItemByValueAsync) {
                this.getItemByValueAsync = value => {
                    const item = Item_Item.getItem(value);
                    if (item)
                        return Promise.resolve(item);
                    return config.getItemByValueAsync(value);
                };
            }
            if (config.equals)
                this.equals = config.equals;
            this._typeName = config.typeName;
            this.displayName = config.displayName;
        }
    }
    /****************************************/
    getItemsAsync(filter) {
        return Promise.resolve([]);
    }
    /****************************************/
    getItemText(item) {
        if (item)
            return item.toString();
    }
    /****************************************/
    getItemValue(item, bindItem) {
        return item;
    }
    /****************************************/
    getFilter(text, offset, pageSize) {
        return {};
    }
    /****************************************/
    async countAsync(filter) {
        return (await this.getItemsAsync(filter)).length;
    }
    /****************************************/
    getItemByValueAsync(value) {
        const item = Item_Item.getItem(value);
        if (item)
            return Promise.resolve(item);
        return Promise.resolve(value);
    }
    /****************************************/
    equals(a, b) {
        if (a == b)
            return true;
        if (a != undefined && a.valueOf && b != undefined && b.valueOf)
            return a.valueOf() == b.valueOf();
        return false;
    }
    /****************************************/
    get itemComparer() {
        return (a, b) => this.equals(this.getItemValue(a), this.getItemValue(b));
    }
    /****************************************/
    get typeName() {
        return this._typeName;
    }
    /****************************************/
    get allowZero() {
        return this._allowZero;
    }
    /****************************************/
    displayName;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Items/PagedItemsLoader.js



/****************************************/
class Items_PagedItemsLoader_PagedItemsLoader extends Templating_BindableObject_BindableObject {
    _hasMoreItems = true;
    _container;
    constructor(config) {
        super();
        this.bindConfig("pageSize", config);
        if (config) {
            if (config.getFilter)
                this.getFilter = config.getFilter;
        }
    }
    /****************************************/
    loadItemsAsync(container, chunkSize) {
        this._container = container;
        this._hasMoreItems = true;
        this._container.clear();
        return this.loadNextPageAsync();
    }
    /****************************************/
    async loadNextPageAsync() {
        if (!this.canLoadNextPage)
            return;
        if (this._container.itemsSource) {
            const filter = this.getFilter(this._container.itemsCount, this.pageSize);
            const operation = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Laoding items from " + this._container.itemsCount, type: Abstraction_IOperation_OperationType.Local });
            try {
                this._container.status = "loading";
                const newItems = await this._container.itemsSource.getItemsAsync({ ...filter, ...this._container.filter });
                if (!newItems || newItems.length == 0)
                    this._hasMoreItems = false;
                else {
                    newItems.forEach(item => this._container.addItem(item));
                    this._hasMoreItems = newItems.length == this.pageSize;
                }
            }
            finally {
                operation.end();
                this._container.status = "loaded";
            }
        }
    }
    /****************************************/
    onScroll(data) {
        if (data.pageBottom < 1 && this.canLoadNextPage)
            this.loadNextPageAsync();
    }
    /****************************************/
    getFilter(offset, pageSize) {
        return { ...this._container.filter, ...this._container.itemsSource.getFilter(undefined, offset, pageSize) };
    }
    /****************************************/
    get canLoadNextPage() {
        return this._hasMoreItems && this._container.status != "loading";
    }
    /****************************************/
    pageSize = 20;
    isScrollCheckActive = true;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Activities/SearchActivity.js









/****************************************/
class SearchActivity_SearchActivity extends Activity_Activity {
    _actionBar;
    _listView;
    _searchView;
    _emptyView;
    _lastItems;
    constructor(config) {
        super(config);
        this.bindConfigString("tooltip", config);
        this.bindConfig("pageSize", config);
        this.bindConfig("noMatchingText", config);
        if (config) {
            if (config.createItemView)
                this.createItemView = config.createItemView;
            if (config.searchAsync)
                this.searchWorkAsync = config.searchAsync;
            if (config.query)
                this.searchText = config.query;
            if (config.listStyles)
                config.listStyles.forEach(a => this.listStyles.push(a));
        }
    }
    /****************************************/
    refreshAsync() {
        return this._listView.refreshAsync();
    }
    /****************************************/
    async createAsync() {
        this._actionBar = this.view.addView(new Components_ActionBar_ActionBar({
            onBack: () => this.closeAsync(),
            title: this.prop("title"),
            mainAction: "back"
        }));
        this._searchView = new Components_SearchView_SearchView({
            name: "search-expanded",
            tooltip: this.prop("tooltip"),
            isExpanded: true,
            searchText: this.prop("searchText"),
            searchAsync: text => this._listView.refreshAsync()
        });
        this._actionBar.actions.add(this._searchView);
        this._emptyView = new Components_IconTextView_IconTextView({
            styles: ["empty-view"],
            visible: false
        });
        this._listView = this.view.addView(new Components_ListView_ListView({
            name: "content",
            styles: this.listStyles,
            template: "ListViewInline",
            header: [this._emptyView],
            itemsSource: new Items_ItemsSource_ItemsSource({
                getItemsAsync: async () => {
                    const searchText = this.searchText;
                    const items = await this.searchWorkAsync(searchText);
                    if (!searchText)
                        this._lastItems = items;
                    this.updateView(items?.length > 0, searchText);
                    return items;
                }
            }),
            itemsLoader: this.pageSize ? new Items_PagedItemsLoader_PagedItemsLoader({
                getFilter: (offset, pageSize) => this.getFilter(this.searchText, offset, pageSize),
                pageSize: this.pageSize
            }) : undefined,
            createItemView: item => this.createItemView(item),
            ...this.configureListView()
        }));
        setTimeout(() => this._searchView.hasFocus = true, 500);
        await this.refreshAsync();
    }
    /****************************************/
    updateView(hasItems, searchText) {
        if (!hasItems) {
            this._emptyView.visible = true;
            if (!this.searchText) {
                this._emptyView.icon = "fas fa-microscope";
                this._emptyView.text = "";
            }
            else {
                this._emptyView.icon = "far fa-sad-cry";
                if (this.noMatchingText)
                    this._emptyView.text = Core_Helpers_Format/* Format.text */.E.text(this.noMatchingText, searchText);
            }
        }
        else
            this._emptyView.visible = false;
    }
    /****************************************/
    configureListView() {
        return {};
    }
    /****************************************/
    createItemView(item) {
        throw "Not Implemented";
    }
    /****************************************/
    searchWorkAsync(query, offset, pageSize) {
        throw "Not Implemented";
    }
    /****************************************/
    getFilter(query, offset, pageSize) {
        return {};
    }
    /****************************************/
    searchText = null;
    tooltip = null;
    pageSize = 0;
    listStyles = ["vertical", "scroll", "compact"];
    emptyView;
    noMatchingText = null;
}
ObjectUtils_registerType(SearchActivity_SearchActivity, "SearchActivity");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/BottomSheet.js




/********************************************/
class Components_BottomSheet_BottomSheet extends ContentView_ContentView {
    _element;
    _margin = 20;
    _isAnimating = 0;
    /********************************************/
    constructor(config) {
        super({ template: "BottomSheet", ...config });
        this.bindConfig("headHeight", config);
        this.bindConfig("headSelector", config);
        this.bindConfig("isShowOpener", config);
    }
    /********************************************/
    attach(element) {
        this._element = element;
        const hammer = new external_Hammer_(element, {
            recognizers: [[external_Hammer_.Pan, { direction: external_Hammer_.DIRECTION_VERTICAL }]]
        });
        let startHeight = 0;
        let oldStatus = this.status;
        let startScrollTop = 0;
        hammer.on("panstart", ev => {
            oldStatus = this.status;
            this.status = "moving";
            startScrollTop = element.scrollTop;
            startHeight = element.clientHeight;
        });
        hammer.on("panend", ev => {
            if (element.clientHeight < this.headHeight - this._margin)
                this.close();
            else {
                if (oldStatus == "open") {
                    if (ev.deltaY > this._margin && this._element.scrollTop <= 0)
                        this.head();
                    else
                        this.open();
                }
                else {
                    if (element.clientHeight > this.headHeight + this._margin)
                        this.open();
                    else
                        this.head();
                }
            }
        });
        hammer.on("panmove", ev => {
            let deltaY = ev.deltaY;
            //Scroll when is opened
            if (oldStatus == "open") {
                const newScrollTop = startScrollTop - deltaY;
                if (deltaY < 0) {
                    this._element.scrollTop = newScrollTop;
                    return;
                }
                else {
                    if (newScrollTop >= 0) {
                        this._element.scrollTop = newScrollTop;
                        return;
                    }
                    this._element.scrollTop = 0;
                    deltaY = -newScrollTop;
                }
            }
            //Oopen, close, head
            let newHeight = startHeight - deltaY;
            const panHeight = newHeight;
            let enableScrolling = false;
            if (newHeight < this._margin)
                newHeight = 0;
            else if (newHeight > element.parentNode.clientHeight - this._margin && newHeight < this._element.scrollHeight) {
                newHeight = element.parentNode.clientHeight;
                enableScrolling = true;
            }
            else if (newHeight > this._element.scrollHeight)
                newHeight = this._element.scrollHeight;
            else if (newHeight > this.headHeight - this._margin && newHeight < this.headHeight + this._margin)
                newHeight = this.headHeight;
            element.style.height = newHeight + "px";
            //Scroll while opening
            if (panHeight - newHeight > 0 && enableScrolling)
                this._element.scrollTop = panHeight - newHeight;
            else
                this._element.scrollTop = 0;
        });
        switch (this.status) {
            case "head":
                this.head();
                break;
            case "open":
                this.open();
                break;
            case "close":
                this.close();
                break;
        }
    }
    /********************************************/
    async setHeightAsync(value) {
        this._isAnimating++;
        if (this._isAnimating == 1)
            this._element.classList.add("animate");
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        this._element.style.height = value.toString() + "px";
        await (0,Utils_PromiseUtils/* delayAsync */.$)(500);
        this._isAnimating--;
        if (this._isAnimating == 0)
            this._element.classList.remove("animate");
    }
    /********************************************/
    toggle() {
        if (this.status == "open" || this.status == "close")
            this.head();
        else
            this.open();
    }
    /********************************************/
    open() {
        this.status = "open";
        if (this._element)
            this.setHeightAsync(this._element.scrollHeight);
    }
    /********************************************/
    head() {
        this.status = "head";
        if (this._element) {
            if (this.headSelector) {
                const headEl = this._element.querySelector(this.headSelector);
                if (headEl) {
                    this.headHeight = headEl.clientHeight;
                    if (this.isShowOpener)
                        this.headHeight += this._element.querySelector(".opener").clientHeight;
                }
            }
            this.setHeightAsync(this.headHeight);
        }
    }
    /********************************************/
    close() {
        this.status = "close";
        if (this._element)
            this.setHeightAsync(0);
    }
    /********************************************/
    isShowOpener = false;
    headHeight = 100;
    headSelector = null;
    status = "close";
}
ObjectUtils_registerType(Components_BottomSheet_BottomSheet, "BottomSheet");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/RemovableItemView.js




/****************************************/
class Components_RemovableItemView_RemovableItemView extends ContentView_ContentView {
    constructor(config) {
        super(config);
        this.bindConfig("item", config);
        if (config) {
            if (config.removeAsync)
                this.removeWorkAsync = config.removeAsync;
        }
    }
    /****************************************/
    async removeAsync() {
        this.status = "removed";
        await (0,Utils_PromiseUtils/* delayAsync */.$)(150);
        await this.removeWorkAsync();
    }
    /****************************************/
    removeWorkAsync() {
        throw "Not supported";
    }
    /****************************************/
    item = null;
}
ObjectUtils_registerType(Components_RemovableItemView_RemovableItemView, "RemovableItemView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/SelectableItemView.js



/****************************************/
class Components_SelectableItemView_SelectableItemView extends ContentView_ContentView {
    constructor(config) {
        super(config);
        this.bindConfig("isSelected", config);
        this.bindConfig("item", config);
    }
    /****************************************/
    select() {
        this.isSelected = true;
    }
    /****************************************/
    toggle() {
        this.isSelected = !this.isSelected;
    }
    /****************************************/
    isSelected = false;
    item = null;
}
ObjectUtils_registerType(Components_SelectableItemView_SelectableItemView, "SelectableItemView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/Container.js




/********************************************/
class Components_Container_Container extends ContentView_ContentView {
    _element;
    constructor(config) {
        super({ template: "Container", ...config });
        this.bindConfigString("title", config, Types_DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfig("isExpanded", config);
        this.bindConfig("canExpand", config);
        this.prop("content").subscribe(() => this.checkOverflow());
    }
    /********************************************/
    attach(element) {
        this._element = element;
        if (this.canExpand) {
            this._element.addEventListener("resize", () => this.checkOverflow());
            this.checkOverflow();
        }
    }
    /********************************************/
    checkOverflow() {
        if (this._element != null) {
            const wrapper = this._element.querySelector(".content-wrapper");
            if (wrapper != null) {
                this.isOverflow = wrapper.scrollHeight > wrapper.clientHeight;
                if (!this.isOverflow)
                    this.isExpanded = true;
            }
        }
    }
    /********************************************/
    onContentChanged() {
    }
    /********************************************/
    toggleExpand() {
        this.isExpanded = !this.isExpanded;
    }
    /********************************************/
    title = "";
    isOverflow = true;
    canExpand = false;
    isExpanded = true;
}
ObjectUtils_registerType(Components_Container_Container, "Container");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Content/ItemEditContent.js





/****************************************/
class ItemEditContent_ItemEditContent extends Templating_BindableObject_BindableObject {
    _host;
    constructor(config) {
        super();
        this.bindConfig("editor", config);
        this.bindConfig("value", config);
        this.bindConfig("styles", config);
        this.bindConfig("url", config);
        this.bindConfig("actions", config);
        this.bindConfig("savePriority", config);
        this.bindConfig("saveOnCommit", config);
        this.bindConfigString("title", config, Types_DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfigString("saveLabel", config, Types_DynamicString/* StringUsage.Action */.Fq.Action);
        if (config) {
            if (config.saveItemAsync)
                this.saveItemAsync = config.saveItemAsync;
        }
    }
    /****************************************/
    async getContentAsync(host) {
        this._host = host;
        await this.editor.beginEditAsync(this.value);
        const container = new Components_Container_Container({
            name: "editor-container",
            title: this.title,
            content: this.editor.view
        });
        if (TypeCheck_isActivable(this.editor))
            setTimeout(() => this.editor.activateAsync(), 200);
        const actions = [];
        if (this.saveOnCommit) {
            this.editor.prop("value").subscribe(value => this.saveAsync());
        }
        else {
            actions.push({
                name: "save",
                icon: "fas fa-save",
                displayName: this.saveLabel,
                operation: Abstraction_IOperation_OperationType.Global,
                priority: this.savePriority,
                executeAsync: () => this.saveAsync()
            });
        }
        return {
            views: [container],
            actions: [...this.actions, ...actions],
            styles: this.styles,
            title: this.title,
            url: this.url
        };
    }
    /****************************************/
    async saveItemAsync(item) {
        return item;
    }
    /****************************************/
    async saveAsync() {
        //TODO check why it was needed before
        //(App as IViewApplication).unblock(true);
        if (this.saveOnCommit) {
            if (!this.editor.isValid)
                return;
        }
        else {
            if (!await this.editor.commitAsync(true))
                return;
        }
        const result = await this.saveItemAsync(this.editor.value);
        if (result == null)
            return;
        await this._host.closeAsync(result);
    }
    /****************************************/
    editor = null;
    title = null;
    url = null;
    value = null;
    saveLabel = "Save";
    saveOnCommit = false;
    savePriority = null;
    actions = [];
    styles = ["vertical", "scroll", "fill-h", "fit-items-h"];
    info = {
        name: "item-edit",
        icon: "fas fa-edit",
        displayName: "Edit",
    };
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/WebView.js


/********************************************/
class Components_WebView_WebView extends ContentView_ContentView {
    constructor(config) {
        super({ template: "WebView", ...config });
    }
    /********************************************/
    attach(element) {
        this.window = element.contentWindow;
    }
    /********************************************/
    window;
}
ObjectUtils_registerType(Components_WebView_WebView, "WebView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/WebPage.js






/****************************************/
class WebPage_WebPage extends Page_Page {
    constructor(config) {
        super(config);
        this.view = new Components_WebView_WebView();
        this.updateUrl();
        this.prop("url").subscribe(() => this.updateUrl());
    }
    /****************************************/
    updateUrl() {
        this.view.content = Core_Helpers_Uri/* Uri.absolute */.S.absolute(Core_Helpers_Format/* Format.replaceArgs */.E.replaceArgs(this.url, Core_Global/* App.startupArgs */.gV.startupArgs));
    }
    /****************************************/
    loadWorkAsync() {
        if (!this.view.window || this.view.window.document.readyState == "complete")
            return Promise.resolve();
        return new Promise((res, rej) => {
            function onLoad(ev) {
                this.view.window.removeEventListener("load", onLoad);
                res();
            }
            function onError(ev) {
                this.view.window.removeEventListener("error", onError);
                rej();
            }
            this.view.window.addEventListener("load", onLoad);
            this.view.window.addEventListener("error", onError);
        });
    }
    /****************************************/
    refreshAsync() {
        if (!this.view.window)
            return Promise.resolve();
        return new Promise((res, rej) => {
            function onLoad(ev) {
                this.view.window.removeEventListener("load", onLoad);
                res();
            }
            function onError(ev) {
                this.view.window.removeEventListener("error", onError);
                rej();
            }
            this.view.window.addEventListener("load", onLoad);
            this.view.window.addEventListener("error", onError);
            this.view.window.document.location.reload();
        });
    }
    /****************************************/
    async closeAsync() {
        this.view.window.close();
        if ("goBackAsync" in this.host)
            await this.host.goBackAsync();
        return true;
    }
}
ObjectUtils_registerType(WebPage_WebPage, "WebPage");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/BasePopUpMessage.js





/****************************************/
class BasePopUpMessage_BasePopUpMessage extends Components_View_View {
    _container;
    _showResolve;
    _isVisible = false;
    /****************************************/
    constructor(config) {
        super(config);
        this.bindConfig("className", config);
        this._container = document.createElement("DIV");
        this._container.className = this.className + "-container";
    }
    /****************************************/
    async showAsync() {
        if (this._isVisible)
            return;
        this._isVisible = true;
        Core_Global/* App.unblock */.gV.unblock(true);
        const builder = new Templating_TemplateBuilder_TemplateBuilder(this, this._container);
        builder.template(this.template, a => a);
        document.body.appendChild(this._container);
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        this._container.classList.add("visible");
        return new Promise(res => this._showResolve = res);
    }
    /****************************************/
    hide(actionName) {
        if (!this._isVisible)
            return;
        this._isVisible = false;
        Core_Global/* App.restoreBlock */.gV.restoreBlock();
        this._container.classList.remove("visible");
        if (this._showResolve) {
            this._showResolve(actionName);
            this._showResolve = null;
        }
        setTimeout(() => {
            if (!this._isVisible)
                document.body.removeChild(this._container);
        }, 500);
    }
    /****************************************/
    className = null;
}
ObjectUtils_registerType(BasePopUpMessage_BasePopUpMessage, "BasePopUpMessage");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/PopUpContent.js








/****************************************/
class Components_PopUpContent_PopUpContent extends BasePopUpMessage_BasePopUpMessage {
    _resultResolve;
    constructor(config) {
        super({ template: "PopUpContent", className: "pop-up-content", ...config });
        this.bindConfig("contentProvider", config);
        this.bindConfig("contentStyle", config);
        this.bindConfigString("title", config);
        this.bindConfigString("closeLabel", config);
    }
    /****************************************/
    async createAsync() {
        const viewContent = await this.contentProvider.getContentAsync(this);
        if (this.closeLabel) {
            this.addAction({
                name: "close",
                icon: "fas fa-close",
                displayName: this.closeLabel,
                executeAsync: () => this.closeAsync()
            });
        }
        if (viewContent.actions)
            viewContent.actions.forEach(a => this.addAction(a));
        if (!this.title && viewContent.title)
            this.title = Core_Helpers_Format/* Format.title */.E.title(viewContent.title);
        this.contentView.content.clear();
        if (viewContent.views)
            viewContent.views.forEach(a => this.contentView.addView(a));
        this.contentView.styles = [...this.contentStyle, ...viewContent.styles];
    }
    /****************************************/
    get result() {
        return new Promise(res => this._resultResolve = res);
    }
    /****************************************/
    async openAsync() {
        await this.createAsync();
        await this.contentView.loadAsync();
        this.showAsync(); //Not awaited
        return this;
    }
    /****************************************/
    notifyContentChanged(provider) {
        this.createAsync();
    }
    /****************************************/
    closeAsync(result) {
        if (this._resultResolve)
            this._resultResolve(result);
        this.hide("");
        return Promise.resolve(true);
    }
    /****************************************/
    addAction(action) {
        const actionView = Components_ActionView_ActionView.fromAction(action);
        if (action.priority == Abstraction_IAction_ActionPriority.Evidence) {
            actionView.styles.push("primary");
            actionView.buildStyles();
        }
        this.actions.add(actionView);
        return actionView;
    }
    /****************************************/
    contentProvider = null;
    actions = Templating_ObservableList_observableListOf();
    contentView = new Components_Panel_Panel();
    title = null;
    contentStyle = ["vertical", "fill-h", "fit-items-h"];
    closeLabel = "Cancel";
}
ObjectUtils_registerType(Components_PopUpContent_PopUpContent, "PopUpContent");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/PopupEditor.js






/********************************************/
class Editors_PopupEditor_PopUpEditor extends Templating_BindableObject_BindableObject {
    constructor(config) {
        super();
        this.bindConfig("name", config);
        this.bindConfig("editor", config);
        this.bindConfig("actions", config);
        this.bindConfig("styles", config);
        this.bindConfig("saveOnCommit", config);
        this.bindConfig("savePriority", config);
        this.bindConfigString("title", config, Types_DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfigString("closeLabel", config, Types_DynamicString/* StringUsage.Action */.Fq.Action);
        this.bindConfigString("saveLabel", config, Types_DynamicString/* StringUsage.Action */.Fq.Action);
        if (config) {
            if (config.editToItemAsync)
                this.editToItemAsync = config.editToItemAsync;
        }
        if (!this.closeLabel)
            this.closeLabel = Core_Helpers_Format/* Format.action */.E.action("cancel");
        if (!this.saveLabel)
            this.saveLabel = Core_Helpers_Format/* Format.action */.E.action("ok");
    }
    /********************************************/
    async editAsync(value, validate) {
        const popUp = new Components_PopUpContent_PopUpContent({
            title: this.title,
            contentProvider: new ItemEditContent_ItemEditContent({
                editor: this.editor,
                value: value,
                actions: this.actions,
                styles: this.styles,
                savePriority: this.savePriority,
                saveOnCommit: this.saveOnCommit,
                saveLabel: this.saveLabel,
                saveItemAsync: async (edit) => {
                    if (validate) {
                        const valResult = await validate(edit);
                        if (valResult == null)
                            return null;
                    }
                    return await this.editToItemAsync(edit);
                }
            }),
            closeLabel: this.closeLabel
        });
        const result = await (await popUp.openAsync()).result;
        if (!result)
            return null;
        return this.editor.value;
    }
    /********************************************/
    editToItemAsync(edit) {
        return Promise.resolve(edit);
    }
    /********************************************/
    editor = null;
    title = "Edit";
    saveLabel = null;
    actions = [];
    savePriority = null;
    closeLabel = null;
    saveOnCommit = false;
    styles = [];
    name = null;
}
ObjectUtils_registerType(Editors_PopupEditor_PopUpEditor, "PopUpEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/BaseEditor.js





/********************************************/
class BaseEditor_BaseEditor extends ViewComponent_ViewComponent {
    _needValidation = false;
    _isEditing = 0;
    _onCommit;
    _editValue = null;
    /********************************************/
    constructor(config) {
        super({ ...config });
        //TODO: hack, props are not enumerable in ts 3.9
        Functions_setEnumerable(this, "editValue");
        this._onCommit = config?.onCommit;
        this.bindConfig("allowNull", config);
        this.bindConfig("hasFocus", config);
        this.bindConfig("value", config);
        this.bindConfig("commitMode", config);
        this.bindConfig("validationMode", config);
        this.prop("displayValue");
        this.prop("value").subscribe((value, old) => this.onValueChanged(value, old));
        this.prop("name").subscribe(() => this.updateUid());
        if (config.converter) {
            this.editToValue = config.converter.convertFrom;
            this.valueToEdit = config.converter.convertTo;
        }
        this.updateUid();
    }
    /********************************************/
    updateUid() {
        this.uid = Identifier_generateId(Helpers_ViewUtils_formatForCss(this.name ?? ObjectUtils_getTypeName(this)));
    }
    /********************************************/
    createEditValueProp() {
        this.prop("editValue").subscribe(() => this.notifyEditValueChangedAsync());
    }
    /********************************************/
    async notifyEditValueChangedAsync() {
        console.debug("value changed: ", this.debugName);
        this._needValidation = true;
        this.isDirty = true;
        if (!this._isEditing) {
            if (this.commitMode == "onchange")
                await this.commitAsync();
            else
                await this.validateAsync();
        }
    }
    /********************************************/
    onValueChanged(value, oldValue) {
        if (this.status == "commiting")
            return;
        this.beginEditAsync(value);
    }
    /********************************************/
    clear() {
        this.value = null;
    }
    /********************************************/
    async loadAsync() {
        console.group("begin load: ", this.debugName, " - status: ", this.status);
        try {
            if (this.status != "none")
                return;
            this.status = "loading";
            try {
                await this.loadAsyncWork();
            }
            finally {
                this.status = "loaded";
            }
        }
        finally {
            console.groupEnd();
        }
    }
    /********************************************/
    clearError() {
        this.error = null;
    }
    /********************************************/
    loadAsyncWork() {
        return Promise.resolve();
    }
    /********************************************/
    async beginEditAsync(value) {
        if (this._isEditing)
            return;
        console.group("begin edit: ", this.debugName);
        this._isEditing++;
        try {
            if (this.status == "none")
                await this.loadAsync();
            this.value = value;
            this.editValue = this.valueToEdit(value);
            await this.beginEditWorkAsync(value);
            this._needValidation = true;
        }
        finally {
            this._isEditing--;
            console.groupEnd();
        }
    }
    /********************************************/
    valueToEdit(value) {
        return value;
    }
    /********************************************/
    editToValue(value) {
        return value;
    }
    /********************************************/
    beginEditWorkAsync(value) {
        return Promise.resolve();
    }
    /********************************************/
    async validateAsync(force) {
        console.group("begin validation: " + this.debugName, " - needValidation: ", this._needValidation);
        try {
            if (this._isEditing)
                return undefined;
            if (!this._needValidation && this.validationMode == "onchanged" && !force)
                return this.isValid;
            this.clearError();
            const validationResult = await this.validateAsyncWork(force);
            if (validationResult !== undefined) {
                this.isValid = validationResult;
                this._needValidation = false;
            }
            console.debug("validation: ", this.debugName, " = ", this.isValid);
            return this.isValid;
        }
        finally {
            console.groupEnd();
        }
    }
    /********************************************/
    validateAsyncWork(force) {
        return Promise.resolve(true);
    }
    /********************************************/
    async commitAsync(force) {
        console.group("begin commit: ", this.debugName, " isDirty: ", this.isDirty, " - status: ", this.status);
        try {
            if (this._isEditing)
                return false;
            if (!force && this.commitMode != "manual" && !this.isDirty)
                return true;
            if (this.status != "loaded")
                return this.status == "commiting";
            this.status = "commiting";
            try {
                if (!await this.validateAsync(force))
                    return false;
                if (!await this.commitAsyncWork(force))
                    return false;
                const newValue = this.editToValue(this.editValue);
                if (newValue !== undefined)
                    this.value = newValue;
                if (this._onCommit)
                    this._onCommit(this);
                this.isDirty = false;
                return true;
            }
            finally {
                this.status = "loaded";
            }
        }
        finally {
            console.groupEnd();
        }
    }
    /********************************************/
    activateAsync() {
        return Promise.resolve();
    }
    /********************************************/
    commitAsyncWork(force) {
        return Promise.resolve(true);
    }
    /********************************************/
    rollback() {
        this.editValue = this.valueToEdit(this.value);
    }
    /********************************************/
    get view() {
        return this;
    }
    /********************************************/
    get editValue() {
        return this._editValue;
    }
    set editValue(value) {
        this._editValue = value;
    }
    /********************************************/
    isValid = true;
    status = "none";
    commitMode = "onchange";
    validationMode = "onchanged";
    allowNull = true;
    displayValue = null;
    value = null;
    hasFocus = false;
    isDirty = false;
    uid = null;
    error = null;
}
ObjectUtils_registerType(BaseEditor_BaseEditor, "BaseEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/SingleItemSelector.js









/****************************************/
class Editors_SingleItemSelector_SingleItemSelector extends BaseEditor_BaseEditor {
    _isSelecting;
    constructor(config) {
        super({ template: "SelectEditor", ...config });
        this.bindConfig("itemsSource", config);
        this.bindConfig("itemTemplate", config);
        this.bindConfigString("placeholder", config);
        this.bindConfigString("emptyText", config, Types_DynamicString/* StringUsage.Title */.Fq.Title);
        if (config?.createItemView)
            this.createItemViewWork = config?.createItemView;
        if (config?.items) {
            if (this.allowNull)
                this.items.add(this.createEmptyItem());
            config.items.forEach(a => this.items.add(this.createItemView(a)));
            this.status = "loaded";
        }
        this.prop("selectedItem").subscribe(async (value, oldValue) => {
            if (this._isSelecting)
                return;
            if (!value && this.emptyText) {
                this.selectedItemText = this.emptyText;
                this.selectedItem = this.items.get(0);
                return;
            }
            this._isSelecting = true;
            try {
                if (oldValue)
                    oldValue.isSelected = false;
                if (value)
                    value.isSelected = true;
                this.selectedIndex = this.items.indexOf(value);
                if (this.itemsSource)
                    this.selectedItemText = value?.content ?? "";
                if (this.status != "loading")
                    await this.notifyEditValueChangedAsync();
            }
            finally {
                this._isSelecting = false;
            }
        });
        this.prop("selectedIndex").subscribe(value => {
            if (value == -1 && this.emptyText) {
                this.selectedIndex = 0;
                return;
            }
            this.selectedItem = value == -1 ? null : this.items.get(value);
            if (this.element?.tagName == "SELECT")
                this.element.selectedIndex = value;
        });
    }
    /********************************************/
    attach(element) {
        this.element = element;
        if (element.tagName == "SELECT") {
            this.element.selectedIndex = this.selectedIndex;
            this.element.addEventListener("change", () => this.selectedIndex = element.selectedIndex);
        }
    }
    /********************************************/
    async selectAsync() {
        const editor = new Editors_PopupEditor_PopUpEditor({
            editor: new Editors_SingleItemSelector_SingleItemSelector({
                template: "ItemSelectorList",
                itemsSource: this.itemsSource,
                allowNull: false,
                styles: ["no-padding-items-h"]
            }),
            saveOnCommit: true,
            saveLabel: "select",
            closeLabel: "cancel",
            title: "select-an-item",
            styles: [""]
        });
        const result = await editor.editAsync(this.value);
        if (result !== null)
            this.editValue = result;
    }
    /********************************************/
    findItemByValue(value) {
        if (this.itemsSource)
            return (0,Core_Linq/* linq */.k)(this.items).first(a => this.itemsSource.equals(a.item, value));
        return (0,Core_Linq/* linq */.k)(this.items).first(a => a.item == value);
    }
    /********************************************/
    set editValue(value) {
        if (this.editValue == value)
            return;
        if (value == null && this.emptyText)
            this.selectedItem = this.items[0];
        else
            this.selectedItem = this.findItemByValue(value);
    }
    get editValue() {
        return this.selectedItem?.item;
    }
    /****************************************/
    async loadAsyncWork() {
        if (this.itemsSource) {
            this.items.clear();
            if (this.allowNull)
                this.items.add(this.createEmptyItem());
            const items = await this.itemsSource.getItemsAsync(this.itemsSource.getFilter());
            if (items)
                items.forEach(a => this.items.add(this.createItemView(a)));
        }
        this.selectedIndex = 0;
        this.isDirty = true;
    }
    /****************************************/
    createEmptyItem() {
        const result = new Components_SelectableItemView_SelectableItemView({
            item: null,
            content: this.emptyText ?? "",
            template: this.itemTemplate,
            styles: ["single", "checkbox"]
        });
        result.prop("isSelected").subscribe(value => {
            if (value)
                this.selectedItem = null;
        });
        return result;
    }
    /****************************************/
    createItemViewWork(item) {
        if (this.itemsSource)
            return new Components_SelectableItemView_SelectableItemView({
                item: this.itemsSource.getItemValue(item),
                content: this.itemsSource.getItemText(item),
                template: this.itemTemplate,
                styles: ["single", "checkbox"]
            });
    }
    /****************************************/
    createItemView(item) {
        const itemView = this.createItemViewWork(item);
        itemView.prop("isSelected").subscribe(value => {
            if (value)
                this.selectedItem = itemView;
        });
        return itemView;
    }
    /****************************************/
    itemTemplate = "SelectableItemView";
    placeholder = null;
    emptyText = null;
    selectedItemText = null;
    selectedItem = null;
    selectedIndex = -1;
    itemsSource = null;
    items = Templating_ObservableList_observableListOf();
}
ObjectUtils_registerType(Editors_SingleItemSelector_SingleItemSelector, "SingleItemSelector");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/Actions.js






const Helpers_Actions_Actions = {};
/****************************************/
Helpers_Actions_Actions.selectFileAsync = options => {
    return new Promise((res, rej) => {
        const input = document.createElement("input");
        input.type = "file";
        let isSelected = false;
        input.onchange = () => {
            isSelected = true;
            res(input.files[0]);
        };
        input.click();
        const handler = async () => {
            window.removeEventListener("focus", handler);
            await (0,Utils_PromiseUtils/* delayAsync */.$)(500);
            if (!isSelected || input.files.length == 0)
                res(undefined);
        };
        window.addEventListener("focus", handler);
    });
};
/****************************************/
Helpers_Actions_Actions.selectOptionAsync = async (options) => {
    const editor = new Editors_PopupEditor_PopUpEditor({
        editor: new Editors_SingleItemSelector_SingleItemSelector({
            template: "ItemSelectorList",
            itemsSource: options.itemsSource,
            styles: ["no-padding-items-h"]
        }),
        saveOnCommit: options.saveOnCommit == undefined ? true : options.saveOnCommit,
        saveLabel: options.saveLabel,
        closeLabel: options.closeLabel,
        title: options.title,
        styles: options.styles
    });
    return await editor.editAsync(options.value);
};
/****************************************/
Helpers_Actions_Actions.loadPageAsync = async (page, options) => {
    return await Core_Global/* App.pageHost.loadAsync */.gV.pageHost.loadAsync(page, options);
};
/****************************************/
Helpers_Actions_Actions.content = (content, contentOptions, pageOptions) => {
    const value = typeof content == "function" ? new content() : content;
    const activity = new Activities_ContentActivity_ContentActivity({
        providers: [
            value
        ],
        ...contentOptions
    });
    return Helpers_Actions_Actions.loadPageAsync(activity, pageOptions);
};
/****************************************/
Helpers_Actions_Actions.go = url => {
    window.location.href = url;
    return Promise.resolve();
};
/****************************************/
Helpers_Actions_Actions.call = phoneNumber => {
    window.location.href = "tel:" + phoneNumber;
    return Promise.resolve();
};
/****************************************/
Helpers_Actions_Actions.email = email => {
    window.location.href = "mailto:" + email;
    return Promise.resolve();
};
/****************************************/
Helpers_Actions_Actions.webPage = url => {
    return Helpers_Actions_Actions.loadPageAsync(new WebPage_WebPage({ url: url }));
};
/****************************************/
Helpers_Actions_Actions.navigate = uri => {
    return new Promise((res, rej) => {
        const newWindows = window.open(uri, "_blank");
        newWindows.addEventListener("load", ev => {
            res();
        });
        newWindows.addEventListener("error", ev => {
            rej();
        });
    });
};
/****************************************/
Helpers_Actions_Actions.facebookPage = pageId => {
    window.location.href = "https://www.facebook.com/" + pageId;
    //window.location.href = "fb://page/" + pageId;
    return Promise.resolve();
};
/****************************************/
Helpers_Actions_Actions.maps = (location, zoomLevel = 17) => {
    if (location.position)
        window.location.href = "https://www.google.com/maps/search/?api=1&query=" + location.position.latitude + "," + location.position.longitude;
    //window.location.href = "geo:" + location.position.latitude + "," + location.position.longitude;
    else
        window.location.href = "https://www.google.com/maps/search/?api=1&query=" + encodeURIComponent(location.address);
    return Promise.resolve();
};

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/ActivityEditor.js





/********************************************/
class ActivityEditor_ActivityEditor extends Templating_BindableObject_BindableObject {
    constructor(config) {
        super();
        this.bindConfig("editor", config);
        this.bindConfigString("title", config);
        if (config) {
            if (config.editToItemAsync)
                this.editToItemAsync = config.editToItemAsync;
        }
    }
    /********************************************/
    async editAsync(value, validate) {
        const activity = new Activities_ContentActivity_ContentActivity({
            providers: [new ItemEditContent_ItemEditContent({
                    editor: this.editor,
                    title: this.title,
                    value: value,
                    saveItemAsync: async (edit) => {
                        if (validate) {
                            const valResult = await validate(edit);
                            if (valResult == null)
                                return null;
                        }
                        return await this.editToItemAsync(edit);
                    }
                })]
        });
        const result = await (await Helpers_Actions_Actions.loadPageAsync(activity, { loadMode: "add" })).result;
        if (result == null)
            return null;
        return this.editor.value;
    }
    /********************************************/
    editToItemAsync(edit) {
        return Promise.resolve(edit);
    }
    /********************************************/
    editor = null;
    title = "Edit";
}
ObjectUtils_registerType(ActivityEditor_ActivityEditor, "ActivityEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Activities/SelectMultipleItemsActivity.js
















/****************************************/
class SelectMultipleItemsActivity_SelectMultipleItemsActivity extends SearchActivity_SearchActivity {
    _bottomSheet;
    _emptyItem;
    constructor(config) {
        super(config);
        this.bindConfig("canAdd", config);
        this.bindConfigString("emptyLabel", config, Types_DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfig("showEmptyItem", config);
        this.bindConfig("itemsSource", config);
        this.bindConfigString("addLabel", config);
        if (config) {
            if (config.createItemView)
                this.createItemContentView = config.createItemContentView;
            if (config.createItemListView)
                this.createItemListView = config.createItemListView;
            if (config.createItemEditor)
                this.createItemEditor = config.createItemEditor;
            if (config.filters)
                this.filters.addRange(config.filters);
            if (config.selectedItems)
                this.setSelectedItems(config.selectedItems);
            if (config.searchMode == "client") {
                this.searchWorkAsync = async (query) => {
                    if (!this._lastItems)
                        this._lastItems = await this.itemsSource.getItemsAsync(this.getFilter(undefined));
                    if (query) {
                        query = query.toLowerCase();
                        return (0,Core_Linq/* linq */.k)(this._listView.items).where(a => {
                            const text = this.itemsSource.getItemText(a).toLowerCase();
                            return text && text.indexOf(query) != -1;
                        }).toArray();
                    }
                    else
                        return this._lastItems;
                };
            }
        }
        if (!config?.tooltip)
            this.tooltip = Types_DynamicString/* DynamicString.get */.wI.get("select-item")({ params: [this.itemsSource.displayName], number: Types_DynamicString/* WordNumber.Plural */.sZ.Plural, usage: Types_DynamicString/* StringUsage.Tooltip */.Fq.Tooltip });
        if (!config?.addLabel)
            this.addLabel = Core_Helpers_Format/* Format.action */.E.action("new-item", this.itemsSource.displayName);
    }
    /****************************************/
    setSelectedItems(items) {
        this.selectedItems.clear();
        if (items) {
            items.forEach(a => this.addSelection(a));
        }
    }
    /****************************************/
    async createAsync() {
        await super.createAsync();
        this._actionBar.addAction({
            name: "confirm",
            icon: "fas fa-check",
            displayName: "confirm",
            executeAsync: () => this.confirmAsync(),
            priority: Abstraction_IAction_ActionPriority.Primary
        });
        this._bottomSheet = new Components_BottomSheet_BottomSheet({
            headHeight: 50,
            content: new Components_ItemsView_ItemsView({
                styles: ["padding", "horizontal-wrap"],
                content: this.selectedItems
            })
        });
        this.view.addView(this._bottomSheet);
        this.updateView();
    }
    /****************************************/
    async confirmAsync() {
        await this.closeAsync((0,Core_Linq/* linq */.k)(this.selectedItems).select(a => a.item).toArray());
    }
    /****************************************/
    configureListView() {
        const header = [];
        if (this.canAdd)
            header.push(Components_ActionView_ActionView.fromAction({
                name: "add-item",
                icon: "fas fa-plus",
                operation: Abstraction_IOperation_OperationType.Local,
                executeAsync: () => this.addItemAsync(),
                displayName: this.addLabel,
            }));
        if (this.showEmptyItem) {
            this._emptyItem = new Components_SelectableItemView_SelectableItemView({
                content: new Components_TextView_TextView({ content: this.emptyLabel }),
                item: null,
            });
            this._emptyItem.toggle = () => this.closeAsync([]);
            header.push(this._emptyItem);
        }
        const result = {
            header: header,
            selectionMode: "multiple"
        };
        if (this.pageSize > 0)
            result.itemsSource = this.itemsSource;
        return result;
    }
    /****************************************/
    searchWorkAsync(query) {
        return this.itemsSource.getItemsAsync(this.getFilter(query));
    }
    /****************************************/
    getFilter(query, offset, pageSize) {
        let filter = this.itemsSource.getFilter(query, offset, pageSize);
        if (this.filters.count == 1)
            filter = { ...filter, ...this.filters.get(0).content };
        return filter;
    }
    /****************************************/
    createItemListView(item) {
        return new Components_TextView_TextView({ content: this.itemsSource.getItemText(item) });
    }
    /****************************************/
    createItemContentView(item) {
        return new Components_TextView_TextView({ content: this.itemsSource.getItemText(item) });
    }
    /****************************************/
    createItemEditor() {
        throw "Not Supported";
    }
    /****************************************/
    createItemView(item) {
        const view = new Components_SelectableItemView_SelectableItemView({
            content: this.createItemListView(item),
            item: item
        });
        view.prop("isSelected").subscribe(value => this.updateSelection(view, item, value));
        const exItem = this.findItem(item);
        if (exItem != null)
            view.isSelected = true;
        return view;
    }
    /****************************************/
    updateSelection(selView, item, isSelected) {
        if (!isSelected)
            this.removeSelection(item);
        else
            this.addSelection(item, selView);
        this.updateView();
    }
    /****************************************/
    updateView() {
        if (this._bottomSheet) {
            if (this.selectedItems.count > 0)
                this._bottomSheet.open();
            else
                this._bottomSheet.close();
        }
    }
    /****************************************/
    removeSelection(item) {
        const exItem = this.findItem(item);
        if (exItem)
            this.selectedItems.remove(exItem);
    }
    /****************************************/
    addSelection(item, selView) {
        const exItem = this.findItem(item);
        if (exItem)
            return;
        const itemView = new Components_RemovableItemView_RemovableItemView({
            content: this.createItemContentView(item),
            removeAsync: () => {
                this.selectedItems.remove(itemView);
                const selItem = this.findSelectable(item);
                if (selItem)
                    selItem.isSelected = false;
                return Promise.resolve();
            },
            item: item
        });
        this.selectedItems.add(itemView);
        return itemView;
    }
    /****************************************/
    findItem(item) {
        return (0,Core_Linq/* linq */.k)(this.selectedItems).first(a => this.itemsSource.itemComparer(a.item, item));
    }
    /****************************************/
    findSelectable(item) {
        return (0,Core_Linq/* linq */.k)(this._listView.content).first(a => this.itemsSource.itemComparer(a.item, item));
    }
    /****************************************/
    async addItemAsync() {
        const editor = this.createItemEditor();
        let editValue;
        if (TypeCheck_isAsyncEditor(editor))
            editValue = await editor.editAsync(this.itemsSource.newItem());
        else {
            const activity = new ActivityEditor_ActivityEditor({
                editor: editor,
                title: this.addLabel
            });
            editValue = await activity.editAsync(this.itemsSource.newItem());
        }
        if (!editValue)
            return;
        const newItem = await this.itemsSource.addItemAsync(editValue);
        if (!newItem)
            return;
        const itemView = this.createItemView(newItem);
        itemView.isSelected = true;
        this._listView.content.insert(0, itemView);
    }
    /****************************************/
    canAdd = false;
    showEmptyItem = false;
    emptyLabel = "[None]";
    itemsSource = null;
    addLabel = "Add New";
    filters = Templating_ObservableList_observableListOf();
    selectedItems = Templating_ObservableList_observableListOf();
}
ObjectUtils_registerType(SelectMultipleItemsActivity_SelectMultipleItemsActivity, "SelectMultipleItemsActivity");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Activities/SelectSingleItemActivity.js











/****************************************/
class SelectSingleItemActivity_SelectSingleItemActivity extends SearchActivity_SearchActivity {
    constructor(config) {
        super(config);
        this.bindConfig("canAdd", config);
        this.bindConfig("itemsSource", config);
        this.bindConfig("selectedValue", config);
        this.bindConfigString("addLabel", config);
        if (config) {
            if (config.createItemContentView)
                this.createItemContentView = config.createItemContentView;
            if (config.createItemEditor)
                this.createItemEditor = config.createItemEditor;
            if (config.filters)
                this.filters.addRange(config.filters);
        }
        if (!config?.tooltip)
            this.tooltip = Core_Helpers_Format/* Format.tooltip */.E.tooltip("select-item", this.itemsSource.displayName);
        if (!config?.addLabel)
            this.addLabel = Core_Helpers_Format/* Format.action */.E.action("new-item", this.itemsSource.displayName);
    }
    /****************************************/
    async createAsync() {
        await super.createAsync();
        this._actionBar.addAction({
            name: "confirm",
            icon: "fas fa-check",
            displayName: "confirm",
            executeAsync: () => this.confirmAsync(),
            priority: Abstraction_IAction_ActionPriority.Primary
        });
    }
    /****************************************/
    async confirmAsync() {
        await this.closeAsync();
    }
    /****************************************/
    configureListView() {
        const header = [];
        if (this.canAdd)
            header.push(Components_ActionView_ActionView.fromAction({
                name: "add-item",
                icon: "fas fa-plus",
                operation: Abstraction_IOperation_OperationType.Local,
                executeAsync: () => this.addItemAsync(),
                displayName: this.addLabel
            }));
        const result = {
            header: header,
        };
        if (this.pageSize > 0)
            result.itemsSource = this.itemsSource;
        return result;
    }
    /****************************************/
    searchWorkAsync(query) {
        return this.itemsSource.getItemsAsync(this.getFilter(query));
    }
    /****************************************/
    getFilter(query, offset, pageSize) {
        let filter = this.itemsSource.getFilter(query, offset, pageSize);
        if (this.filters.count == 1)
            filter = { ...filter, ...this.filters.get(0).content };
        return filter;
    }
    /****************************************/
    createItemContentView(item) {
        return new Components_TextView_TextView({ content: this.itemsSource.getItemText(item) });
    }
    /****************************************/
    createItemEditor() {
        throw "Not Supported";
    }
    /****************************************/
    createItemView(item) {
        const view = new Components_SelectableItemView_SelectableItemView({
            content: this.createItemContentView(item),
            styles: ["single"],
            item: item
        });
        if (this.itemsSource.equals(this.itemsSource.getItemValue(item), this.selectedValue))
            view.isSelected = true;
        view.prop("isSelected").subscribe(value => {
            if (value)
                this.setSelectionAsync(item);
        });
        return view;
    }
    /****************************************/
    setSelectionAsync(item) {
        return this.closeAsync(item);
    }
    /****************************************/
    async addItemAsync() {
        const editor = this.createItemEditor();
        let editValue;
        if (TypeCheck_isAsyncEditor(editor))
            editValue = await editor.editAsync(this.itemsSource.newItem());
        else {
            const activity = new ActivityEditor_ActivityEditor({
                editor: editor,
                title: this.addLabel
            });
            editValue = await activity.editAsync(this.itemsSource.newItem());
        }
        if (!editValue)
            return;
        const newItem = await this.itemsSource.addItemAsync(editValue);
        if (newItem)
            await this.setSelectionAsync(newItem);
    }
    /****************************************/
    canAdd = false;
    itemsSource = null;
    addLabel = "Add New";
    filters = Templating_ObservableList_observableListOf();
    selectedValue = null;
}
ObjectUtils_registerType(SelectSingleItemActivity_SelectSingleItemActivity, "SelectSingleItemActivity");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ConsoleView.js





class ConsoleView_ConsoleItem extends Components_View_View {
    constructor(args) {
        super();
        this.content = args;
    }
    /****************************************/
    debugTypeName() {
    }
    /****************************************/
    content;
}
/****************************************/
class ConsoleView_ConsoleMessageView extends ConsoleView_ConsoleItem {
    constructor(type, ...args) {
        super(args);
        this.type = type;
        this.template = "ConsoleMessageView";
    }
    /****************************************/
    type;
}
/****************************************/
class ConsoleView_ConsoleGroupView extends ConsoleView_ConsoleItem {
    constructor(...args) {
        super(args);
        this.template = "ConsoleGroupView";
    }
    /****************************************/
    items = Templating_ObservableList_observableListOf();
}
/****************************************/
class Components_ConsoleView_ConsoleView extends ViewComponent_ViewComponent {
    _oldConsole;
    _groups = [];
    _activeGroup;
    _isCreated = false;
    constructor() {
        super({ template: "ConsoleView" });
        this.root = new ConsoleView_ConsoleGroupView();
        this._activeGroup = this.root;
    }
    /****************************************/
    debugTypeName() {
    }
    /****************************************/
    show() {
        if (!this._isCreated) {
            var builder = new Templating_TemplateBuilder_TemplateBuilder(this, document.body);
            builder.content(this);
        }
        this.visible = true;
    }
    /****************************************/
    hide() {
        this.visible = false;
    }
    /****************************************/
    attach() {
        if (this._oldConsole)
            return;
        this._oldConsole = {};
        for (const key in console)
            this._oldConsole[key] = console[key];
        console.log = (...args) => this.write("log", args);
        console.warn = (...args) => this.write("warn", args);
        console.info = (...args) => this.write("info", args);
        console.trace = (...args) => this.write("trace", args);
        console.error = (...args) => this.write("error", args);
        console.debug = (...args) => this.write("debug", args);
        console.clear = () => this.clear();
        console.group = (...args) => this.group(args);
        console.groupEnd = () => this.groupEnd();
    }
    /****************************************/
    detach() {
        if (!this._oldConsole)
            return;
        for (const key in console)
            console[key] = this._oldConsole[key];
        this._oldConsole = null;
    }
    /****************************************/
    write(logType, args) {
        this._oldConsole[logType].apply(console, args);
        this._activeGroup.items.add(new ConsoleView_ConsoleMessageView(logType, args));
        if (logType == "error")
            this._activeGroup.items.add(new ConsoleView_ConsoleMessageView(logType, new Error().stack));
    }
    /****************************************/
    group(args) {
        this._oldConsole.group.apply(console, args);
        const newGroup = new ConsoleView_ConsoleGroupView(args);
        this._activeGroup.items.add(newGroup);
        this._groups.push(newGroup);
        this._activeGroup = newGroup;
    }
    /****************************************/
    groupEnd() {
        this._oldConsole.groupEnd.apply(console);
        if (this._groups.length > 0)
            this._activeGroup = this._groups.pop();
    }
    /****************************************/
    clear() {
        this._oldConsole.clear.apply(console);
        this._groups = [];
        this.root.items.clear();
        this._activeGroup = this.root;
    }
    /****************************************/
    root;
}
ObjectUtils_registerType(Components_ConsoleView_ConsoleView, "ConsoleView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ContentHostView.js




/****************************************/
class Components_ContentHostView_ContentHostView extends Components_Panel_Panel {
    _body;
    _actions;
    constructor(config) {
        super({
            ...config
        });
        this.bindConfig("contentProvider", config);
        this.bindConfig("actionTemplate", config);
        this._body = new Components_Panel_Panel({ name: "body" });
        this._actions = new Components_Panel_Panel({ name: "actions" });
        this.addView(this._body);
        this.addView(this._actions);
        this._body.emptyView = this.emptyView;
        this.emptyView = null;
    }
    /********************************************/
    async loadAsync() {
        if (this.contentProvider) {
            await this.closeAsync();
            const content = await this.contentProvider.getContentAsync(this);
            if (content.styles)
                this._body.styles = content.styles;
            this.name = this.contentProvider.info.name;
            this.title = Core_Helpers_Format/* Format.title */.E.title(content.title);
            content.views.forEach(a => this._body.addView(a));
            if (content.actions)
                content.actions.forEach(a => this.addAction(a));
            await super.loadAsync();
            if (this.contentProvider.activateAsync)
                await this.contentProvider.activateAsync();
        }
        this._actions.visible = this._actions.content.count > 0;
    }
    /********************************************/
    addAction(action) {
        this._actions.addView(Components_ActionView_ActionView.fromAction(action, { template: this.actionTemplate }));
    }
    /********************************************/
    notifyContentChanged(provider) {
        this.loadAsync();
    }
    /********************************************/
    async closeAsync(result) {
        if (this.contentProvider?.deactivateAsync)
            await this.contentProvider.deactivateAsync();
        this._body.clear();
        this._actions.clear();
        this.title = null;
        return true;
    }
    /********************************************/
    title = null;
    actionTemplate = "ActionButton";
    contentProvider = null;
}
ObjectUtils_registerType(Components_ContentHostView_ContentHostView, "ContentHostView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/Animation.js
/****************************************/
var Animation_Animation;
(function (Animation) {
    function cubic(p0, p1, p2, p3) {
        return t => Math.pow(1 - t, 3) * p0 +
            3 * Math.pow(1 - t, 2) * t * p1 +
            3 * (1 - t) * Math.pow(t, 2) * p2 +
            Math.pow(t, 3) * p3;
    }
    Animation.cubic = cubic;
    /****************************************/
    function linear() {
        return t => t;
    }
    Animation.linear = linear;
    /****************************************/
    function animate(options) {
        let curTime = 0;
        const handler = setInterval(() => {
            if (curTime > options.duration)
                curTime = options.duration;
            options.step(options.timeFunction(curTime / options.duration));
            if (curTime == options.duration)
                clearInterval(handler);
            curTime += options.stepTime;
        }, options.stepTime);
    }
    Animation.animate = animate;
})(Animation_Animation || (Animation_Animation = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/CounterView.js



/********************************************/
class Components_CounterView_CounterView extends ContentView_ContentView {
    constructor(config) {
        super({ template: "CounterView", ...config });
        this.bindConfig("value", config);
        this.bindConfig("title", config);
        this.prop("value").subscribe(() => this.animate());
        if (this.value != null)
            this.animate();
    }
    /********************************************/
    animate() {
        this.content = 0;
        const duration = this.value / 200;
        return Animation_Animation.animate({
            timeFunction: Animation_Animation.linear(),
            duration: isNaN(duration) || duration < 1 ? 1 : duration,
            stepTime: 1 / 20,
            step: t => this.content = Math.round(this.value * t)
        });
    }
    /********************************************/
    title = null;
    value = 0;
}
ObjectUtils_registerType(Components_CounterView_CounterView, "CounterView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/Drawer.js









/****************************************/
class Drawer_DrawerGroup {
    _host;
    constructor(host, config) {
        this._host = host;
        if (config) {
            this.label = Core_Helpers_Format/* Format.action */.E.action(config.label);
            config.actions.forEach(a => this.addAction(a));
        }
    }
    /****************************************/
    addAction(action) {
        const actionView = Components_ActionView_ActionView.fromAction(action, {
            executeAsync: async () => {
                this._host.hideAsync();
                await action.executeAsync();
            }
        });
        this.actions.add(actionView);
        return actionView;
    }
    /****************************************/
    actions = Templating_ObservableList_observableListOf();
    label = null;
}
/****************************************/
class Components_Drawer_Drawer extends Components_View_View {
    constructor(config) {
        super({ template: "Drawer", ...config });
        this.bindConfig("header", config);
        if (config) {
            config.groups.forEach(a => this.addGroup(a));
        }
    }
    /****************************************/
    onGesture(data) {
        if (data.type == Abstraction_IGestureListener_GestureType.SwipeLeft)
            this.hideAsync();
    }
    /****************************************/
    getGroup(label) {
        const labelTxt = Core_Helpers_Format/* Format.action */.E.action(label);
        return (0,Core_Linq/* linq */.k)(this.groups).first(a => a.label == labelTxt);
    }
    /****************************************/
    addGroup(config) {
        const group = new Drawer_DrawerGroup(this, config);
        this.groups.add(group);
        return group;
    }
    /****************************************/
    attach(element) {
        element.addEventListener("click", e => {
            if (e.srcElement == e.currentTarget)
                this.hideAsync();
        });
    }
    /****************************************/
    async showAsync(ctx) {
        this.status = "showing";
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        this.status = "visible";
    }
    /****************************************/
    async hideAsync() {
        this.status = "hiding";
        await (0,Utils_PromiseUtils/* delayAsync */.$)(500);
        if (this.status == "hiding")
            this.status = "hidden";
    }
    /****************************************/
    status = "hidden";
    header = null;
    groups = Templating_ObservableList_observableListOf();
}
ObjectUtils_registerType(Components_Drawer_Drawer, "Drawer");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/FileUploadView.js




/****************************************/
/* FileViewModel                        */
/****************************************/
class Components_FileUploadView_FileUploadView extends ViewComponent_ViewComponent {
    _input;
    constructor(config) {
        super(config);
        this._input = document.createElement("input");
        this._input.type = "file";
        this._input.addEventListener("change", () => {
            this.update();
            if (config?.onChanged)
                config.onChanged();
        });
        this.update();
    }
    /****************************************/
    update() {
        const file = this._input.files[0];
        if (file) {
            this.text = file.name;
            this.status = "selected";
        }
        else {
            this.text = "Seleziona file";
            this.status = "empty";
        }
        this.isSelected = this._input.files[0] != null;
    }
    /****************************************/
    select() {
        this._input.click();
    }
    /****************************************/
    remove() {
    }
    /****************************************/
    async uploadAsync(url) {
        this.status = "uploading";
        const result = await Helpers_Http/* Http.postBinaryAsync */.e.postBinaryAsync(url, this._input.files[0], ev => {
            this.progress = ev.loaded / ev.total;
            return true;
        });
        this.status = "uploaded";
        return result;
    }
    /****************************************/
    get file() {
        if (!this._input.files || this._input.files.length == 0)
            return null;
        return this._input.files[0];
    }
    /****************************************/
    progress = 0;
    text = null;
    progressText = null;
    status = "empty";
    error = null;
    isSelected = false;
}
ObjectUtils_registerType(Components_FileUploadView_FileUploadView, "FileUploadView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/GridView.js


/****************************************/
class GridView_GridView extends Components_ListView_ListView {
    constructor(config) {
        super({ styles: ["grid"], ...config });
        this.bindConfig("colsCount", config);
        this.bindConfig("rowsCount", config);
    }
    /****************************************/
    colsCount = 0;
    rowsCount = 0;
}
ObjectUtils_registerType(GridView_GridView, "GridView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/HeadedContentView.js



/****************************************/
class Components_HeadedContentView_HeadedContentView extends ContentView_ContentView {
    constructor(config) {
        super(config);
        this.bindConfig("header", config);
    }
    /****************************************/
    header = null;
    headerTemplate = null;
}
ObjectUtils_registerType(Components_HeadedContentView_HeadedContentView, "HeadedContentView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/HtmlView.js



class Components_HtmlView_HtmlView extends ContentView_ContentView {
    constructor(config) {
        super({ template: "Html", ...config });
    }
}
ObjectUtils_registerType(Components_HtmlView_HtmlView, "HtmlView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/ImageLoade.js


function ImageLoade_loadImageAsync(src) {
    const op = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading image: " + src.substring(0, 50), type: Abstraction_IOperation_OperationType.Local });
    return new Promise((res, rej) => {
        const img = document.createElement("img");
        img.addEventListener("load", () => {
            res(img);
            op.end();
        });
        img.addEventListener("error", ev => {
            rej(ev?.error);
            op.end();
        });
        img.src = src;
    });
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ImageView.js




/********************************************/
class Components_ImageView_ImageView extends ContentView_ContentView {
    constructor(config) {
        super({ template: "Image", ...config });
    }
    /********************************************/
    loadAsync() {
        if (this.content)
            return ImageLoade_loadImageAsync(this.content);
        return Promise.resolve();
    }
}
ObjectUtils_registerType(Components_ImageView_ImageView, "ImageView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ItemView.js









/****************************************/
class Components_ItemView_ItemView extends Components_Panel_Panel {
    _otherAction;
    constructor(config) {
        super({ template: "ItemView", ...config });
        this.bindConfig("item", config);
        this.bindConfig("canOpen", config);
        if (config) {
            if (config.open)
                this.openWork = config.open;
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
            if (config.itemTemplate)
                this.content.add(new Components_View_View({ template: t => t.template(config.itemTemplate, this) }));
        }
        this.computed("hasActions", m => (0,Core_Linq/* linq */.k)(m.contextActions).any(a => a.visible));
        this.create();
    }
    /****************************************/
    addAction(action) {
        const view = Components_ActionView_ActionView.fromItemAction(action, () => this.item);
        if (action.priority == Abstraction_IAction_ActionPriority.Primary) {
            if (this.mainActions.length >= 3) {
                if (!this._otherAction) {
                    this._otherAction = Components_ActionView_ActionView.fromAction({
                        name: "other",
                        icon: "fas fa-ellipsis-h",
                        operation: Abstraction_IOperation_OperationType.Local,
                        executeAsync: () => Promise.resolve()
                    });
                    this._otherAction.subActions.add(this.mainActions.pop());
                    this.mainActions.push(this._otherAction);
                }
                this._otherAction.subActions.add(view);
            }
            else
                this.mainActions.push(view);
        }
        else {
            this.contextActions.push(view);
            this.prop("hasActions").notifyChanged();
        }
    }
    /****************************************/
    create() {
    }
    /****************************************/
    open() {
        if (this.canOpen)
            this.openWork();
    }
    /****************************************/
    openWork() {
    }
    /****************************************/
    showMenu() {
        const menu = new Components_ContextMenu_ContextMenu();
        this.contextActions.forEach(a => menu.actions.add(a));
        menu.showAsync(window.event.srcElement);
    }
    /****************************************/
    item = null;
    contextActions = [];
    mainActions = [];
    status = null;
    canOpen = false;
    hasActions = null;
}
ObjectUtils_registerType(Components_ItemView_ItemView, "ItemView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/LocationView.js




/********************************************/
class Components_LocationView_LocationView extends ContentView_ContentView {
    constructor(config) {
        super({ template: "LocationView", ...config });
        if (config) {
            if (config.mapSize)
                this.mapSize = config.mapSize;
            if (config.zoomLevel)
                this.zoomLevel = config.zoomLevel;
        }
        this.updateAsync();
    }
    /********************************************/
    onContentChanged() {
        this.updateAsync();
    }
    /********************************************/
    showMap() {
        Helpers_Actions_Actions.maps(this.content);
    }
    /********************************************/
    async updateAsync() {
        const manager = Core_Global/* Services.mapManager */.K9.mapManager();
        let pos = this.content.position;
        if (!pos)
            pos = await manager.getLocationAsync(this.content.address);
        this.map = manager.staticMap({
            center: pos,
            size: this.mapSize,
            zoomLevel: this.zoomLevel,
            pins: [{
                    center: pos,
                    icon: 113,
                    name: this.content.name
                }]
        });
    }
    /********************************************/
    map;
    mapSize = { width: 1280, height: 720 };
    zoomLevel = 16;
}
ObjectUtils_registerType(Components_LocationView_LocationView, "LocationView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/Core/Types/Signal.js
class Types_Signal_Signal {
    _waitHandlers = [];
    _isSet;
    _autoReset;
    /****************************************/
    constructor(isSet = false, autoReset = true) {
        this._isSet = isSet;
        this._autoReset = autoReset;
    }
    /****************************************/
    set() {
        this._isSet = true;
        for (let i = this._waitHandlers.length - 1; i >= 0; i--)
            this._waitHandlers[i](true);
    }
    /****************************************/
    reset() {
        this._isSet = false;
    }
    /****************************************/
    waitFor(timeout) {
        if (this._isSet) {
            if (this._autoReset && this._waitHandlers.length == 0)
                this.reset();
            return Promise.resolve(true);
        }
        return new Promise((res) => {
            const handler = isSuccess => {
                res(isSuccess);
                const index = this._waitHandlers.indexOf(handler);
                if (index != -1)
                    this._waitHandlers.splice(index, 1);
                if (this._waitHandlers.length == 0 && this._autoReset)
                    this.reset();
            };
            if (timeout) {
                setTimeout(() => {
                    const index = this._waitHandlers.indexOf(handler);
                    if (index != -1) {
                        this._waitHandlers.splice(index, 1);
                        res(false);
                    }
                }, timeout.totalMilliseconds);
            }
            this._waitHandlers.push(handler);
        });
    }
    /****************************************/
    get isSet() {
        return this._isSet;
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/MapItemsView.js






/********************************************/
class MapItemsView_MapItemsView extends Components_ItemsView_ItemsView {
    _manager;
    /********************************************/
    constructor(config) {
        super({ template: "Attach", ...config });
        this.bindConfig("itemsSource", config);
        this.bindConfig("showCurrentPosition", config);
        if (config) {
            if (config.manager)
                this._manager = config.manager;
            if (config.createMapItem)
                this.createMapItem = config.createMapItem;
        }
        if (!this._manager)
            this._manager = Core_Global/* Services.mapManager */.K9.mapManager();
        this.prop("selectedItem").subscribe(value => {
            if (!value)
                this._manager.selectedItem = null;
            else
                this._manager.selectedItem = value["@mapItem"];
            if (config && config.onItemSelected)
                config.onItemSelected(value);
        });
        this._manager.onSelectionChanged = () => {
            if (this._manager.selectedItem)
                this.selectedItem = this._manager.selectedItem["@item"];
            else
                this.selectedItem = null;
        };
        this.prop("showCurrentPosition").subscribe(value => {
            this.manager.showCurrentPositionAsync(value);
        });
    }
    /****************************************/
    async loadItemsAsync(filter) {
        if (!this.itemsSource)
            return;
        this.beginUpdate();
        this.content.clear();
        this.status = "loading";
        const operation = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading items", type: Abstraction_IOperation_OperationType.Local });
        try {
            const items = await this.itemsSource.getItemsAsync(filter);
            if (items)
                items.forEach(a => this.content.add(a));
            if (this.mapReady.isSet)
                this.initItems();
        }
        finally {
            operation.end();
            this.status = "";
            this.endUpdate();
        }
    }
    /********************************************/
    attach(element) {
        Core_Global/* Services.operation.progress */.K9.operation.progress("Map attacched");
        if (this._manager)
            this._manager.attach(element);
        this.mapReady.set();
        if (this.status != "loading")
            this.initItems();
        this._manager.showCurrentPositionAsync(this.showCurrentPosition);
    }
    /********************************************/
    initItems() {
        const mapOptions = (0,Core_Linq/* linq */.k)(this.content).select(a => this.createMapItem(a)).toArray();
        const mapItems = this._manager.addItems(mapOptions);
        for (let i = 0; i < mapItems.length; i++) {
            ObjectUtils_set(this.content.get(i), "@mapItem", mapItems[i]);
            ObjectUtils_set(mapItems[i], "@item", this.content.get(i));
        }
    }
    /********************************************/
    createMapItem(item) {
        return undefined;
    }
    /********************************************/
    onItemAdded(item) {
        if (!this.mapReady.isSet)
            return;
        const options = this.createMapItem(item);
        if (!options.location || isNaN(options.location.latitude) || isNaN(options.location.longitude)) {
            console.warn("Invalid location for " + options.title);
            return;
        }
        const mapItem = this._manager.addItems([options]);
        ObjectUtils_set(item, "@mapItem", mapItem);
        ObjectUtils_set(mapItem, "@item", item);
    }
    /********************************************/
    onItemRemoved(item) {
        if (!this.mapReady.isSet)
            return;
        const mapItem = ObjectUtils_get(item, "@mapItem");
        if (mapItem)
            this._manager.removeItem(mapItem);
    }
    /********************************************/
    itemsSource = null;
    status = "";
    selectedItem = null;
    showCurrentPosition = false;
    mapReady = new Types_Signal_Signal();
    get manager() { return this._manager; }
}
ObjectUtils_registerType(MapItemsView_MapItemsView, "MapItemsView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/MapView.js




/********************************************/
class Components_MapView_MapView extends ViewComponent_ViewComponent {
    constructor(config) {
        super({ template: "Attach", ...config });
        if (config) {
            if (config.onMapLoaded)
                this.onMapLoaded = config.onMapLoaded;
            if (config.manager)
                this.manager = config.manager;
            this.bindConfig("showCurrentPosition", config);
        }
        if (!this.manager)
            this.manager = Core_Global/* Services.mapManager */.K9.mapManager();
        this.prop("showCurrentPosition").subscribe(value => {
            this.manager.showCurrentPositionAsync(value);
        });
    }
    /********************************************/
    attach(element) {
        if (this.manager)
            this.manager.attach(element);
        this.mapReady.set();
        this.onMapLoaded();
        this.manager.showCurrentPositionAsync(this.showCurrentPosition);
    }
    /********************************************/
    onMapLoaded() {
    }
    /********************************************/
    showCurrentPosition = false;
    manager;
    mapReady = new Types_Signal_Signal();
}
ObjectUtils_registerType(Components_MapView_MapView, "MapView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/VideoLoader.js


function VideoLoader_loadVideoAsync(src) {
    const op = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading video: " + src.substring(0, 50), type: Abstraction_IOperation_OperationType.Local });
    return new Promise((res, rej) => {
        const video = document.createElement("video");
        video.addEventListener("playing", () => {
            video.pause();
            op.end();
            res(video);
        });
        video.addEventListener("error", ev => {
            op.end();
            rej("error" in ev ? ev.error : "video load error");
        });
        video.src = src;
        video.muted = true;
        video.play();
        if (video.readyState >= 2)
            res(video);
    });
}
function VideoLoader_loadVideoIntoAsync(src, video) {
    if (!video.paused || video.played)
        return Promise.resolve();
    const op = Core_Global/* Services.operation.begin */.K9.operation.begin({ message: "Loading image: " + src, type: Abstraction_IOperation_OperationType.Local });
    return new Promise((res, rej) => {
        function removeListeners() {
            video.removeEventListener("playing", loadListener);
            video.removeEventListener("error", errorListener);
        }
        const loadListener = () => {
            op.end();
            removeListeners();
            res(undefined);
        };
        const errorListener = ev => {
            op.end();
            removeListeners();
            rej(ev.error);
        };
        video.addEventListener("playing", loadListener);
        video.addEventListener("error", errorListener);
        video.src = src;
        video.play();
    });
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/VideoView.js


;

/********************************************/
class Components_VideoView_VideoView extends ContentView_ContentView {
    _video;
    constructor(config) {
        super({ template: "VideoView", ...config });
        this.bindConfig("isAutoPlay", config);
        this.bindConfig("isMuted", config);
        this.bindConfig("showControls", config);
        this.bindConfig("isLoop", config);
    }
    /********************************************/
    onContentChanged() {
        this.updateVideo();
    }
    /********************************************/
    attach(element) {
        this._video = element;
        this.updateVideo();
    }
    /********************************************/
    loadAsync() {
        if (this.content) {
            if (this._video)
                return VideoLoader_loadVideoIntoAsync(this.content, this._video);
            else
                return VideoLoader_loadVideoAsync(this.content);
        }
        return Promise.resolve();
    }
    /********************************************/
    updateVideo() {
        if (!this._video)
            return;
        this._video.muted = this.isMuted;
        this._video.autoplay = this.isAutoPlay;
        this._video.controls = this.showControls;
        this._video.loop = this.isLoop;
        if (this.content)
            this._video.load();
    }
    /********************************************/
    play() {
        if (this._video)
            this._video.play();
    }
    /********************************************/
    pause() {
        if (this._video)
            this._video.pause();
    }
    /********************************************/
    isAutoPlay = true;
    isMuted = true;
    showControls = false;
    isLoop = true;
}
ObjectUtils_registerType(Components_VideoView_VideoView, "VideoView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/MediaView.js





/********************************************/
class Components_MediaView_MediaView extends ContentView_ContentView {
    _imageConfig = {};
    _videoConfig = {};
    constructor(config) {
        super({ template: "MediaView", ...config });
        if (config) {
            if (config.image)
                this._imageConfig = config.image;
            if (config.video)
                this._videoConfig = config.video;
        }
        this.updateContent();
    }
    /********************************************/
    loadAsync() {
        if (this.activeView)
            return this.activeView.loadAsync();
        return Promise.resolve();
    }
    /********************************************/
    onContentChanged() {
        this.updateContent();
    }
    /********************************************/
    updateContent() {
        if (this.content && this.content.type == "image")
            this.activeView = new Components_ImageView_ImageView({ ...this._imageConfig, content: this.content.src });
        if (this.content && this.content.type == "video")
            this.activeView = new Components_VideoView_VideoView({ ...this._videoConfig, content: this.content.src });
    }
    /********************************************/
    activeView = null;
}
ObjectUtils_registerType(Components_MediaView_MediaView, "MediaView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/MessageBox.js






/****************************************/
class Components_MessageBox_MessageBox extends BasePopUpMessage_BasePopUpMessage {
    constructor(config) {
        super({ template: "MessageBox", className: "message-box", ...config });
        this.bindConfigString("title", config, Types_DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfigString("message", config, Types_DynamicString/* StringUsage.Message */.Fq.Message);
        this.bindConfig("icon", config);
        if (config) {
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
        }
    }
    /****************************************/
    addAction(action) {
        const styles = action.styles ?? [];
        if (action.priority == Abstraction_IAction_ActionPriority.Evidence)
            styles.push("primary");
        this.actions.add(Components_ActionView_ActionView.fromAction(action, {
            template: "ActionButton",
            styles: styles,
            executeAsync: async () => {
                await action.executeAsync();
                this.hide(action.name);
            }
        }));
    }
    /****************************************/
    actions = Templating_ObservableList_observableListOf();
    message = null;
    title = null;
    icon = null;
}
ObjectUtils_registerType(Components_MessageBox_MessageBox, "MessageBox");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/ProgressView.js


/********************************************/
class Components_ProgressView_ProgressView extends ViewComponent_ViewComponent {
    constructor(config) {
        super(config);
    }
}
ObjectUtils_registerType(Components_ProgressView_ProgressView, "ProgressView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/BaseTextEditor.js



/********************************************/
class BaseTextEditor_BaseTextEditor extends BaseEditor_BaseEditor {
    _element;
    constructor(config) {
        super(config);
        this.bindConfig("trackMode", config);
        this.prop("hasFocus").subscribe(a => this.onFocusChanged(a));
    }
    /********************************************/
    attach(element) {
        this._element = element;
    }
    /********************************************/
    async activateAsync() {
        if (this._element.nodeName == "INPUT" || this._element.nodeName == "TEXTAREA") {
            while (true) {
                const input = this._element;
                input.selectionStart = 0;
                input.selectionEnd = input.value?.length;
                this._element.focus();
                if (this.hasFocus)
                    break;
                await (0,Utils_PromiseUtils/* delayAsync */.$)(100);
            }
        }
    }
    /********************************************/
    onFocusChanged(value) {
        if (!value && this.trackMode == "onlostfocus")
            this.notifyEditValueChangedAsync();
    }
    /********************************************/
    notifyEditValueChangedAsync() {
        if (this.hasFocus && this.trackMode == "onlostfocus") {
            this._needValidation = true;
            this.isDirty = true;
            return Promise.resolve();
        }
        return super.notifyEditValueChangedAsync();
    }
    /********************************************/
    trackMode = "onlostfocus";
}
ObjectUtils_registerType(BaseTextEditor_BaseTextEditor, "BaseTextEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/NumberEditor.js


/********************************************/
class NumberEditor_NumberEditor extends BaseTextEditor_BaseTextEditor {
    constructor(config) {
        super({ template: "NumberEditor", ...config });
        this.bindConfig("placeholder", config);
        this.bindConfig("precision", config);
        this.createEditValueProp();
    }
    /********************************************/
    valueToEdit(value) {
        return isNaN(value) ? "" : (this.precision != null ? value.toFixed(this.precision) : value.toString()).replace(".", ",");
    }
    /********************************************/
    editToValue(value) {
        const result = parseFloat(value?.replace(",", "."));
        return isNaN(result) ? null : result;
    }
    /********************************************/
    placeholder = null;
    min = null;
    max = null;
    precision = null;
}
ObjectUtils_registerType(NumberEditor_NumberEditor, "NumberEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/PropertyView.js







/********************************************/
class Components_PropertyView_PropertyView extends ViewComponent_ViewComponent {
    _lastValidationValue = undefined;
    constructor(config) {
        super({ template: "PropertyView", ...config });
        this.bindConfig("host", config);
        this.bindConfig("editor", config);
        this.bindConfig("readonly", config);
        this.bindConfig("showLabel", config);
        this.bindConfig("value", config);
        this.bindConfigString("label", config, Types_DynamicString/* StringUsage.Label */.Fq.Label);
        this.prop("error");
        if (config) {
            if (config.onChanged)
                this.prop("value").subscribe((o, n) => config.onChanged(o, n, this.host?.editValue, "editor"));
            if (config.validators)
                this.validators = config.validators;
        }
        this.prop("editor").subscribe(() => this.bindEditor());
        this.bindEditor();
    }
    /********************************************/
    bindEditor() {
        if (this.editor) {
            this.editor.name = this.name;
            this.editor.value = this.value;
            this.bind("value", this.editor.prop("value"));
            this.bind("isDirty", this.editor.prop("isDirty"));
            if ("label" in this.editor) {
                this.bind("label", this.editor.prop("label"));
                this.showLabel = false;
            }
            this.editor.prop("isValid").subscribe(value => {
                if (!value)
                    this.isValid = false;
                this.error = this.editor.error;
            });
        }
    }
    /********************************************/
    clearError() {
        this.editor.error = null;
        this.error = null;
    }
    /********************************************/
    async validateAsync(target, force) {
        console.group("begin validation: " + this.label, " - needValidation: ", this.isDirty);
        try {
            await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
            //TODO fix this, sometimes is editValue other time value
            const curValue = this.editor instanceof NumberEditor_NumberEditor ? this.editor.value : this.editor.editValue;
            if (!force && this._lastValidationValue !== undefined && ObjectUtils_equals(this._lastValidationValue, curValue))
                return this.isValid;
            this.clearError();
            this._lastValidationValue = curValue;
            if (!await this.editor.validateAsync(force)) {
                this.isValid = false;
                this.error = this.editor.error;
                return false;
            }
            const ctx = {
                value: curValue,
                fieldName: this.label,
                target: target
            };
            for (const validator of this.validators) {
                const result = await validator.validateAsync(ctx);
                if (!result.isValid) {
                    this.error = Core_Helpers_Format/* Format.message */.E.message(result.error);
                    this.isValid = false;
                    return false;
                }
            }
            this.isValid = true;
            return true;
        }
        finally {
            console.groupEnd();
        }
    }
    /********************************************/
    loadAsync() {
        return this.editor.loadAsync();
    }
    /********************************************/
    clear() {
        this.editor.clear();
        this.clearError();
    }
    /********************************************/
    isDirty = null;
    isValid = true;
    value = null;
    editor = null;
    error = null;
    label = null;
    readonly = false;
    showLabel = true;
    host = null;
    validators = [];
}
ObjectUtils_registerType(Components_PropertyView_PropertyView, "PropertyView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/SectionsView.js





/********************************************/
class SectionsView_SectionView extends ContentView_ContentView {
    constructor(config) {
        super(config);
        if (typeof config?.header == "string")
            this.header = new Components_TextView_TextView({ content: config.header });
    }
    /********************************************/
    header;
}
/********************************************/
class Components_SectionsView_SectionsView extends Components_ItemsView_ItemsView {
    constructor(config) {
        super(config);
        if (config?.sections)
            config.sections.forEach(a => this.content.add(new SectionsView_SectionView(a)));
    }
    /********************************************/
    section(name) {
        return (0,Core_Linq/* linq */.k)(this.content).first(a => a.name == name);
    }
}
ObjectUtils_registerType(Components_SectionsView_SectionsView, "SectionsView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/SimpleItemView.js



/****************************************/
class Components_SimpleItemView_SimpleItemView extends Components_IconTextView_IconTextView {
    constructor(config) {
        super(config);
        this.bindConfigString("subText", config);
        this.bindConfig("status", config);
        this.bindConfig("item", config);
    }
    /****************************************/
    subText = null;
    status = null;
    item = null;
}
ObjectUtils_registerType(Components_SimpleItemView_SimpleItemView, "SimpleItemView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/SnackBar.js







/****************************************/
class Components_SnackBar_SnackBar extends ViewComponent_ViewComponent {
    _showResolve;
    constructor() {
        super({ template: "SnackBar" });
        this.status = "close";
        new Templating_TemplateBuilder_TemplateBuilder(this, document.body).content(this);
    }
    /****************************************/
    async showAsync() {
        if (this.status == "open")
            return;
        Core_Global/* App.unblock */.gV.unblock(true);
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        this.status = "open";
        return new Promise(res => this._showResolve = res);
    }
    /****************************************/
    hide(actionName) {
        if (this.status != "open")
            return;
        this.status = "close";
        Core_Global/* App.restoreBlock */.gV.restoreBlock();
        if (this._showResolve) {
            this._showResolve(actionName);
            this._showResolve = null;
        }
    }
    /****************************************/
    static showAsync(options) {
        const instanceId = new Date().valueOf();
        if (!Components_SnackBar_SnackBar.instance)
            Components_SnackBar_SnackBar.instance = new Components_SnackBar_SnackBar();
        Components_SnackBar_SnackBar.instance.content = options.content;
        Components_SnackBar_SnackBar.instance.instanceId = instanceId;
        if (options.action) {
            let action;
            if (typeof options.action == "string")
                action = {
                    name: options.action,
                    executeAsync: () => Promise.resolve()
                };
            else
                action = options.action;
            Components_SnackBar_SnackBar.instance.action = Components_ActionView_ActionView.fromAction(action, {
                executeAsync: async () => {
                    await action.executeAsync();
                    Components_SnackBar_SnackBar.instance.hide(action.name);
                }
            });
        }
        else
            Components_SnackBar_SnackBar.instance.action = null;
        if (options.showTime) {
            setTimeout(() => {
                if (Components_SnackBar_SnackBar.instance.instanceId == instanceId && Components_SnackBar_SnackBar.instance._isVisible)
                    Components_SnackBar_SnackBar.instance.hide(null);
            }, options.showTime.totalMilliseconds);
        }
        return Components_SnackBar_SnackBar.instance.showAsync();
    }
    /****************************************/
    action = null;
    content = null;
    showTime = Types_TimeSpan_TimeSpan.fromSeconds(0);
    instanceId = null;
    static instance = null;
}
ObjectUtils_registerType(Components_SnackBar_SnackBar, "SnackBar");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/StaticMapView.js



/********************************************/
class StaticMapView_StaticMapView extends ViewComponent_ViewComponent {
    constructor(config) {
        super({ template: "ImageView", ...config });
        this.bindConfig("options", config);
        this.update();
    }
    /********************************************/
    update() {
        this.content = Core_Global/* Services.mapManager */.K9.mapManager().staticMap(this.options);
    }
    /********************************************/
    options;
    content;
}
ObjectUtils_registerType(StaticMapView_StaticMapView, "StaticMapView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/Toast.js







/****************************************/
class Components_Toast_Toast extends ViewComponent_ViewComponent {
    static _container;
    static _items = Templating_ObservableList_observableListOf();
    _showResolve;
    constructor(config) {
        super({ template: "Toast", visible: false, ...config });
        if (Components_Toast_Toast._container == null)
            Components_Toast_Toast.init();
        this.bindConfigString("message", config, Types_DynamicString/* StringUsage.Tooltip */.Fq.Tooltip);
        this.bindConfig("showTime", config);
        this.bindConfig("icon", config);
    }
    /****************************************/
    static init() {
        Components_Toast_Toast._container = document.createElement("div");
        Components_Toast_Toast._container.className = "toast-container";
        const builder = new Templating_TemplateBuilder_TemplateBuilder(Components_Toast_Toast._items, Components_Toast_Toast._container);
        builder.template("ToastContainer", a => a);
        document.body.appendChild(Components_Toast_Toast._container);
    }
    /****************************************/
    async showAsync() {
        Components_Toast_Toast._items.add(this);
        await (0,Utils_PromiseUtils/* delayAsync */.$)(10);
        this.visible = true;
        let showMs = this.showTime.totalMilliseconds;
        if (showMs == 0)
            showMs = Math.min(Math.max(this.message.length * 70, 2000), 7000);
        setTimeout(() => this.hideAsync(), showMs);
        return new Promise(res => this._showResolve = res);
    }
    /****************************************/
    async hideAsync() {
        this.visible = false;
        await (0,Utils_PromiseUtils/* delayAsync */.$)(600);
        Components_Toast_Toast._items.remove(this);
        if (this._showResolve) {
            this._showResolve();
            this._showResolve = null;
        }
    }
    /****************************************/
    message = null;
    icon = null;
    showTime = Types_TimeSpan_TimeSpan.fromSeconds(0);
}
ObjectUtils_registerType(Components_Toast_Toast, "Toast");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Components/WizardView.js









/****************************************/
class WizardView_WizardStepView extends ContentView_ContentView {
    constructor(config) {
        super({ template: "ContentView", ...config });
        this.bindConfig("index", config);
        this.bindConfig("coverImage", config);
        this.bindConfigString("title", config, Types_DynamicString/* StringUsage.Title */.Fq.Title);
        this.bindConfigString("nextLabel", config, Types_DynamicString/* StringUsage.Action */.Fq.Action);
        if (config) {
            if (config.loadAsync)
                this.loadAsync = () => config.loadAsync(this);
            if (config.validateAsync)
                this.validateAsync = force => config.validateAsync(this);
            if (config.actions)
                config.actions.forEach(a => this.addAction(a));
        }
    }
    /****************************************/
    addAction(action) {
        const view = Components_ActionView_ActionView.fromAction(action, { template: "ActionButton", styles: ["primary"] });
        this.actions.add(view);
        return view;
    }
    /****************************************/
    loadAsync() {
        if (TypeCheck_isAsyncLoad(this.content))
            return this.content.loadAsync();
        return Promise.resolve();
    }
    /****************************************/
    async validateAsync(force) {
        if (TypeCheck_isValidable(this.content))
            this.isValid = await this.content.validateAsync(force);
        return this.isValid;
    }
    /****************************************/
    select() {
        this.parentView.selectStepAsync(this.index);
    }
    /****************************************/
    error = null;
    isValid = true;
    index = 0;
    title = "";
    isActive = false;
    nextLabel = null;
    coverImage = null;
    actions = Templating_ObservableList_observableListOf();
}
/****************************************/
/* WizardViewModel
/****************************************/
class Components_WizardView_WizardView extends Components_ItemsView_ItemsView {
    constructor(config) {
        super({ template: "WizardView", ...config });
        this.actions = {
            next: new Components_ActionView_ActionView({
                name: "next",
                template: "ActionButton",
                styles: ["secondary"],
                content: new Components_IconTextView_IconTextView({
                    template: "IconTextViewInline",
                    text: this.prop("nextLabel")
                }),
                executeAsync: () => this.nextAsync()
            }),
            prev: new Components_ActionView_ActionView({
                name: "prev",
                template: "ActionButton",
                styles: ["secondary"],
                content: new Components_IconTextView_IconTextView({
                    template: "IconTextViewInline",
                    text: this.prop("prevLabel")
                }),
                executeAsync: () => this.previousAsync()
            }),
            finish: new Components_ActionView_ActionView({
                name: "finish",
                template: "ActionButton",
                styles: ["secondary"],
                content: new Components_IconTextView_IconTextView({
                    template: "IconTextViewInline",
                    text: this.prop("finishLabel")
                }),
                executeAsync: () => this.finishAsync()
            })
        };
        this.prop("currentStepIndex").subscribe((value, oldValue) => {
            if (oldValue != -1)
                this.content.get(oldValue).isActive = false;
            this.content.get(value).isActive = true;
            this.currentView = this.content.get(value);
            this.actions.next.visible = this.hasNextStep();
            this.actions.prev.visible = this.hasPrevStep();
            this.actions.finish.visible = !this.hasNextStep();
            if (this.currentView.nextLabel)
                this.nextLabel = this.currentView.nextLabel;
            else
                this.nextLabel = Core_Helpers_Format/* Format.action */.E.action(config?.nextLabel ?? "wizard-next");
        });
        this.bindConfigString("nextLabel", config, Types_DynamicString/* StringUsage.Action */.Fq.Action);
        this.bindConfigString("prevLabel", config, Types_DynamicString/* StringUsage.Action */.Fq.Action);
        this.bindConfigString("finishLabel", config, Types_DynamicString/* StringUsage.Action */.Fq.Action);
        if (config) {
            if (config.steps) {
                config.steps.forEach((step, i) => this.content.add(new WizardView_WizardStepView({ ...step, index: i })));
                this.currentStepIndex = 0;
            }
            if (config.finishAsync)
                this.doFinishAsync = config.finishAsync;
        }
        if (!config?.prevLabel)
            this.prevLabel = Core_Helpers_Format/* Format.action */.E.action("wizard-prev");
        if (!config?.finishLabel)
            this.prevLabel = Core_Helpers_Format/* Format.action */.E.action("wizard-finish");
    }
    /****************************************/
    async finishAsync() {
        if (await this.validateUntilAsync(this.content.count - 1) !== true)
            return;
        await this.doFinishAsync();
    }
    /****************************************/
    async doFinishAsync() {
        return Promise.resolve();
    }
    /****************************************/
    clearErrors() {
    }
    /****************************************/
    async validateUntilAsync(targetIndex) {
        let curStep = this.currentStepIndex;
        while (curStep <= targetIndex) {
            if (!await this.content.get(curStep).validateAsync())
                return curStep;
            curStep++;
        }
        return true;
    }
    /****************************************/
    async loadAsync() {
        if (this.content.count > 0)
            await this.content.get(this.currentStepIndex).loadAsync();
    }
    /****************************************/
    async selectStepAsync(index) {
        if (index == this.currentStepIndex)
            return;
        this.clearErrors();
        if (index > this.currentStepIndex) {
            const result = await this.validateUntilAsync(index - 1);
            if (result === true) {
                this.currentStepIndex = index;
                await this.content.get(index).loadAsync();
            }
            else {
                this.currentStepIndex = result;
                if (result != this.currentStepIndex)
                    await this.content.get(result).loadAsync();
            }
        }
        else
            this.currentStepIndex = index;
    }
    /****************************************/
    async nextAsync() {
        if (this.currentStepIndex + 1 < this.content.count)
            await this.selectStepAsync(this.currentStepIndex + 1);
    }
    /****************************************/
    async previousAsync() {
        if (this.currentStepIndex > 0)
            await this.selectStepAsync(this.currentStepIndex - 1);
    }
    /****************************************/
    async endAsync() {
        await this.selectStepAsync(this.content.count - 1);
    }
    /****************************************/
    hasPrevStep() {
        let curIndex = this.currentStepIndex - 1;
        while (curIndex >= 0) {
            if (this.content.get(curIndex).visible)
                return true;
            curIndex--;
        }
        return false;
    }
    /****************************************/
    hasNextStep() {
        let curIndex = this.currentStepIndex + 1;
        while (curIndex <= this.content.count - 1) {
            if (this.content.get(curIndex).visible)
                return true;
            curIndex++;
        }
        return false;
    }
    /****************************************/
    isComplete() {
        return !this.hasNextStep();
    }
    /****************************************/
    currentStepIndex = -1;
    currentView;
    actions;
    nextLabel = "Next";
    prevLabel = "Previous";
    finishLabel = "Finish";
}
ObjectUtils_registerType(WizardView_WizardStepView, "WizardStepView");
ObjectUtils_registerType(Components_WizardView_WizardView, "WizardView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Content/ItemListContent.js







/****************************************/
class ItemListContent_ItemListContent extends (/* unused pure expression or super */ null && (BindableObject)) {
    _listView;
    _tabView;
    _isRefreshing = false;
    _isBodyScroll = false;
    /****************************************/
    constructor() {
        super();
    }
    /****************************************/
    async refreshAsync() {
        this._isRefreshing = true;
        try {
            if (await this.prepareFilterAsync(this._listView.filter))
                await this._listView.refreshAsync();
        }
        finally {
            this._isRefreshing = false;
        }
    }
    /****************************************/
    prepareFilterAsync(filter) {
        return Promise.resolve(true);
    }
    /****************************************/
    deactivateAsync() {
        if (this._isBodyScroll)
            this.removeContent();
        this._listView?.deactivateListener();
        return Promise.resolve();
    }
    /****************************************/
    async activateAsync(reason) {
        this._listView?.activateListener();
        if (reason == "loading")
            await this.refreshAsync();
    }
    /****************************************/
    async getContentAsync(host) {
        const views = [];
        const options = await this.configureAsync(host);
        this._listView = new ListView({
            itemsSource: options.itemsSource,
            itemsLoader: options.pageSize ? new PagedItemsLoader({
                pageSize: options.pageSize
            }) : undefined,
            ...options.listView
        });
        this._listView.loadAsync = () => Promise.resolve();
        if (options.filters) {
            if (options.filters.length > 1) {
                this._tabView = new NavBar({
                    styles: ["tab-view"],
                    itemTemplate: "TextView",
                    itemBehavoirs: ["ripple"],
                    onItemSelected: item => {
                        this._listView.filter = item.content;
                        this.refreshAsync();
                    },
                    items: linq(options.filters).select(a => ({
                        name: a.name,
                        text: a.name,
                        content: a.content
                    })).toArray()
                });
                views.push(this._tabView);
            }
            else if (options.filters.length == 1)
                this._listView.filter = options.filters[0].content;
        }
        views.push(this._listView);
        if (this._tabView)
            this._tabView.selectedItem = this._tabView.content.get(0);
        if (options.footer)
            options.footer.forEach(a => views.push(a));
        this._listView.activateListener();
        //await this.refreshAsync();
        if (options.isBodyScroll) {
            this._isBodyScroll = true;
            setTimeout(() => this.moveContent());
        }
        return Promise.resolve({
            title: options.title ?? this.info.displayName,
            actions: options.actions,
            styles: options.styles,
            views: views,
            url: options.url,
            searchAsync: options.canSearch ? text => this.searchAsync(text) : undefined
        });
    }
    /****************************************/
    removeContent() {
        removeClass(document.scrollingElement, "scroll");
        removeClass(document.body.parentElement, "body-scroll");
        const element = document.querySelector("." + formatForCss(this.info.name));
        if (element)
            element.remove();
    }
    /****************************************/
    moveContent() {
        const element = document.querySelector("." + formatForCss(this.info.name));
        let container = document.querySelector(".scroll-content");
        if (!container) {
            container = document.createElement("div");
            container.classList.add("scroll-content");
            document.body.insertBefore(container, document.body.firstChild);
        }
        container.innerHTML = "";
        container.appendChild(element);
        addClass(document.body.parentElement, "body-scroll");
        removeClass(element, "scroll");
        addClass(document.scrollingElement, "scroll");
    }
    /****************************************/
    setFilter(name, content) {
        this._listView.filter = content;
        if (this._tabView) {
            let item = this._tabView.getItem(name);
            if (!item) {
                item = this._tabView.addItem({
                    text: name,
                    name: name,
                    content: content
                });
            }
            else {
                item.content = content;
            }
            const isSelected = this._tabView.selectedItem == item;
            this._tabView.selectedItem = item;
            return isSelected;
        }
        else
            return true;
    }
    /****************************************/
    async searchAsync(text) {
        this._listView.filter = { ...this._listView.filter, ...this._listView.itemsSource.getFilter(text) };
        await this._listView.refreshAsync();
    }
    /****************************************/
    get listView() {
        return this._listView;
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Content/MapContent.js



/****************************************/
class MapContent_MapContent {
    _mapView;
    _progress;
    _showCurrentPosition;
    /****************************************/
    constructor(config) {
        if (config) {
            if (config.showCurrentPosition !== undefined)
                this._showCurrentPosition = config.showCurrentPosition;
        }
    }
    /****************************************/
    refreshAsync() {
        return null;
    }
    /****************************************/
    async getContentAsync(host) {
        this._mapView = new MapView({
            onMapLoaded: () => this.onMapLoaded(),
            manager: Services.mapManager(),
            showCurrentPosition: this._showCurrentPosition
        });
        this._progress = new ProgressView();
        return {
            views: [this._mapView, this._progress],
            title: this.info.displayName
        };
    }
    /****************************************/
    createMapAsync(manager) {
        return Promise.resolve();
    }
    /****************************************/
    async onMapLoaded() {
        await this.createMapAsync(this._mapView.manager);
        this._progress.visible = false;
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Content/MasterDetailsContent.js






/****************************************/
class MasterDetailsContent_MasterDetailsContent extends (/* unused pure expression or super */ null && (BindableObject)) {
    _host;
    _masterContainer;
    _detailsContainer;
    constructor(config) {
        super();
        this.bindConfig("mode", config);
        this.bindConfig("masterContent", config);
        this.bindConfig("itemDisplayName", config);
        this.bindConfig("minWidth", config);
        if (config != null) {
            if (config.styles)
                config.styles.forEach(a => this.styles.push(a));
        }
        if (this.masterContent)
            this.masterContent.masterHost = this;
    }
    /****************************************/
    activateAsync(reason) {
        if (this.masterContent.activateAsync)
            return this.masterContent.activateAsync(reason);
        return Promise.resolve();
    }
    /****************************************/
    deactivateAsync() {
        if (this.masterContent.deactivateAsync)
            return this.masterContent.deactivateAsync();
        return Promise.resolve();
    }
    /****************************************/
    async getContentAsync(host) {
        this._host = host;
        if (this.mode == "auto") {
            const curWidth = document.body.clientWidth / window.devicePixelRatio;
            if (curWidth > this.minWidth)
                this.mode = "split-h";
            else
                this.mode = "separate";
        }
        if (this.mode != "separate") {
            const views = [];
            this._masterContainer = new ContentHostView({
                name: "master",
                contentProvider: this.masterContent
            });
            this._detailsContainer = new ContentHostView({
                name: "details",
                emptyView: new IconTextView({
                    styles: ["empty-view"],
                    icon: this.info.icon,
                    text: Format.message("msg-select-an-item", this.itemDisplayName)
                })
            });
            views.push(this._masterContainer);
            views.push(this._detailsContainer);
            return Promise.resolve({
                views: views,
                styles: [...this.styles, this.mode],
                title: this.info.displayName
            });
        }
        else
            return this.masterContent.getContentAsync(host);
    }
    /****************************************/
    async showDetailsAsync(item) {
        if (this.isDetailsLoading)
            return;
        try {
            this.isDetailsLoading = true;
            if (!item) {
                if (this.mode != "separate")
                    await this._detailsContainer.closeAsync();
            }
            else {
                const details = await this.masterContent.getDetailsAsync(item);
                if (!details)
                    return;
                if (this.mode != "separate") {
                    if (this._detailsContainer.contentProvider?.deactivateAsync)
                        await this._detailsContainer.contentProvider.deactivateAsync();
                    this._detailsContainer.contentProvider = details;
                    await this._detailsContainer.loadAsync();
                }
                else {
                    await Actions.loadPageAsync(new ContentActivity({
                        providers: [details],
                        name: details.info.name,
                    }));
                }
                this.details = details;
            }
        }
        finally {
            this.isDetailsLoading = false;
        }
    }
    /****************************************/
    isDetailsLoading = false;
    details = null;
    minWidth = 400;
    masterContent = null;
    styles = ["horizontal", "fill-v", "fill-h", "fill-items-v", "master-details"];
    mode = "auto";
    itemDisplayName = null;
    get info() { return this.masterContent.info; }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Content/MessageContent.js




class MessageContent_MessageContent {
    _options;
    /****************************************/
    constructor(options) {
        this._options = options;
    }
    /****************************************/
    async getContentAsync(host) {
        const views = [];
        views.push(new Components_IconTextView_IconTextView({
            icon: this._options.icon,
            text: this._options.message,
            styles: ["message-view"]
        }));
        if (this._options.customActions) {
            this._options.customActions.forEach(action => views.push(new Components_ActionView_ActionView({
                name: action.name,
                template: "ActionButton",
                styles: ["primary"],
                content: new Components_TextView_TextView({ content: Core_Helpers_Format/* Format.action */.E.action(action.displayName) }),
                executeAsync: async () => {
                    await host.closeAsync();
                    await action.executeAsync();
                }
            })));
        }
        return Promise.resolve({
            views: views,
            title: this._options.title,
            styles: ["vertical", "margin-items-v", "scroll", "fit-items-h", "surface", "padding", "small"],
        });
    }
    /****************************************/
    get info() {
        return {
            name: "message",
            icon: null,
            displayName: this._options.title
        };
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/BaseItemEditor.js


/****************************************/
class BaseItemEditor_BaseItemEditor extends Templating_BindableObject_BindableObject {
    constructor(config) {
        super();
    }
    /****************************************/
    beginEditAsync(item) {
        throw "Not implemented";
    }
    /****************************************/
    commitAsync(force) {
        throw "Not implemented";
    }
    /****************************************/
    view = null;
    value = null;
    isValid = null;
}
ObjectUtils_registerType(BaseItemEditor_BaseItemEditor, "BaseItemEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/BasePicker.js







/****************************************/
class BasePicker_BasePicker extends BaseEditor_BaseEditor {
    constructor(config) {
        super(config);
        this.bindConfig("canAdd", config);
        this.bindConfig("itemsSource", config);
        this.bindConfig("pageSize", config);
        this.bindConfigString("addLabel", config);
        this.bindConfigString("pickLabel", config);
        this.bindConfig("searchMode", config);
        if (config) {
            if (config.filters)
                this.filters.addRange(config.filters);
            if (config.createItemView)
                this.createItemView = config.createItemView;
            if (config.createItemListView)
                this.createItemListView = config.createItemListView;
            if (config.createItemEditor)
                this.createItemEditor = config.createItemEditor;
        }
        if (!config?.addLabel)
            this.addLabel = Core_Helpers_Format/* Format.title */.E.title("new-item", this.itemsSource.displayName);
        if (!config?.pickLabel)
            this.pickLabel = Core_Helpers_Format/* Format.title */.E.title("select-item", this.itemsSource.displayName);
        this.createEditValueProp();
        this.selectAction = Components_ActionView_ActionView.fromActionIcon({
            name: "select",
            icon: "fas fa-list",
            operation: Abstraction_IOperation_OperationType.Local,
            displayName: this.pickLabel,
            executeAsync: () => this.selectAsync()
        });
    }
    /****************************************/
    createItemEditor() {
        throw "Not Supported";
    }
    /****************************************/
    createItemView(item) {
        return new Components_TextView_TextView({ content: this.itemsSource.getItemText(item) });
    }
    /****************************************/
    createItemListView(item) {
        return this.createItemView(item);
    }
    /****************************************/
    async notifyEditValueChangedAsync() {
        await super.notifyEditValueChangedAsync();
        await this.updateViewAsync();
    }
    /****************************************/
    canAdd = false;
    addLabel = "Add";
    pickLabel = "Select";
    selectAction = null;
    itemsSource = null;
    pageSize = 0;
    searchMode = "default";
    filters = Templating_ObservableList_observableListOf();
}
ObjectUtils_registerType(BasePicker_BasePicker, "BasePicker");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/BooleanEditor.js



/********************************************/
class Editors_BooleanEditor_BooleanEditor extends BaseEditor_BaseEditor {
    constructor(config) {
        super({ template: "CheckBox", ...config });
        this.bindConfigString("trueLabel", config);
        this.bindConfigString("falseLabel", config);
        this.bindConfigString("label", config, Types_DynamicString/* StringUsage.Action */.Fq.Action);
        this.createEditValueProp();
    }
    /********************************************/
    toggle() {
        if (window.event)
            window.event.stopPropagation();
        this.editValue = !this.editValue;
    }
    /********************************************/
    trueLabel = null;
    falseLabel = null;
    label = null;
}
ObjectUtils_registerType(Editors_BooleanEditor_BooleanEditor, "BooleanEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/DateEditor.js



/********************************************/
class Editors_DateEditor_DateEditor extends BaseTextEditor_BaseTextEditor {
    constructor(config) {
        super({ template: "DateEditor", ...config });
        this.bindConfig("placeholder", config);
        this.createEditValueProp();
    }
    /********************************************/
    valueToEdit(value) {
        return value === null || value === undefined ? "" : DateUtils_formatDate(value, "{YYYY}-{MM}-{DD}");
    }
    /********************************************/
    editToValue(value) {
        if (value === undefined || value === null)
            return null;
        return DateUtils_parseDate(value + " 00:00");
    }
    /********************************************/
    placeholder = null;
}
ObjectUtils_registerType(Editors_DateEditor_DateEditor, "DateEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/DateEditorCombo.js



/********************************************/
class Editors_DateEditorCombo_DateEditorCombo extends BaseEditor_BaseEditor {
    constructor(config) {
        super(config);
        for (let i = 1; i <= 31; i++)
            this.days.push(i.toString());
        for (let i = 1; i <= 12; i++)
            this.months.push({ number: i.toString(), name: DateUtils_MONTHS[i - 1] });
        const maxYear = config?.maxYear ?? new Date().getFullYear();
        const minYear = config?.minYear ?? new Date().getFullYear() - 100;
        for (let i = minYear; i <= maxYear; i++)
            this.years.push(i.toString());
        this.prop("selectedDay").subscribe(() => this.tryCommit());
        this.prop("selectedMonth").subscribe(() => this.tryCommit());
        this.prop("selectedYear").subscribe(() => this.tryCommit());
    }
    /********************************************/
    tryCommit() {
        this.commitAsync();
    }
    /********************************************/
    commitAsync(force) {
        if (this.editValue?.getTime() != this.value?.getTime())
            this.value = this.editValue;
        return Promise.resolve(true);
    }
    /********************************************/
    get editValue() {
        if (!this.selectedDay || !this.selectedMonth || !this.selectedYear)
            return null;
        return new Date(parseInt(this.selectedYear), parseInt(this.selectedMonth) - 1, parseInt(this.selectedDay));
    }
    /********************************************/
    set editValue(value) {
        if (value?.getTime() == this.editValue?.getTime())
            return;
        if (!value) {
            this.selectedDay = null;
            this.selectedMonth = null;
            this.selectedYear = null;
        }
        else {
            this.selectedDay = (value.getDate()).toString();
            this.selectedMonth = (value.getMonth() + 1).toString();
            this.selectedYear = value.getFullYear().toString();
        }
    }
    /********************************************/
    selectedDay = null;
    selectedMonth = null;
    selectedYear = null;
    days = [];
    months = [];
    years = [];
}
ObjectUtils_registerType(Editors_DateEditorCombo_DateEditorCombo, "DateEditorCombo");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/ItemEditorConverter.js



/****************************************/
class ItemEditorConverter_ItemEditorConverter extends Templating_BindableObject_BindableObject {
    _item;
    constructor(config) {
        super();
        this.bindConfig("editor", config);
        if (config) {
            if (config.itemToEdit)
                this.itemToEdit = config.itemToEdit;
            if (config.editToItem)
                this.editToItem = config.editToItem;
        }
    }
    /****************************************/
    activateAsync() {
        if (TypeCheck_isActivable(this.editor))
            return this.editor.activateAsync();
        return Promise.resolve();
    }
    /****************************************/
    beginEditAsync(item) {
        this._item = item;
        return this.editor.beginEditAsync(this.itemToEdit(item));
    }
    /****************************************/
    async commitAsync(force) {
        if (await this.editor.commitAsync(force)) {
            this.editToItem(this._item, this.editor.value);
            return true;
        }
        return false;
    }
    /****************************************/
    itemToEdit(item) {
        throw "Not supported";
    }
    /****************************************/
    editToItem(item, editValue) {
    }
    /****************************************/
    get value() {
        return this.editor.value;
    }
    get view() {
        return this.editor;
    }
    get isValid() {
        return this.editor.isValid;
    }
    editor = null;
}
ObjectUtils_registerType(ItemEditorConverter_ItemEditorConverter, "ItemEditorConverter");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/Interaction.js






/****************************************/
var Interaction_Interaction;
(function (Interaction) {
    async function showMessageAsync(options) {
        const msgActions = options.actions ?? (options.customActions ? [] : ["ok"]);
        const msgBox = new Components_MessageBox_MessageBox({ message: options.message, icon: options.icon, title: options.title });
        msgActions.forEach(a => {
            msgBox.addAction({
                name: a,
                displayName: Core_Helpers_Format/* Format.action */.E.action(a),
                executeAsync: () => Promise.resolve()
            });
        });
        if (options.customActions)
            options.customActions.forEach(a => msgBox.addAction(a));
        const result = await msgBox.showAsync();
        return result;
    }
    Interaction.showMessageAsync = showMessageAsync;
    /****************************************/
    async function confirmAsync(message) {
        const result = await showMessageAsync({
            message: message,
            title: "confirm",
            actions: ["yes", "no"]
        });
        return result == "yes";
    }
    Interaction.confirmAsync = confirmAsync;
    /****************************************/
    function info(message) {
        const toast = new Components_Toast_Toast({ message: message });
        toast.showAsync();
    }
    Interaction.info = info;
    /****************************************/
    function warning(message) {
        const toast = new Components_Toast_Toast({ message: message, styles: ["warning"] });
        toast.showAsync();
    }
    Interaction.warning = warning;
    /****************************************/
    function error(message) {
        const toast = new Components_Toast_Toast({ message: message, styles: ["error"], icon: "fas fa-exclamation" });
        toast.showAsync();
    }
    Interaction.error = error;
    /****************************************/
    async function succeed(message) {
        const page = await Helpers_Actions_Actions.loadPageAsync(new Activities_ContentActivity_ContentActivity({
            providers: [new MessageContent_MessageContent({
                    icon: "far fa-smile",
                    customActions: [{
                            name: "close",
                            displayName: "close",
                            executeAsync: () => Promise.resolve(),
                        }],
                    ...message
                })],
            name: "message"
        }));
        return await page.result;
    }
    Interaction.succeed = succeed;
    /****************************************/
    async function fail(message) {
        const page = await Helpers_Actions_Actions.loadPageAsync(new Activities_ContentActivity_ContentActivity({
            providers: [new MessageContent_MessageContent({
                    icon: "far fa-sad-tear",
                    customActions: [{
                            name: "close",
                            displayName: "close",
                            executeAsync: () => Promise.resolve(),
                        }], ...message
                })],
            name: "message"
        }));
        return await page.result;
    }
    Interaction.fail = fail;
})(Interaction_Interaction || (Interaction_Interaction = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Items/EditableItemsSource.js

/****************************************/
class Items_EditableItemsSource_EditableItemsSource extends Items_ItemsSource_ItemsSource {
    constructor(config) {
        super(config);
        if (config) {
            if (config.addItemAsync)
                this.addItemAsync = config.addItemAsync;
            if (config.updateItemAsync)
                this.updateItemAsync = config.updateItemAsync;
            if (config.removeItemAsync)
                this.removeItemAsync = config.removeItemAsync;
            if (config.newItem)
                this.newItem = config.newItem;
        }
    }
    /********************************************/
    newItem() {
        return {};
    }
    /********************************************/
    addItemAsync(item) {
        return Promise.resolve(item);
    }
    /********************************************/
    updateItemAsync(editItem, item) {
        return Promise.resolve(item);
    }
    /********************************************/
    removeItemAsync(item) {
        return Promise.resolve(true);
    }
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/ItemsEditor.js


















/********************************************/
class ItemsEditor_ItemsEditorItemView extends Components_ItemView_ItemView {
    constructor(config) {
        super({
            ...config
        });
        if (config.canEdit) {
            this.addAction({
                name: "edit-item",
                icon: "fas fa-edit",
                operation: Abstraction_IOperation_OperationType.Local,
                priority: Templating_BindableObject_BindableObject.bindValue(config.editActionsPriority),
                displayName: config.editActionLabel,
                executeAsync: () => this.editAsync()
            });
        }
        if (config.canRemove) {
            this.addAction({
                name: "remove-item",
                icon: "fas fa-trash",
                operation: Abstraction_IOperation_OperationType.Local,
                priority: Templating_BindableObject_BindableObject.bindValue(config.editActionsPriority),
                displayName: config.removeActionLabel,
                executeAsync: () => this.removeAsync()
            });
        }
        if (config.itemActions) {
            config.itemActions.forEach(action => this.addAction({
                name: action.name,
                icon: action.icon,
                priority: action.priority,
                operation: action.operation,
                displayName: Core_Helpers_Format/* Format.action */.E.action(action.displayName, config.itemsSource.displayName),
                canExecute: action.canExecute ? () => action.canExecute(this) : undefined,
                executeAsync: () => action.executeAsync(this)
            }));
        }
        this.value = config.value;
    }
    /********************************************/
    updateView() {
        this.content.clear();
        if (this.isEdit && this.editMode == "inline" && !TypeCheck_isAsyncEditor(this.editor))
            this.content.add(this.editor.view);
        else
            this.content.add(this.view);
    }
    /********************************************/
    updateValueAsync() {
        throw "Not implemented";
    }
    /********************************************/
    createUpdateEditor() {
        throw "Not implemented";
    }
    /********************************************/
    createAddEditor() {
        throw "Not implemented";
    }
    /********************************************/
    executeUpdateAsync(item) {
        throw "Not implemented";
    }
    /********************************************/
    executeAddAsync(item) {
        throw "Not implemented";
    }
    /********************************************/
    async editAsync() {
        if (this.isEdit)
            return false;
        if (!this.editor) {
            if (this.status == "added")
                this.editor = this.createAddEditor();
            else
                this.editor = this.createUpdateEditor();
        }
        this.isEdit = true;
        if (this.editMode == "external") {
            let newItem = null;
            if (TypeCheck_isAsyncEditor(this.editor)) {
                const editValue = await this.editor.editAsync(this.item);
                if (editValue) {
                    if (this.status == "added")
                        newItem = await this.executeAddAsync(editValue);
                    else
                        newItem = await this.executeUpdateAsync(editValue);
                }
            }
            else {
                const activity = new Activities_ContentActivity_ContentActivity({
                    providers: [new ItemEditContent_ItemEditContent({
                            editor: this.editor,
                            title: item => this.status == "added" ? this.addTitle : this.editTitle,
                            value: this.item,
                            saveItemAsync: item => this.status == "added" ? this.executeAddAsync(item) : this.executeUpdateAsync(item)
                        })]
                });
                newItem = await (await Helpers_Actions_Actions.loadPageAsync(activity)).result;
            }
            if (newItem) {
                this.item = newItem;
                this.status = "unchanged";
                this.isEdit = false;
                await this.updateValueAsync();
            }
            else
                this.isEdit = false;
            this.editor = null;
            return newItem != null;
        }
        return false;
    }
    /********************************************/
    cancelEdit() {
        this.isEdit = false;
    }
    /********************************************/
    removeAsync() {
        throw "Not implemented";
    }
    /********************************************/
    clearErrors() {
        this.error = null;
    }
    /********************************************/
    async validateAsync(force) {
        if (this.isEdit) {
            if (TypeCheck_isValidable(this.editor))
                return await this.editor.validateAsync();
        }
        else {
            if (TypeCheck_isValidable(this.view))
                return await this.view.validateAsync();
        }
        return true;
    }
    /********************************************/
    async loadAsync() {
        this.updateView();
    }
    /********************************************/
    get itemsEditor() {
        return this.parentView;
    }
    /********************************************/
    error = null;
    addTitle = null;
    editTitle = null;
    editor = null;
    ;
    view = null;
    value = null;
    status = "unchanged";
    editMode = "external";
    isEdit = false;
}
/********************************************/
class Editors_ItemsEditor_ItemsEditor extends BaseEditor_BaseEditor {
    _changesCount = 0;
    _isUpdating = 0;
    constructor(config) {
        super({ template: "ItemsEditor", ...config });
        this.bindConfig("editMode", config);
        this.bindConfig("canAdd", config);
        this.bindConfig("canOpen", config);
        this.bindConfig("canRemove", config);
        this.bindConfig("isConfirmRemove", config);
        this.bindConfig("canEdit", config);
        this.bindConfig("itemsSource", config);
        this.bindConfig("itemActions", config);
        this.bindConfig("editActionsPriority", config);
        this.bindConfig("removeActionLabel", config);
        this.bindConfig("editActionLabel", config);
        if (config) {
            if (!config.editActionLabel)
                this.editActionLabel = Core_Helpers_Format/* Format.action */.E.action("edit-item", this.itemsSource?.displayName);
            if (!config.removeActionLabel)
                this.removeActionLabel = Core_Helpers_Format/* Format.action */.E.action("remove-item", this.itemsSource?.displayName);
            if (config.createItemAddEditor)
                this.createItemAddEditor = config.createItemAddEditor;
            if (config.createItemUpdateEditor)
                this.createItemUpdateEditor = config.createItemUpdateEditor;
            if (config.createItemView)
                this.createItemView = config.createItemView;
            if (config.attachItem)
                this.attachItem = config.attachItem;
            if (config.newItem)
                this.newItem = config.newItem;
            if (config.openItem) {
                this.openItem = config.openItem;
                if (config.canOpen == undefined)
                    this.canOpen = true;
            }
        }
        if (!this.itemsSource)
            this.itemsSource = new Items_EditableItemsSource_EditableItemsSource();
        this.addAction = Components_ActionView_ActionView.fromAction({
            name: "add-item",
            icon: "fas fa-plus",
            operation: Abstraction_IOperation_OperationType.Local,
            displayName: config?.addActionLabel ?? Core_Helpers_Format/* Format.action */.E.action("add-item", this.itemsSource.displayName),
            executeAsync: async () => await this.addAsync()
        });
        if (this.value)
            this.beginEditAsync(this.value);
    }
    /********************************************/
    async loadAsyncWork() {
        const awaiters = [];
        for (const item of this.content)
            awaiters.push(item.loadAsync());
        await Promise.all(awaiters);
    }
    /********************************************/
    clear() {
        this.content.clear();
    }
    /********************************************/
    clearErrors() {
        for (const item of this.content)
            item.clearErrors();
    }
    /********************************************/
    insert() {
    }
    /********************************************/
    async addAsync() {
        const item = this.newItem();
        this.attachItem(item, true);
        const itemView = this.createItem(this.itemToValue(item), item);
        itemView.item = item;
        itemView.status = "added";
        if (await itemView.editAsync()) {
            if ((0,Core_Linq/* linq */.k)(this.content).any(a => this.itemsSource.itemComparer(a.item, itemView.item)))
                return;
            this.content.add(itemView);
            await this.notifyEditValueChangedAsync();
        }
    }
    /********************************************/
    openItem(item) {
    }
    /********************************************/
    attachItem(item, isNew) {
    }
    /********************************************/
    isCapable(selector, item) {
        if (typeof selector == "boolean")
            return selector;
        return selector(item);
    }
    /********************************************/
    createItem(value, item) {
        const result = new ItemsEditor_ItemsEditorItemView({
            value: value,
            item: item,
            addTitle: Core_Helpers_Format/* Format.title */.E.title("add-item", this.itemsSource.displayName),
            editTitle: "",
            itemsSource: this.itemsSource,
            editActionsPriority: this.editActionsPriority,
            editActionLabel: this.editActionLabel,
            removeActionLabel: this.removeActionLabel,
            itemActions: this.itemActions,
            canRemove: this.isCapable(this.canRemove, item),
            canEdit: this.isCapable(this.canEdit, item),
            canOpen: this.isCapable(this.canOpen, item),
            open: () => this.openItem(result.item)
        });
        result.parentView = this;
        result.isConfirmRemove = this.isConfirmRemove;
        result.createAddEditor = () => this.createItemAddEditor(result.item);
        result.createUpdateEditor = () => this.createItemUpdateEditor(result.item);
        result.executeAddAsync = item => this.itemsSource.addItemAsync(item);
        result.executeUpdateAsync = editItem => this.itemsSource.updateItemAsync(editItem, result.item);
        result.loadAsync = async () => {
            if (!result.item) {
                result.item = await this.valueToItemAsync(result.value);
                result.canOpen = this.isCapable(this.canOpen, result.item);
                result.editTitle = Core_Helpers_Format/* Format.title */.E.title("edit-item", this.itemsSource.getItemText(result.item));
                this.attachItem(result.item, result.status != "added");
            }
            result.view = this.createItemView(result.item);
            result.updateView();
        };
        result.updateValueAsync = async () => {
            result.canOpen = this.isCapable(this.canOpen, result.item);
            result.value = this.itemToValue(result.item);
            result.view = this.createItemView(result.item);
            result.editTitle = Core_Helpers_Format/* Format.title */.E.title("edit-item", this.itemsSource.getItemText(result.item));
            result.updateView();
            await this.notifyEditValueChangedAsync();
        };
        result.removeAsync = async () => {
            if (result.status == "added")
                this.content.remove(result);
            else {
                if (this.isConfirmRemove) {
                    if (!await Interaction_Interaction.confirmAsync(Core_Helpers_Format/* Format.message */.E.message("msg-remove-confirm", this.itemsSource.displayName)))
                        return;
                }
                if (this.status == "none")
                    this.status = "loaded";
                result.status = "removed";
                await this.notifyEditValueChangedAsync();
            }
        };
        result.value = value;
        if (this.status != "none")
            result.loadAsync();
        return result;
    }
    /********************************************/
    itemToValue(item) {
        return item;
    }
    /********************************************/
    valueToItemAsync(value) {
        return Promise.resolve(value);
    }
    /********************************************/
    onItemChanged(oldValue, newValue) {
        this._needValidation = true;
        if (this._isUpdating) {
            this._changesCount++;
            return;
        }
        this.notifyEditValueChangedAsync();
    }
    /********************************************/
    set editValue(value) {
        if (!this.content || this._isUpdating)
            return;
        this._isUpdating++;
        this._changesCount = 0;
        this.content.clear();
        try {
            if (value) {
                for (const itemValue of value)
                    this.content.add(this.createItem(itemValue));
            }
        }
        finally {
            this._isUpdating--;
        }
        if (this._changesCount > 0)
            this.notifyEditValueChangedAsync();
    }
    /********************************************/
    get editValue() {
        const result = [];
        for (const item of this.content) {
            if (item.status == "removed")
                continue;
            result.push(item.value);
        }
        return result;
    }
    /********************************************/
    async validateAsyncWork(force) {
        let isValid = true;
        for (const item of this.content) {
            if (!await item.validateAsync(force))
                isValid = false;
        }
        return isValid;
    }
    /********************************************/
    async commitAsyncWork(force) {
        let isValid = true;
        let isChanged = false;
        /*
        for (var item of this.content) {
            if (item.isEdit) {
                if (!await item.commitAsync())
                    isValid = false;
            }
        }
        */
        if (!isValid)
            return false;
        for (let i = this.content.count - 1; i >= 0; i--) {
            const item = this.content.get(i);
            item.clearErrors();
            if (item.status == "removed") {
                if (await this.itemsSource.removeItemAsync(item.item))
                    this.content.removeAt(i);
                else {
                    this.error = "";
                    isValid = false;
                }
                isChanged = true;
            }
            else if (item.status == "modified" && !TypeCheck_isAsyncEditor(item.editor)) {
                const updateItem = await this.itemsSource.updateItemAsync(item.editor.value, item.item);
                if (updateItem) {
                    item.item = updateItem;
                    item.status = "unchanged";
                    item.updateView();
                }
                else {
                    this.error = "";
                    isValid = false;
                }
                isChanged = true;
            }
            else if (item.status == "added" && !TypeCheck_isAsyncEditor(item.editor)) {
                const addItem = await this.itemsSource.addItemAsync(item.editor.value);
                if (addItem) {
                    item.item = addItem;
                    item.status = "unchanged";
                    item.updateView();
                }
                else {
                    this.error = "";
                    isValid = false;
                }
                isChanged = true;
            }
        }
        if (isValid) {
            if (isChanged)
                this.onValueChanged(this.editValue);
        }
        return isValid;
    }
    /********************************************/
    newItem() {
        return this.itemsSource.newItem();
    }
    /********************************************/
    getItemViewContent(item) {
        return this.itemsSource ? this.itemsSource.getItemText(item) : item.toString();
    }
    /********************************************/
    createItemView(item) {
        return new Components_TextView_TextView({ content: this.getItemViewContent(item) });
    }
    /********************************************/
    createItemUpdateEditor(item) {
        throw "Not Supported";
    }
    /********************************************/
    createItemAddEditor(item) {
        throw "Not Supported";
    }
    /********************************************/
    content = Templating_ObservableList_observableListOf();
    editActionsPriority = Abstraction_IAction_ActionPriority.Secondary;
    editActionLabel = "Edit";
    removeActionLabel = "Remove";
    canAdd = true;
    canRemove = true;
    canEdit = false;
    canOpen = false;
    editMode = "inline";
    itemActions = [];
    itemsSource = null;
    addAction;
    isConfirmRemove = true;
}
ObjectUtils_registerType(Editors_ItemsEditor_ItemsEditor, "ItemsEditor");
ObjectUtils_registerType(ItemsEditor_ItemsEditorItemView, "ItemsEditorItemView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/MediaEditor.js







/****************************************/
class Editors_MediaEditor_MediaEditor extends BaseEditor_BaseEditor {
    constructor(config) {
        super({ template: "MediaEditor", ...config });
        this.bindConfig("noMediaUrl", config);
        this.bindConfig("maxFileSize", config);
        this.bindConfig("validMedias", config);
        if (config) {
            if (config.getUploadUrl)
                this.getUploadUrl = config.getUploadUrl;
            if (config.getMediaUrl)
                this.getMediaUrl = () => config.getMediaUrl(this.editValue);
        }
        this.mediaView = new Components_MediaView_MediaView({ image: { template: "ImageInline" }, video: { template: "VideoViewInline" }, ...config?.mediaView });
        this.fileUpload = new Components_FileUploadView_FileUploadView({
            onChanged: () => this.notifyEditValueChangedAsync()
        });
        this.fileUpload.visible = false;
        this.mediaView.content = {
            type: "empty"
        };
    }
    /********************************************/
    getUploadUrl(fileName) {
        throw "Not implemented";
    }
    /********************************************/
    validateAsyncWork(force) {
        if (this.fileUpload.status == "selected") {
            if (this.validMedias.indexOf("image") != -1 && this.fileUpload.file.type.startsWith("image/"))
                this.mediaView.content.type = "image";
            else if (this.validMedias.indexOf("video") != -1 && this.fileUpload.file.type.startsWith("video/"))
                this.mediaView.content.type = "video";
            else
                this.error = Core_Helpers_Format/* Format.message */.E.message("msg-invalid-media");
            if (this.maxFileSize && this.fileUpload.file.size > this.maxFileSize)
                this.error = Core_Helpers_Format/* Format.message */.E.message("msg-max-size", (this.maxFileSize / 1024 / 1024).toString());
        }
        return Promise.resolve(!this.error);
    }
    /********************************************/
    async commitAsyncWork(force) {
        if (this.fileUpload.status == "selected") {
            const result = await this.fileUpload.uploadAsync(this.getUploadUrl(this.fileUpload.file.name));
            this.editValue.id = result;
            this.editValue.status = "new";
            this.editValue.type = this.mediaView.content.type;
            this.mediaView.content = {
                src: this.getMediaUrl(),
                type: this.mediaView.content.type
            };
            this.notifyEditValueChangedAsync();
        }
        return true;
    }
    /********************************************/
    getMediaUrl() {
        throw "Not Implemented";
    }
    /********************************************/
    async beginEditAsync(value) {
        await super.beginEditAsync(value);
        if (!this.editValue)
            this.editValue = {
                id: null,
                type: "empty",
                status: "empty"
            };
        if (this.editValue.status == "empty")
            this.mediaView.content = {
                type: "image",
                src: this.noMediaUrl
            };
        else {
            this.mediaView.content = {
                type: this.editValue.type,
                src: this.getMediaUrl()
            };
        }
    }
    /****************************************/
    change() {
        this.fileUpload.visible = true;
        this.fileUpload.select();
    }
    /****************************************/
    remove() {
        this.editValue.status = "deleted";
        this.mediaView.content = {
            type: "image",
            src: this.noMediaUrl
        };
        this.notifyEditValueChangedAsync();
    }
    /****************************************/
    showMenu() {
        const menu = new Components_ContextMenu_ContextMenu();
        if (this.editValue.status == "new" || this.editValue.id) {
            menu.addAction({
                name: "remove-item",
                icon: "fas fa-trash",
                displayName: "delete",
                executeAsync: async () => this.remove()
            });
        }
        menu.addAction({
            name: "edit-item",
            icon: "fas fa-edit",
            displayName: "change",
            executeAsync: async () => this.change()
        });
        menu.showAsync(undefined, window.event);
    }
    /****************************************/
    fileUpload = null;
    mediaView = null;
    noMediaUrl = null;
    maxFileSize = null;
    validMedias = ["video", "image"];
}
ObjectUtils_registerType(Editors_MediaEditor_MediaEditor, "MediaEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/MultiItemPicker.js









/****************************************/
class Editors_MultiItemPicker_MultiItemPicker extends BasePicker_BasePicker {
    constructor(config) {
        super(config);
    }
    /****************************************/
    async selectAsync() {
        let mustRefresh = false;
        if (this.selector == null) {
            this.selector = new SelectMultipleItemsActivity_SelectMultipleItemsActivity({
                createItemEditor: () => this.createItemEditor(),
                createItemContentView: item => this.createItemView(item),
                createItemListView: item => this.createItemListView(item),
                itemsSource: this.itemsSource,
                addLabel: this.addLabel,
                searchMode: this.searchMode,
                tooltip: this.pickLabel,
                canAdd: this.canAdd
            });
            this.selector.filters = this.filters;
        }
        else
            mustRefresh = true;
        this.selector.setSelectedItems((0,Core_Linq/* linq */.k)(this.items).select(a => a.item).toArray());
        if (mustRefresh)
            await this.selector.refreshAsync();
        const result = await (await Helpers_Actions_Actions.loadPageAsync(this.selector)).result;
        if (result != null) {
            const newValue = (0,Core_Linq/* linq */.k)(result).select(a => this.itemsSource.getItemValue(a)).toArray();
            if (!ArrayUtils_equalsArray(newValue, this.editValue))
                this.editValue = newValue;
        }
    }
    /********************************************/
    valueToEdit(value) {
        return value ? value.slice() : [];
    }
    /********************************************/
    editToValue(value) {
        return value ? value.slice() : [];
    }
    /****************************************/
    async updateViewAsync() {
        if (this.status == "loading")
            return;
        this.items.clear();
        if (this.editValue) {
            this.status = "loading";
            try {
                for (const value of this.editValue) {
                    const item = await this.itemsSource.getItemByValueAsync(value);
                    if (!item)
                        continue;
                    const itemView = new Components_RemovableItemView_RemovableItemView({
                        item: item,
                        content: this.createItemView(item),
                        removeAsync: async () => {
                            this.items.remove(itemView);
                            const value = this.itemsSource.getItemValue(itemView.item);
                            const index = (0,Core_Linq/* linq */.k)(this.editValue).indexOf(a => this.itemsSource.equals(a, value));
                            this.editValue.splice(index, 1);
                            await this.notifyEditValueChangedAsync();
                        }
                    });
                    this.items.add(itemView);
                }
            }
            finally {
                this.status = "loaded";
            }
        }
    }
    /****************************************/
    selector = null;
    items = Templating_ObservableList_observableListOf();
}
ObjectUtils_registerType(Editors_MultiItemPicker_MultiItemPicker, "MultiItemPicker");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/ObjectEditor.js




/********************************************/
class ObjectEditor_ObjectEditor extends BaseEditor_BaseEditor {
    _proxy;
    _changesCount = 0;
    _isUpdating = 0;
    _onPropertyChanged;
    constructor(config) {
        super({ template: "ItemsViewForm", validationMode: "always", commitMode: "manual", ...config });
        this.bindConfig("propertyTemplateName", config);
        this.bindConfig("defaultProperty", config);
        this.bindConfig("emptyView", config);
        this.prop("content");
        if (config) {
            this._onPropertyChanged = config.onPropertyChanged;
            if (config.properties) {
                for (const propName in config.properties) {
                    config.properties[propName].name = propName;
                    this.addProperty(config.properties[propName]);
                }
            }
        }
        this.createProxy();
        if (!ObjectUtils_isEmpty(this.value))
            this.beginEditAsync(this.value);
    }
    /********************************************/
    addProperty(config) {
        const item = new Components_PropertyView_PropertyView({
            name: config.name,
            template: this.prop("propertyTemplateName"),
            ...config,
            host: this
        });
        this.properties[config.name] = item;
        return item;
    }
    /********************************************/
    async beginEditWorkAsync(value) {
        if (!this.value)
            this.value = {};
        this.isDirty = true;
        for (const propName in this.properties) {
            const prop = this.properties[propName];
            if (prop.value != undefined)
                await prop.editor.beginEditAsync(prop.value);
        }
    }
    /********************************************/
    clearErrors() {
        for (const propName in this.properties)
            this.properties[propName].error = null;
    }
    /********************************************/
    async validateAsyncWork(force) {
        let isValid = true;
        const curValue = this.editValue;
        for (const propName in this.properties) {
            const prop = this.properties[propName];
            if (!await prop.validateAsync(curValue, force)) {
                this.isValid = false;
                isValid = false;
            }
        }
        return isValid;
    }
    /********************************************/
    createProxy() {
        this._proxy = {};
        this.content.clear();
        for (const propName in this.properties) {
            const curProp = this.properties[propName];
            curProp.prop("value").subscribe((value, oldValue) => this.onPropertyValueChanged(propName, value, oldValue));
            curProp.prop("isValid").subscribe(value => {
                if (!value)
                    this.isValid = false;
            });
            curProp.prop("isDirty").subscribe(value => {
                if (value)
                    this.isDirty = true;
            });
            this.content.add(curProp);
            Object.defineProperty(this._proxy, propName, {
                enumerable: true,
                get: () => curProp.value,
                set: value => curProp.value = value
            });
        }
    }
    /********************************************/
    activateAsync() {
        if (this.defaultProperty)
            return this.editor(this.defaultProperty).activateAsync();
        return Promise.resolve();
    }
    /********************************************/
    async loadAsyncWork() {
        const awaiters = [];
        for (const propName in this.properties)
            awaiters.push(this.properties[propName].loadAsync());
        await Promise.all(awaiters);
    }
    /********************************************/
    clear() {
        this._isUpdating++;
        try {
            for (const propName in this.properties)
                this.property(propName).clear();
        }
        finally {
            this._isUpdating--;
        }
    }
    /********************************************/
    editToValue(value) {
        return undefined;
    }
    /********************************************/
    async commitAsyncWork(force) {
        let isChanged = false;
        let isValid = true;
        if (!this.value)
            this.value = {};
        for (const propName in this.properties) {
            const commitResult = await this.commitPropertyAsync(propName, false);
            if (!commitResult.isValid)
                isValid = false;
            if (!commitResult.isChanged)
                isChanged = true;
        }
        if (isValid) {
            if (isChanged)
                this.onValueChanged(this.value);
        }
        return isValid;
    }
    /********************************************/
    async commitPropertyAsync(propName, validate) {
        const result = {
            isValid: true,
            isChanged: false
        };
        const prop = this.property(propName);
        if (validate && !await prop.validateAsync(this.editValue, false))
            result.isValid = false;
        else if (!await prop.editor.commitAsync())
            result.isValid = false;
        else {
            if (!ObjectUtils_equals(prop.value, this.value[propName])) {
                this.value[propName] = prop.value;
                result.isChanged = true;
            }
        }
        return result;
    }
    /********************************************/
    editor(propName) {
        return this.properties[propName].editor;
    }
    /********************************************/
    property(propName) {
        return this.properties[propName];
    }
    /********************************************/
    async onPropertyValueChanged(propName, value, oldValue) {
        this._needValidation = true;
        if (this._isUpdating || this._isEditing) {
            this._changesCount++;
            return;
        }
        if (this.commitMode == "onchange") {
            const commitResult = await this.commitPropertyAsync(propName, true);
            if (commitResult.isChanged) {
                this._needValidation = true;
                this.isDirty = true;
            }
        }
        else
            await this.notifyEditValueChangedAsync();
        if (this._onPropertyChanged)
            this._onPropertyChanged(propName, value, oldValue, this._proxy);
    }
    /********************************************/
    set editValue(value) {
        if (this._isUpdating)
            return;
        this._isUpdating++;
        this._changesCount = 0;
        try {
            if (ObjectUtils_isEmpty(value))
                this.clear();
            else {
                for (const propName in this.properties)
                    this._proxy[propName] = value[propName];
            }
        }
        finally {
            this._isUpdating--;
        }
        if (this._changesCount > 0)
            this.notifyEditValueChangedAsync();
    }
    /********************************************/
    get editValue() {
        return this._proxy;
    }
    /********************************************/
    properties = {};
    defaultProperty = null;
    propertyTemplateName = "PropertyView";
    emptyView = null;
    content = Templating_ObservableList_observableListOf();
}
ObjectUtils_registerType(ObjectEditor_ObjectEditor, "ObjectEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/RichTextEditor.js



/****************************************/
class RichTextEditor_RichTextEditor extends BaseTextEditor_BaseTextEditor {
    constructor(config) {
        super({ template: "Attach", ...config });
    }
    /****************************************/
    attach(element) {
        this.editor = new Quill(element, {
            theme: "snow",
        });
        this.editor.root.innerHTML = this.value;
        this.editor.on("text-change", () => this.notifyEditValueChangedAsync());
    }
    /****************************************/
    set editValue(value) {
        if (this.editor)
            this.editor.root.innerHTML = value;
    }
    get editValue() {
        if (this.editor)
            return this.editor.root.innerHTML;
        return this.value;
    }
    /****************************************/
    editor;
}
ObjectUtils_registerType(RichTextEditor_RichTextEditor, "RichTextEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/SectionEditor.js







/********************************************/
class SectionEditor_SectionEditorView extends ViewComponent_ViewComponent {
    constructor(config) {
        super(config);
        this.bindConfig("editor", config);
        this.bindConfigString("title", config);
    }
    /********************************************/
    title = null;
    editor;
}
/********************************************/
class Editors_SectionEditor_SectionEditor extends BaseEditor_BaseEditor {
    constructor(config) {
        super({ template: "SectionEditor", ...config });
        this.navBar = new Components_NavBar_NavBar({
            styles: ["tab-view", "surface"],
            itemTemplate: "TextView",
            itemBehavoirs: ["ripple"],
            selectedItem: this.prop("activeSectionName")
        });
        if (config) {
            if (config.sections)
                config.sections.forEach(a => this.addSection(a));
        }
        if (this.sections.count > 0)
            this.activeSectionName = this.sections.get(0).name;
        this.createEditValueProp();
    }
    /********************************************/
    async loadAsyncWork() {
        for (const section of this.sections) {
            if (section.editor)
                await section.editor.loadAsync();
        }
    }
    /********************************************/
    async beginEditWorkAsync(value) {
        for (const section of this.sections) {
            if (section.editor)
                await section.editor.beginEditAsync(value);
        }
    }
    /********************************************/
    async validateAsyncWork(force) {
        let isValid = true;
        for (const section of this.sections) {
            if (section.editor)
                if (!await section.editor.validateAsync(force)) {
                    isValid = false;
                    this.activeSectionName = section.name;
                }
        }
        return isValid;
    }
    /********************************************/
    async commitAsyncWork(force) {
        let isValid = true;
        for (const section of this.sections) {
            if (section.editor)
                if (!await section.editor.commitAsync(force))
                    isValid = false;
        }
        return isValid;
    }
    /********************************************/
    getSection(name) {
        return (0,Core_Linq/* linq */.k)(this.sections).first(a => a.name == name);
    }
    /********************************************/
    addSection(config) {
        const item = new SectionEditor_SectionEditorView(config);
        this.sections.add(item);
        this.navBar.addItem({
            text: item.prop("title"),
            name: item.name,
            content: item
        });
        return item;
    }
    /********************************************/
    sections = Templating_ObservableList_observableListOf();
    navBar;
    activeSectionName = null;
}
ObjectUtils_registerType(SectionEditor_SectionEditorView, "SectionEditorView");
ObjectUtils_registerType(Editors_SectionEditor_SectionEditor, "SectionEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/SingleItemPicker.js






/****************************************/
class Editors_SingleItemPicker_SingleItemPicker extends BasePicker_BasePicker {
    constructor(config) {
        super(config);
        this.clearAction = Components_ActionView_ActionView.fromActionIcon({
            name: "clear",
            icon: "fas fa-times",
            displayName: "clear",
            executeAsync: () => Promise.resolve(this.clear())
        });
    }
    /****************************************/
    async selectAsync() {
        let mustRefresh = false;
        if (this.selector == null) {
            this.selector = new SelectSingleItemActivity_SelectSingleItemActivity({
                itemsSource: this.itemsSource,
                createItemEditor: () => this.createItemEditor(),
                createItemContentView: item => this.createItemListView(item),
                pageSize: this.pageSize,
                addLabel: this.addLabel,
                tooltip: this.pickLabel,
                canAdd: this.canAdd
            });
            this.selector.filters = this.filters;
        }
        else
            mustRefresh = true;
        this.selector.selectedValue = this.editValue;
        if (mustRefresh)
            await this.selector.refreshAsync();
        const result = await (await Helpers_Actions_Actions.loadPageAsync(this.selector)).result;
        if (result != null)
            this.editValue = this.itemsSource.getItemValue(result);
    }
    /****************************************/
    createItemEditor() {
        throw "Not Supported";
    }
    /****************************************/
    async updateViewAsync() {
        if (this.status == "loading")
            return;
        if (this.editValue) {
            this.status = "loading";
            try {
                const item = await this.itemsSource.getItemByValueAsync(this.editValue);
                this.contentView = this.createItemView(item);
            }
            finally {
                this.status = "loaded";
            }
        }
        else
            this.contentView = null;
    }
    /****************************************/
    selector = null;
    contentView = null;
    clearAction = null;
}
ObjectUtils_registerType(Editors_SingleItemPicker_SingleItemPicker, "SingleItemPicker");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/MultiItemSelector.js








/****************************************/
class MultiItemSelector_MultiItemSelector extends BaseEditor_BaseEditor {
    constructor(config) {
        super({ template: "SelectEditor", ...config });
        this.bindConfig("itemsSource", config);
        this.bindConfig("itemTemplate", config);
        this.bindConfigString("placeholder", config);
        if (config?.createItemView)
            this.createItemViewWork = config?.createItemView;
        if (config?.items) {
            config.items.forEach(a => this.items.add(this.createItemView(a)));
            this.status = "loaded";
        }
    }
    /********************************************/
    async selectAsync() {
        const editor = new Editors_PopupEditor_PopUpEditor({
            editor: new MultiItemSelector_MultiItemSelector({
                template: "MultiItemSelectorList",
                itemsSource: this.itemsSource,
                styles: ["no-padding-items-h"]
            }),
            saveOnCommit: true,
            saveLabel: "select",
            closeLabel: "cancel",
            title: "select-an-item",
            styles: [""]
        });
        const result = await editor.editAsync(this.value);
        if (result !== null)
            this.editValue = result;
    }
    /********************************************/
    findItemByValue(value) {
        if (this.itemsSource)
            return (0,Core_Linq/* linq */.k)(this.items).first(a => this.itemsSource.equals(a.item, value));
        return (0,Core_Linq/* linq */.k)(this.items).first(a => a.item == value);
    }
    /********************************************/
    set editValue(value) {
        for (const item of this.items) {
            item.isSelected = value && (0,Core_Linq/* linq */.k)(value).any(a => Item_Item.getValue(a) == Item_Item.getValue(item.item));
        }
    }
    get editValue() {
        return (0,Core_Linq/* linq */.k)(this.items).where(a => a.isSelected).select(a => a.item).toArray();
    }
    /****************************************/
    async loadAsyncWork() {
        if (this.itemsSource) {
            this.items.clear();
            const items = await this.itemsSource.getItemsAsync(this.itemsSource.getFilter());
            if (items)
                items.forEach(a => this.items.add(this.createItemView(a)));
        }
        this.isDirty = true;
    }
    /****************************************/
    createItemViewWork(item) {
        if (this.itemsSource)
            return new Components_SelectableItemView_SelectableItemView({
                item: this.itemsSource.getItemValue(item),
                content: this.itemsSource.getItemText(item),
                template: this.itemTemplate
            });
    }
    /****************************************/
    createItemView(item) {
        const itemView = this.createItemViewWork(item);
        itemView.prop("isSelected").subscribe(value => {
            if (value)
                this.notifyEditValueChangedAsync();
        });
        return itemView;
    }
    /****************************************/
    itemTemplate = "SelectableItemView";
    placeholder = null;
    itemsSource = null;
    items = Templating_ObservableList_observableListOf();
}
ObjectUtils_registerType(MultiItemSelector_MultiItemSelector, "MultiItemSelector");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/TextEditor.js




/********************************************/
class Editors_TextEditor_TextEditor extends BaseTextEditor_BaseTextEditor {
    constructor(config) {
        super({ template: "TextEditor", ...config });
        this.bindConfigString("placeholder", config, Types_DynamicString/* StringUsage.Tooltip */.Fq.Tooltip);
        this.bindConfig("lineCount", config);
        this.bindConfig("maxLength", config);
        this.bindConfig("trackMode", config);
        this.createEditValueProp();
    }
    /********************************************/
    placeholder = null;
    lineCount = 1;
    maxLength = null;
}
ObjectUtils_registerType(Editors_TextEditor_TextEditor, "TextEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Editors/TimeEditor.js



/********************************************/
class TimeEditor_TimeEditor extends BaseTextEditor_BaseTextEditor {
    constructor(config) {
        super({ template: "TimeEditor", ...config });
        this.bindConfig("placeholder", config);
        this.createEditValueProp();
    }
    /********************************************/
    valueToEdit(value) {
        return value === null || value === undefined ? "" : value.format("{hh}:{mm}");
    }
    /********************************************/
    editToValue(value) {
        if (value === undefined || value === null)
            return null;
        const parts = value.split(':');
        if (parts.length != 2)
            return null;
        return Types_TimeSpan_TimeSpan.fromMinutes(parseInt(parts[0]) * 60 + parseInt(parts[1]));
    }
    /********************************************/
    placeholder = null;
}
ObjectUtils_registerType(TimeEditor_TimeEditor, "TimeEditor");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/Components.js

var Components_Components;
(function (Components) {
    function sections(config) {
        return new Components_SectionsView_SectionsView(config);
    }
    Components.sections = sections;
})(Components_Components || (Components_Components = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/Editors.js









var Editors_Editors;
(function (Editors) {
    function richText() {
        return new RichTextEditor_RichTextEditor();
    }
    Editors.richText = richText;
    /****************************************/
    function currency() {
        return new NumberEditor_NumberEditor({
            allowNull: false,
            min: 0.01,
        });
    }
    Editors.currency = currency;
    /****************************************/
    function converter(editor, itemToEdit, editToItem) {
        return new ItemEditorConverter_ItemEditorConverter({
            editor: editor,
            editToItem: editToItem,
            itemToEdit: itemToEdit
        });
    }
    Editors.converter = converter;
    /****************************************/
    function items(config) {
        return new Editors_ItemsEditor_ItemsEditor({ ...config });
    }
    Editors.items = items;
    /****************************************/
    function text(config) {
        return new Editors_TextEditor_TextEditor({ ...config });
    }
    Editors.text = text;
    /****************************************/
    function textMultiLine(config) {
        return new Editors_TextEditor_TextEditor({ template: "TextEditorMultiLine", ...config });
    }
    Editors.textMultiLine = textMultiLine;
    /****************************************/
    function number(config) {
        return new NumberEditor_NumberEditor({ ...config });
    }
    Editors.number = number;
    /****************************************/
    function boolean(config) {
        return new Editors_BooleanEditor_BooleanEditor({ ...config });
    }
    Editors.boolean = boolean;
    /****************************************/
    function password(config) {
        return new Editors_TextEditor_TextEditor({ template: "PasswordEditor", ...config });
    }
    Editors.password = password;
    /****************************************/
    function object(config) {
        return new ObjectEditor_ObjectEditor(config);
    }
    Editors.object = object;
    /****************************************/
    function address(config) {
        return new Editors_TextEditor_TextEditor({ template: "TextEditorMultiLine", ...config });
    }
    Editors.address = address;
    /****************************************/
    function birthDate(minAge, config) {
        return new Editors_DateEditorCombo_DateEditorCombo({ maxYear: new Date().getFullYear() - (minAge ?? 0), minYear: new Date().getFullYear() - 100 });
    }
    Editors.birthDate = birthDate;
    /****************************************/
    function singleItemSelector(config) {
        return new Editors_SingleItemSelector_SingleItemSelector(config);
    }
    Editors.singleItemSelector = singleItemSelector;
})(Editors_Editors || (Editors_Editors = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/ItemsSources.js



function ItemsSources_repositoryItems(repo, config) {
    return new ItemsSource({
        getItemsAsync: async (filter) => Array.from(await repo.listAsync(filter)),
        getItemByValueAsync: value => repo.getByIdAsync(value),
        ...config
    });
}
/****************************************/
function ItemsSources_staticItems(items, allowZero = false) {
    return new ItemsSource({
        typeName: "WebApp.ISimpleItem",
        getItemValue: a => a.value,
        getItemText: a => Format.title(a.text),
        getItemsAsync: () => Promise.resolve(items),
        getItemByValueAsync: value => Promise.resolve(linq(items).first(a => a.value == value)),
        allowZero: allowZero
    });
}
/****************************************/
function ItemsSources_arrayItems(items) {
    return new ItemsSource({
        getItemsAsync: () => Promise.resolve(items)
    });
}
/****************************************/
function ItemsSources_actionItems(items) {
    return new ItemsSource({
        typeName: "WebApp.IAction",
        getItemText: a => Format.text(a.displayName),
        getItemsAsync: () => Promise.resolve(items),
        allowZero: false
    });
}

// EXTERNAL MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/Loaders.js
var Helpers_Loaders = __webpack_require__(2560);
;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Helpers/Validators.js

var Validators_Validators;
(function (Validators) {
    const EMAIL_REGEXP = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    const PHONE_REGEXP = /^[+]*[(]{0,1}[0-9]{1,4}[)]{0,1}[-\s\./0-9]*$/;
    Validators.required = {
        validateAsync: ctx => Promise.resolve({
            isValid: ctx.value != null && ctx.value != "" && (!Array.isArray(ctx.value) || ctx.value.length > 0),
            error: Core_Helpers_Format/* Format.message */.E.message("msg-specify-value", ctx.fieldName)
        })
    };
    /****************************************/
    function minValue(value) {
        return {
            validateAsync: ctx => Promise.resolve(({
                isValid: ctx.value >= value,
                error: Core_Helpers_Format/* Format.message */.E.message("msg-insert-greater-than", value.toString())
            }))
        };
    }
    Validators.minValue = minValue;
    ;
    /****************************************/
    function maxValue(value) {
        return {
            validateAsync: ctx => Promise.resolve(({
                isValid: ctx.value <= value,
                error: Core_Helpers_Format/* Format.message */.E.message("msg-insert-less-than", value.toString()),
            }))
        };
    }
    Validators.maxValue = maxValue;
    ;
    /****************************************/
    Validators.integer = {
        validateAsync: ctx => Promise.resolve(({
            isValid: Math.round(ctx.value) == ctx.value,
            error: Core_Helpers_Format/* Format.message */.E.message("msg-insert-int-number"),
        }))
    };
    /****************************************/
    Validators.phone = {
        validateAsync: ctx => Promise.resolve(({
            isValid: ctx.value && ctx.value.length >= 9 && PHONE_REGEXP.test(ctx.value.toLowerCase()),
            error: Core_Helpers_Format/* Format.message */.E.message("msg-invalid-phone", ctx.value)
        }))
    };
    /****************************************/
    Validators.email = {
        validateAsync: ctx => Promise.resolve(({
            isValid: ctx.value && EMAIL_REGEXP.test(ctx.value.toLowerCase()),
            error: Core_Helpers_Format/* Format.message */.E.message("msg-invalid-email", ctx.value)
        }))
    };
    /****************************************/
    function custom(validator) {
        return {
            validateAsync: async (ctx) => await validator(ctx)
        };
    }
    Validators.custom = custom;
    ;
})(Validators_Validators || (Validators_Validators = {}));

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Items/CachedEditableItemsSource.js




/****************************************/
class CachedEditableItemsSource_CachedEditableItemsSource extends (/* unused pure expression or super */ null && (EditableItemsSource)) {
    constructor(config) {
        super();
        if (config) {
            this.source = config.source;
            this.cache = config.cache;
            if (config.filterItem)
                this.filterItem = (filter, item) => config.filterItem(filter, item, this.items);
            if (config.finalize)
                this.finalize = config.finalize;
        }
        if (!this.cache)
            this.cache = {
                key: new Date().getTime().toString(),
                lastUpdateTime: null,
                value: null
            };
        if (!this.cache.updateComplete)
            this.cache.updateComplete = new Signal(true);
        if (!this.cache.value)
            this.cache.value = new Map();
        else if (this.cache.value.size > 0)
            this.cache.lastUpdateTime = new Date();
    }
    /****************************************/
    getItemText(item) {
        return this.source.getItemText(item);
    }
    /****************************************/
    getItemValue(item, bindItem) {
        return this.source.getItemValue(item, bindItem);
    }
    /****************************************/
    getFilter(text, offset, pageSize) {
        return this.source.getFilter(text, offset, pageSize);
    }
    /****************************************/
    equals(a, b) {
        return this.source.equals(a, b);
    }
    /********************************************/
    newItem() {
        return this.source.newItem();
    }
    /****************************************/
    finalize(filter, items) {
    }
    /****************************************/
    async countAsync(filter) {
        return linq(this.items.entries()).select(a => a[1]).where(a => this.filterItem(filter, a)).count();
    }
    /****************************************/
    async getItemsAsync(filter) {
        await this.updateCacheAsync(false);
        const items = await linq(this.items.entries()).select(a => a[1]).where(a => this.filterItem(filter, a)).toArrayAsync(10);
        this.finalize(filter, items);
        return items;
    }
    /****************************************/
    async getItemByValueAsync(value) {
        await this.updateCacheAsync(false);
        if (value == null)
            return null;
        if (typeof value == "object" && typeof value["valueOf"] == "function")
            value = value["valueOf"]();
        return Promise.resolve(this.items.get(value));
    }
    /********************************************/
    async addItemAsync(item) {
        const newItem = await this.source.addItemAsync(item);
        if (newItem != null)
            this.items.set(this.getItemValue(newItem, false), newItem);
        return newItem;
    }
    /********************************************/
    async updateItemAsync(item) {
        const newItem = await this.source.updateItemAsync(item);
        if (newItem != null)
            this.items.set(this.getItemValue(newItem, false), newItem);
        return newItem;
    }
    /********************************************/
    async removeItemAsync(item) {
        const result = await this.source.removeItemAsync(item);
        if (result)
            this.items.delete(this.getItemValue(item, false));
        return result;
    }
    /****************************************/
    filterItem(filter, item) {
        return true;
    }
    /****************************************/
    async readCacheAsync() {
        if (this.cache.key)
            return await Services.dbStorage.getItem(this.cache.key);
    }
    /****************************************/
    async writeCacheAsync(items) {
        if (this.cache.key)
            await Services.dbStorage.setItem(this.cache.key, items);
    }
    /****************************************/
    async updateCacheAsync(force) {
        if (this.cache.lastUpdateTime && !force)
            return;
        if (!this.cache.updateComplete.isSet) {
            await this.cache.updateComplete.waitFor();
            return;
        }
        this.cache.updateComplete.reset();
        try {
            let newItems;
            try {
                newItems = await this.source.getItemsAsync(this.filter);
            }
            catch (ex) {
                console.error(ex);
            }
            let mustUpdate = true;
            if (newItems == null) {
                newItems = await this.readCacheAsync();
                mustUpdate = false;
            }
            if (newItems != null) {
                this.items.clear();
                for (const item of newItems)
                    this.items.set(this.getItemValue(item, false), item);
                this.cache.lastUpdateTime = new Date();
                if (mustUpdate)
                    await this.writeCacheAsync(newItems);
            }
        }
        finally {
            this.cache.updateComplete.set();
        }
    }
    /****************************************/
    get typeName() {
        return this.source.typeName;
    }
    get allowZero() {
        return this.source.allowZero;
    }
    get itemComparer() {
        return this.source.itemComparer;
    }
    get items() {
        return this.cache.value;
    }
    /****************************************/
    source = null;
    cache = null;
    filter = null;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Services/AppContentManager.js

class AppContentManager_AppContentManager {
    constructor(contents) {
        this.contents = contents;
    }
    /****************************************/
    get(name) {
        return linq(this.contents).first(a => a.name == name);
    }
    /****************************************/
    actionFor(name) {
        const content = this.get(name);
        return {
            executeAsync: content.openAsync,
            name: content.name,
            displayName: content.displayName,
            icon: content.icon
        };
    }
    /****************************************/
    contents;
}

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/View/Services/PermissionManager.js










/****************************************/
class Services_PermissionManager_PermissionRequestItemView extends ViewComponent_ViewComponent {
    constructor(request) {
        super();
        this.request = request;
        this.switchView = new Editors_BooleanEditor_BooleanEditor({
            label: this.request.permission.name,
            template: "Switch",
            styles: ["primary"]
        });
        this.switchView.beginEditAsync(request.granted);
    }
    /****************************************/
    request = null;
    switchView = null;
    isShowInfo = false;
}
/****************************************/
class PermissionManager_PermissionEditor extends (/* unused pure expression or super */ null && (BindableObject)) {
    _listView = null;
    beginEditAsync(item) {
        const panel = new Panel({
            styles: ["vertical"]
        });
        this._listView = panel.addView(new ListView({
            styles: ["surface"],
            items: observableListOf(item),
            isAutoLoad: true,
            createItemView: item => new Services_PermissionManager_PermissionRequestItemView(item)
        }));
        panel.addView(new IconTextView({ text: "msg-permission-request", styles: ["message warning"] }));
        this.view = panel;
        this.value = item;
        return Promise.resolve();
    }
    /****************************************/
    commitAsync(force) {
        for (const item of this._listView.content)
            item.request.granted = item.switchView.editValue;
        return Promise.resolve(true);
    }
    /****************************************/
    view = null;
    value = null;
    isValid = true;
}
/****************************************/
class PermissionManager_PermissionManager {
    constructor() {
    }
    /****************************************/
    async requireAsync(...permissions) {
        const toAsk = [];
        const result = {};
        for (const perm of permissions) {
            if (!(await perm.permission.isGranted()))
                toAsk.push(perm);
            else {
                result[perm.permission.name] = true;
                perm.granted = true;
            }
        }
        if (toAsk.length > 0) {
            const editor = new PopUpEditor({
                editor: new PermissionManager_PermissionEditor(),
                saveLabel: "accept",
                savePriority: ActionPriority.Evidence,
                title: "permission-request",
            });
            const editResult = await editor.editAsync(toAsk);
            if (editResult) {
                for (const item of editResult) {
                    if (item.granted)
                        item.granted = await item.permission.ask();
                    result[item.permission.name] = item.granted;
                }
            }
        }
        return result;
    }
    /****************************************/
    geolocation = {
        name: "geolocation",
        ask: () => new Promise(res => {
            function setResult(result) {
                localStorage.setItem("geolocation", result ? "granted" : "denied");
                res(result);
            }
            navigator.geolocation.getCurrentPosition(() => setResult(true), error => setResult(error.code != error.PERMISSION_DENIED), { maximumAge: Infinity, timeout: 2000 });
        }),
        isGranted: async () => {
            if ("permissions" in navigator)
                return (await navigator.permissions.query({ name: "geolocation" })).state == "granted";
            return localStorage.getItem("geolocation") == "granted";
        }
    };
    /****************************************/
    notification = {
        name: "notification",
        ask: () => new Promise(res => {
            if (!("Notification" in window)) {
                console.warn("Notification not supported");
                res(false);
            }
            Notification.requestPermission(p => {
                res(p == "granted");
            });
        }),
        isGranted: () => Promise.resolve(!("Notification" in window) ? true : Notification.permission == "granted")
    };
}
ObjectUtils_registerType(Services_PermissionManager_PermissionRequestItemView, "PermissionRequestItemView");

;// CONCATENATED MODULE: ./obj/js/Eusoft/WebApp/src/Eusoft.WebApp/Scripts/index.js
/**
 * @file Automatically generated by barrelsby.
 */






































































































































































































































;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Framework/Operation.js

class BaseOperation {
    _progress;
    _type;
    /****************************************/
    constructor(config) {
        if (!config.type)
            this._type = IOperation_OperationType.Global;
        else
            this._type = config.type;
        this.parentOperation = config.parentOperation;
    }
    /****************************************/
    end() {
        Operation.end(this);
    }
    /****************************************/
    get type() {
        return this._type;
    }
    /****************************************/
    get progress() {
        return this._progress;
    }
    /****************************************/
    set progress(value) {
        this._progress = value;
        if (this._progress) {
            console.log(this.getProgressDescription(this._progress));
            if (this._progress.message)
                this.message = this._progress.message;
            Operation.onProgress.raise(this, { operation: this, progress: value });
        }
        else
            this.message = undefined;
    }
    /****************************************/
    addSubOperation(op) {
    }
    /****************************************/
    removeSubOperation(op) {
    }
    /****************************************/
    getProgressDescription(value) {
        let msg = "Progress (" + this.message + "): ";
        if (value.message)
            msg += "'" + value.message + "'";
        if (value.current != null && value.totCount != null)
            msg += " - " + value.current + "/" + value.totCount + " (" + Math.round(100 / value.totCount * value.current) + "%)";
        else if (value.current != null)
            msg += value.current;
        return msg;
    }
    /****************************************/
    message = null;
    parentOperation = null;
}
/****************************************/
class BaseOperationManager {
    _oprations = [];
    progress(progress) {
        if ((0,TypeCheck/* isString */.HD)(progress))
            progress = { message: progress };
        if (this.current)
            this.current.progress = progress;
    }
    /****************************************/
    begin(configOrMessge) {
        if ((0,TypeCheck/* isString */.HD)(configOrMessge))
            configOrMessge = { message: configOrMessge };
        let operation = new BaseOperation(configOrMessge);
        console.group("Begin operation: ", $string(operation.message ?? ""));
        operation.progress = configOrMessge;
        if (operation.parentOperation === undefined)
            operation.parentOperation = this.current;
        this._oprations.push(operation);
        if (!operation.parentOperation) {
            if (operation.type == IOperation_OperationType.Global) {
            }
        }
        else
            operation.parentOperation.addSubOperation(operation);
        this.onBegin.raise(this, operation);
        return operation;
    }
    /****************************************/
    end(operation) {
        console.groupEnd();
        console.log("End operation: ", $string(operation.message ?? ""));
        const index = this._oprations.indexOf(operation);
        this._oprations.splice(index, 1);
        if (operation.parentOperation)
            operation.parentOperation.removeSubOperation(operation);
        else {
            if (operation.type == IOperation_OperationType.Global) {
            }
        }
        this.onEnd.raise(this, operation);
    }
    /****************************************/
    get current() {
        return this._oprations.length > 0 ? this._oprations[this._oprations.length - 1] : null;
    }
    /****************************************/
    get operations() {
        return this._oprations;
    }
    /****************************************/
    onBegin = Event_event();
    onEnd = Event_event();
    onProgress = Event_event();
}
/****************************************/
var Operation = new BaseOperationManager();

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Framework/SplitEnumerator.js
class SplitEnumerator {
    _separator;
    _value;
    _startIndex;
    _curIndex;
    _currentStartIndex;
    _current;
    constructor(value, separator, startIndex = 0) {
        this._value = value;
        this._separator = separator;
        this._startIndex = startIndex;
    }
    /****************************************/
    get current() {
        if (!this._current)
            this._current = this._value.substring(this._currentStartIndex, this._curIndex - this._separator.length);
        return this._current;
    }
    /****************************************/
    moveNext() {
        if (this._curIndex > this._value.length)
            return false;
        this._currentStartIndex = this._curIndex;
        var index = this._value.indexOf(this._separator, this._curIndex);
        if (index == -1) {
            this._curIndex = this._value.length + 1;
        }
        else
            this._curIndex = index + this._separator.length;
        this._current = null;
        return true;
    }
    /****************************************/
    reset() {
        this._curIndex = this._startIndex;
        this._currentStartIndex = this._curIndex;
        this._current = null;
    }
}
/****************************************/
class CsvSplitEnumerator {
    _state = 0;
    _wordLength = 0;
    _wordStartIndex;
    _separator;
    _value;
    _startIndex;
    _curIndex;
    _current;
    _hasEscape;
    /****************************************/
    constructor(value, separator, startIndex = 0) {
        this._value = value;
        this._separator = separator;
        this._startIndex = startIndex;
    }
    /****************************************/
    get current() {
        if (!this._current) {
            this._current = this._value.substr(this._wordStartIndex, this._wordLength);
            if (this._hasEscape)
                this._current = this._current.replace("\"\"", "\"");
        }
        return this._current;
    }
    /****************************************/
    moveNext() {
        let found = false;
        while (true) {
            const c = this._curIndex >= this._value.length ? "" : this._value[this._curIndex];
            switch (this._state) {
                case 0:
                    if (c == "\"") {
                        this._state = 1;
                        this._hasEscape = false;
                        this._wordLength = 0;
                        this._wordStartIndex = this._curIndex + 1;
                    }
                    else if (c == this._separator || !c) {
                        this._wordStartIndex = this._curIndex;
                        this._wordLength = 0;
                        found = this._curIndex <= this._value.length;
                    }
                    else {
                        this._state = 2;
                        this._wordLength = 1;
                        this._wordStartIndex = this._curIndex;
                    }
                    break;
                case 1:
                    if (c == "\"")
                        this._state = 3;
                    else
                        this._wordLength++;
                    break;
                case 2:
                    if (c == this._separator || !c) {
                        this._state = 0;
                        found = true;
                    }
                    else
                        this._wordLength++;
                    break;
                case 3:
                    if (c == "\"") {
                        this._hasEscape = true;
                        this._wordLength += 2;
                        this._state = 1;
                    }
                    else if (c == this._separator || !c) {
                        found = true;
                        this._state = 0;
                    }
                    else
                        this._state = 4;
                    break;
                case 4:
                    if (c == this._separator || !c) {
                        found = true;
                        this._state = 0;
                    }
                    break;
            }
            this._curIndex++;
            if (!c || found)
                break;
        }
        this._current = null;
        return found;
    }
    /****************************************/
    reset() {
        this._hasEscape = false;
        this._curIndex = this._startIndex;
        this._wordStartIndex = this._curIndex;
        this._wordLength = 0;
        this._current = null;
        this._state = 0;
    }
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Framework/DataAdapter.js
/****************************************/
/* IDataAdapter
/****************************************/




/****************************************/
var DaColumnType;
(function (DaColumnType) {
    DaColumnType[DaColumnType["Exclude"] = 0] = "Exclude";
    DaColumnType[DaColumnType["XAxis"] = 1] = "XAxis";
    DaColumnType[DaColumnType["Serie"] = 2] = "Serie";
    DaColumnType[DaColumnType["Group"] = 3] = "Group";
})(DaColumnType || (DaColumnType = {}));
/****************************************/
class BaseDataAdapter {
    constructor() {
    }
}
/****************************************/
class TextTableDataAdapter extends BaseDataAdapter {
    constructor() {
        super();
    }
    /****************************************/
    createIdentifier(value) {
        let state = 0;
        let result = "";
        for (let i = 0; i < value.length; i++) {
            const c = value[i];
            switch (state) {
                case 0:
                    result += c.toLowerCase();
                    state = 1;
                    break;
                case 1:
                    if (c == " " || c == "-" || c == "_")
                        state = 2;
                    else
                        result += c;
                    break;
                case 2:
                    result += c.toUpperCase();
                    state = 1;
                    break;
            }
        }
        return result;
    }
    /****************************************/
    extractHeader(text, options) {
        const firstRow = (0,Linq/* linq */.k)(new SplitEnumerator(text, options.rowSeparator)).first();
        const cols = (0,Linq/* linq */.k)(new CsvSplitEnumerator(firstRow, options.columnSeparator)).toArray();
        let headers;
        if (options.hasHeader !== false) {
            const rowAnal = [];
            this.analyzeRow(cols, rowAnal);
            const stringCount = (0,Linq/* linq */.k)(rowAnal).sum(a => a.stringCount);
            const emptyCount = (0,Linq/* linq */.k)(rowAnal).sum(a => a.emptyCount);
            if (stringCount > 0 && stringCount + emptyCount == cols.length) {
                options.hasHeader = true;
                headers = (0,Linq/* linq */.k)(cols).select((a, i) => {
                    if (a == "")
                        return "col" + i;
                    return a;
                }).toArray();
            }
        }
        if (!headers) {
            options.hasHeader = false;
            headers = (0,Linq/* linq */.k)(cols).select((a, i) => "col" + i).toArray();
        }
        if (!options.columns)
            options.columns = (0,Linq/* linq */.k)(headers).select(a => ({ id: this.createIdentifier(a), name: a, type: DaColumnType.Exclude })).toArray();
    }
    /****************************************/
    extractRowSeparator(text, options) {
        if (options.rowSeparator)
            return;
        const items = ["\r\n", "\n"];
        for (var item of items) {
            if (text.indexOf(item) != -1) {
                options.rowSeparator = item;
                return;
            }
        }
    }
    /****************************************/
    extractColumnSeparator(text, options) {
        if (options.columnSeparator)
            return;
        const items = ["\t", ";", ",", " "];
        const stats = {};
        const rows = (0,Linq/* linq */.k)(new SplitEnumerator(text, options.rowSeparator)).take(10);
        for (let row of rows) {
            if (row.trim().length == 0)
                continue;
            for (let item of items) {
                if (stats[item] === false)
                    continue;
                const cols = (0,Linq/* linq */.k)(new CsvSplitEnumerator(row, item)).count();
                if (cols > 1 && !(item in stats))
                    stats[item] = cols;
                else {
                    if (stats[item] != cols)
                        stats[item] = false;
                }
            }
        }
        for (var key in stats) {
            if (stats[key] !== false) {
                options.columnSeparator = key;
                return;
            }
        }
    }
    /****************************************/
    analyzeRow(cols, result) {
        if (result.length == 0) {
            for (let i = 0; i < cols.length; i++) {
                result.push({
                    values: {},
                    booleanCount: 0,
                    dateCount: 0,
                    emptyCount: 0,
                    numberCount: 0,
                    stringCount: 0
                });
            }
        }
        for (let i = 0; i < cols.length; i++)
            this.analyzeColumn(cols[i], result[i]);
    }
    /****************************************/
    analyzeColumn(value, result) {
        if (!result.values || Object.keys(result.values).length < 150)
            value in result.values ? result.values[value]++ : result.values[value] = 1;
        if (value == null || value.length == 0 || value.trim().length == 0)
            result.emptyCount++;
        else if (!isNaN(value))
            result.numberCount++;
        else if (Date.parse(value))
            result.dateCount++;
        else if (value == "true" || value == "false")
            result.booleanCount++;
        else
            result.stringCount++;
    }
    /****************************************/
    createParser(anal) {
        if (anal.numberCount > 0 && anal.stringCount == 0)
            return a => isNaN(a) ? null : parseFloat(a);
        if (anal.booleanCount > 0 && anal.stringCount == 0)
            return a => a == "true";
        if (anal.dateCount > 0 && anal.stringCount == 0)
            return a => !a ? null : new Date(a);
        if (anal.stringCount > 0)
            return a => {
                if (!a)
                    return "";
                if (a.startsWith("\"") && a.endsWith("\""))
                    return a.substr(1, a.length - 2);
                return a;
            };
        return a => null;
    }
    /****************************************/
    async analyzeAsync(text, options, maxRows) {
        if (!options)
            options = {};
        //Separators
        this.extractRowSeparator(text, options);
        this.extractColumnSeparator(text, options);
        //Header
        this.extractHeader(text, options);
        //Rows
        let rows = (0,Linq/* linq */.k)(new SplitEnumerator(text, options.rowSeparator));
        if (maxRows)
            rows = rows.take(maxRows);
        if (options.hasHeader)
            rows = rows.skip(1);
        let curOp = Operation.begin("Analazing rows...");
        //col analysis
        const colAnalysis = [];
        let rowCount = 0;
        await rows.foreachAsync(async (row) => {
            rowCount++;
            this.analyzeRow((0,Linq/* linq */.k)(new CsvSplitEnumerator(row, options.columnSeparator)).toArray(), colAnalysis);
            if (rowCount % 200 == 0) {
                curOp.progress = { current: rowCount };
                await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
            }
        });
        options.rowsCount = rowCount;
        curOp.end();
        const columns = (0,Linq/* linq */.k)(options.columns);
        //Parser
        colAnalysis.forEach((col, i) => {
            if (!options.columns[i].parser)
                options.columns[i].parser = this.createParser(col);
        });
        //X-axis
        if (!columns.any(a => a.type == DaColumnType.XAxis))
            columns.first(a => a.type == DaColumnType.Exclude).type = DaColumnType.XAxis;
        //Y-axis
        if (!columns.any(a => a.type == DaColumnType.Serie)) {
            colAnalysis.forEach((col, i) => {
                if (col.numberCount > 0 && col.stringCount == 0)
                    options.columns[i].type = DaColumnType.Serie;
            });
        }
        //groups
        if (!columns.any(a => a.type == DaColumnType.Group)) {
            colAnalysis.forEach((col, i) => {
                if (col.stringCount > 0 && col.emptyCount == 0) {
                    var values = (0,Linq/* linq */.k)(col.values);
                    if (values.count() > 1 && values.any(a => a.value > 1))
                        options.columns[i].type = DaColumnType.Group;
                }
            });
        }
        return options;
    }
    /****************************************/
    async loadTableAsync(text, options, maxItems) {
        var result = [];
        var rows = (0,Linq/* linq */.k)(new SplitEnumerator(text, options.rowSeparator));
        if (options.hasHeader)
            rows = rows.skip(1);
        for (var row of rows) {
            const cols = (0,Linq/* linq */.k)(new CsvSplitEnumerator(row, options.columnSeparator)).toArray();
            const item = {};
            for (let i = 0; i < cols.length; i++) {
                const col = options.columns[i];
                if (col.type == DaColumnType.Exclude)
                    continue;
                item[col.id] = col.parser(cols[i]);
            }
            result.push(item);
            if (maxItems && result.length >= maxItems)
                break;
        }
        return result;
    }
    /****************************************/
    async loadGroupAsync(text, options) {
        var result = { name: $string("$(da-main-group)") };
        var rows = (0,Linq/* linq */.k)(new SplitEnumerator(text, options.rowSeparator));
        if (options.hasHeader)
            rows = rows.skip(1);
        const xColumnIndex = (0,Linq/* linq */.k)(options.columns).where(a => a.type == DaColumnType.XAxis).select((a, i) => i).first();
        let curOp = Operation.begin("Loading groups...");
        let rowCount = 0;
        let chunkCount;
        await rows.foreachAsync(async (row) => {
            const values = (0,Linq/* linq */.k)(new CsvSplitEnumerator(row, options.columnSeparator)).toArray();
            const xValue = options.columns[xColumnIndex].parser(values[xColumnIndex]);
            const item = {};
            let curGroup = result;
            for (let i = 0; i < values.length; i++) {
                const col = options.columns[i];
                if (col.type == DaColumnType.Exclude || col.type == DaColumnType.XAxis)
                    continue;
                let value = col.parser(values[i]);
                if (col.type == DaColumnType.Group) {
                    if (!curGroup.groups)
                        curGroup.groups = {};
                    if (value === "")
                        value = $string("<$(empty)>");
                    if (!(value in curGroup.groups))
                        curGroup.groups[value] = { name: value, colId: col.id };
                    curGroup = curGroup.groups[value];
                }
                else if (col.type == DaColumnType.Serie) {
                    if (!curGroup.series)
                        curGroup.series = {};
                    if (!(col.id in curGroup.series))
                        curGroup.series[col.id] = { name: col.name, colId: col.id, values: [] };
                    curGroup.series[col.id].values.push({ x: xValue, y: value });
                }
            }
            rowCount++;
            if (rowCount % 200 == 0) {
                curOp.progress = { current: rowCount, totCount: options.rowsCount };
                await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
            }
        });
        options.rowsCount = rowCount;
        curOp.end();
        return result;
    }
}
/****************************************/
class JsonDataAdapter extends (/* unused pure expression or super */ null && (BaseDataAdapter)) {
    constructor() {
        super();
    }
    /****************************************/
    async loadGroupAsync(text, options) {
        return null;
    }
    /****************************************/
    async loadTableAsync(text, options, maxItems) {
        return null;
    }
    /****************************************/
    async analyzeAsync(text, options, maxRows) {
        return null;
    }
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Components/TreeView.js
/****************************************/
/* BaseTreeItem
/****************************************/

class BaseTreeItem {
    constructor() {
        this.canDrag = false;
    }
    /****************************************/
    canReadData(transfer) {
        return false;
    }
    /****************************************/
    readData(transfer) {
    }
    /****************************************/
    writeData(transfer) {
        return false;
    }
    /****************************************/
    attachNode(node) {
        this.node = node;
    }
    /****************************************/
    remove() {
    }
    /****************************************/
    onParentChanged() {
    }
    /****************************************/
    canAccept(value) {
        return false;
    }
    /****************************************/
    name = ko.observable();
    color = ko.observable();
    canDrag;
    itemType;
    icon;
    node;
}
/****************************************/
/* ActionViewModel
/****************************************/
class TreeView_ActionView {
    execute() {
    }
    /****************************************/
    text;
    icon;
}
/****************************************/
/* TreeNode
/****************************************/
class TreeNode {
    _treeView;
    _parentNode;
    _element;
    _dargEnterCount = 0;
    _childLoaded = false;
    constructor(value) {
        this.value(value);
        this.isExpanded.subscribe(async (value) => {
            if (value && !this._childLoaded) {
                await this.loadChildNodes();
                this._childLoaded = true;
            }
        });
        this.isSelected.subscribe(a => {
            if (a)
                this._treeView.select(this);
        });
    }
    /****************************************/
    async loadChildNodes() {
    }
    /****************************************/
    clear() {
        this._childLoaded = false;
        this.nodes.removeAll();
    }
    /****************************************/
    get element() {
        return this._element;
    }
    /****************************************/
    attachNode(element) {
        this._element = element;
        this._element.id = generateId("id");
        this._element["$model"] = this;
        this._element.addEventListener("keydown", ev => this.onKeyDown(ev));
        let header = this._element.querySelector("header");
        header.ondragstart = ev => this.onDrag(ev);
        header.ondragover = ev => this.onDragOver(ev);
        header.ondragenter = ev => this.onDragEnter(ev);
        header.ondragleave = ev => this.onDragLeave(ev);
        header.ondrop = ev => this.onDrop(ev);
    }
    /****************************************/
    onKeyDown(ev) {
        if (ev.keyCode == 46 && ev.target.tagName != "INPUT") {
            ev.preventDefault();
            if (this.isSelected())
                this.value().remove();
        }
    }
    /****************************************/
    onDrag(ev) {
        if (!this.value().writeData(ev.dataTransfer) || !this.value().canDrag) {
            ev.preventDefault();
            return false;
        }
    }
    /****************************************/
    onDragEnter(ev) {
        this._dargEnterCount++;
    }
    /****************************************/
    onDragLeave(ev) {
        this._dargEnterCount--;
        if (this._dargEnterCount == 0)
            DomUtils_removeClass(this._element, "drop");
    }
    /****************************************/
    onDragOver(ev) {
        ev.preventDefault();
        if (this._dargEnterCount == 1) {
            let canDrop = true;
            if (!this.value().canReadData(ev.dataTransfer))
                canDrop = false;
            if (canDrop) {
                if (ev.ctrlKey)
                    ev.dataTransfer.dropEffect = "copy";
                else
                    ev.dataTransfer.dropEffect = "move";
                DomUtils_addClass(this._element, "drop");
            }
            else
                ev.dataTransfer.dropEffect = "move";
        }
    }
    /****************************************/
    onDrop(ev) {
        ev.preventDefault();
        this._dargEnterCount = 0;
        DomUtils_removeClass(this._element, "drop");
        const elId = ev.dataTransfer.getData("text/html+id");
        if (elId) {
            const element = document.getElementById(elId);
            const node = element["$model"];
            if (!this.value().canAccept(node.value()))
                return;
            if (ev.ctrlKey) {
            }
            else {
                if (node._parentNode == this)
                    return;
                node._parentNode.nodes.remove(node);
                node._parentNode = this;
                this.nodes.push(node);
                this.isExpanded(true);
                node.value().onParentChanged();
                return;
            }
        }
        else
            this.value().readData(ev.dataTransfer);
    }
    /****************************************/
    remove() {
        if (this._parentNode)
            this._parentNode.nodes.remove(this);
        if (this._treeView.selectedNode() == this)
            this._treeView.select(null);
    }
    /****************************************/
    addNode(node) {
        node.attach(this._treeView, this);
        this.nodes.push(node);
    }
    /****************************************/
    attach(treeView, parent) {
        this._treeView = treeView;
        this._parentNode = parent;
        for (let childNode of this.nodes())
            childNode.attach(treeView);
    }
    /****************************************/
    get parentNode() {
        return this._parentNode;
    }
    /****************************************/
    toggleVisible() {
        this.isVisible(!this.isVisible());
    }
    /****************************************/
    select(expand = false) {
        this.isSelected(true);
        if (this._element)
            this._element.focus();
        if (expand) {
            let curNode = this;
            while (curNode) {
                curNode.isExpanded(true);
                curNode = curNode.parentNode;
            }
        }
    }
    /****************************************/
    expandCollapse() {
        this.isExpanded(!this.isExpanded());
    }
    /****************************************/
    nodes = ko.observableArray();
    value = ko.observable();
    isSelected = ko.observable(false);
    isVisible = ko.observable(true);
    isExpanded = ko.observable(false);
    actions = ko.observable();
}
/****************************************/
/* TreeView
/****************************************/
class TreeView {
    _selectedNode;
    /****************************************/
    select(node) {
        if (this.selectedNode() == node)
            return;
        if (this.selectedNode())
            this.selectedNode().isSelected(false);
        this.selectedNode(node);
        if (this.selectedNode())
            this.selectedNode().isSelected(true);
    }
    /****************************************/
    setRoot(node) {
        node.attach(this);
        this.root(node);
    }
    /****************************************/
    root = ko.observable();
    selectedNode = ko.observable();
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Components/DataImport.js
/****************************************/
/* FileDragDrop
/****************************************/





class FileDragDrop {
    _element;
    _dargEnterCount = 0;
    /****************************************/
    attachNode(element) {
        this._element = element;
        element.ondragover = ev => this.onDragOver(ev);
        element.ondrop = ev => this.onDrop(ev);
        element.ondragenter = ev => this.onDragEnter(ev);
        element.ondragleave = ev => this.onDragLeave(ev);
    }
    /****************************************/
    onFileDropped(content) {
    }
    /****************************************/
    onDragEnter(ev) {
        this._dargEnterCount++;
    }
    /****************************************/
    onDragLeave(ev) {
        this._dargEnterCount--;
        if (this._dargEnterCount == 0)
            DomUtils_removeClass(this._element, "drop");
    }
    /****************************************/
    onDragOver(ev) {
        ev.preventDefault();
        if (this._dargEnterCount == 1)
            DomUtils_addClass(this._element, "drop");
    }
    /****************************************/
    async onDrop(ev) {
        ev.preventDefault();
        this._dargEnterCount = 0;
        DomUtils_removeClass(this._element, "drop");
        if (ev.dataTransfer.files.length == 1) {
            const file = ev.dataTransfer.files[0];
            if (file.name.toLowerCase().endsWith(".csv")) {
                const text = await ev.dataTransfer.files[0].text();
                this.onFileDropped(text);
                return;
            }
        }
        M.toast({ html: $string("$(msg-not-supported-only-csv)") });
    }
}
class ProgressViewModel {
    _showCount = 0;
    /****************************************/
    constructor() {
        this.status("hidden");
        Operation.onBegin.add((s, op) => this.show(op));
        Operation.onEnd.add((s, op) => this.hide(op));
        Operation.onProgress.add((s, data) => this.update(data.operation, data.progress));
    }
    /****************************************/
    show(op) {
        if (this._showCount == 0) {
            this.status("indefinite");
            this.percentage(100);
        }
        this.message(op.message);
        this._showCount++;
    }
    /****************************************/
    update(op, progress) {
        this.message(op["getProgressDescription"](progress));
        if (progress.totCount != undefined && progress.current != undefined) {
            this.percentage(Math.min(100, (progress.current / progress.totCount) * 100));
            this.status("show");
        }
        else {
            this.status("show");
            this.percentage(100);
        }
    }
    /****************************************/
    hide(op) {
        this._showCount--;
        if (this._showCount == 0) {
            //this.message("");
            this.status("hidden");
        }
    }
    /****************************************/
    message = ko.observable();
    percentage = ko.observable();
    status = ko.observable();
}
/****************************************/
class ColumnViewModel {
    constructor(value) {
        this.types = [
            { text: $string("$(exclude)"), value: DaColumnType.Exclude },
            { text: $string("$(x-axis)"), value: DaColumnType.XAxis },
            { text: $string("$(serie)"), value: DaColumnType.Serie },
            { text: $string("$(group)"), value: DaColumnType.Group }
        ];
        this.value = value;
        this.type(value.type);
        this.alias(value.name);
    }
    /****************************************/
    value;
    alias = ko.observable();
    type = ko.observable();
    types;
}
/****************************************/
class GroupItem extends BaseTreeItem {
    constructor(value) {
        super();
        this.value = value;
        this.icon = "folder";
        this.itemType = "group";
        this.color("#ffc107");
        this.name(value.name);
    }
    /****************************************/
    attachNode(node) {
        super.attachNode(node);
        node.isVisible.subscribe(value => {
            for (var childNode of this.node.nodes())
                childNode.isVisible(value);
        });
    }
    /****************************************/
    value;
}
/****************************************/
class SerieItem extends BaseTreeItem {
    constructor(value) {
        super();
        this.value = value;
        this.icon = "insert_chart";
        this.itemType = "serie";
        this.color("#4caf50");
        this.name(value.name);
    }
    /****************************************/
    value;
    colId;
}
/****************************************/
class DataImportControl {
    _model;
    _adapter;
    _text;
    _options;
    _onGetData;
    constructor() {
        this.columnSeparators = [
            { text: $string("$(tab-key)"), value: "\t" },
            { text: ",", value: "," },
            { text: ";", value: ";" },
            { text: $string("$(sapce-key)"), value: " " }
        ];
        this.treeView.setRoot(new TreeNode());
        this.treeView.selectedNode.subscribe(a => this.onNodeSelected(a));
        this.fileDrop.onFileDropped = text => this.importText(text);
    }
    /****************************************/
    async importText(text, options) {
        M.toast({ html: $string("$(msg-start-analysis)") });
        this.hasData(true);
        await (0,Utils_PromiseUtils/* delayAsync */.$)(0);
        this._text = text;
        this._adapter = new TextTableDataAdapter();
        this._options = await this._adapter.analyzeAsync(this._text, options, 5000);
        if (!this._options.columnSeparator || !this._options.rowSeparator || !this._options.columns || this._options.columns.length < 2)
            return false;
        this.hasHeader(this._options.hasHeader);
        this.columnSeparator(this._options.columnSeparator);
        const cols = [];
        for (let col of this._options.columns) {
            var model = new ColumnViewModel(col);
            cols.push(model);
        }
        this.columns(cols);
        await this.updatePreview();
        return true;
    }
    /****************************************/
    async getSelectedData() {
        const result = [];
        await this.getSelectedDataWork(this.treeView.root(), [], result);
        return result;
    }
    /****************************************/
    async getSelectedDataWork(node, groups, result) {
        if (!node.isVisible())
            return;
        if (node.value() instanceof SerieItem) {
            const serie = node.value().value;
            const source = {
                type: "data-import",
                options: this._options,
                serie: serie,
                groups: groups
            };
            result.push(source);
            return;
        }
        if (!node.isExpanded())
            await node.loadChildNodes();
        if (node.value() instanceof GroupItem) {
            const group = node.value().value;
            let newGroups = groups.slice(0, groups.length);
            newGroups.push({ id: group.colId, value: group.name });
            groups = newGroups;
        }
        for (let childNode of node.nodes())
            await this.getSelectedDataWork(childNode, groups, result);
    }
    /****************************************/
    async executeImport() {
        const data = await this.getSelectedData();
        if (this._onGetData) {
            this._onGetData(data);
            this._onGetData = null;
        }
        this._model.close();
    }
    /****************************************/
    async applyChanges() {
        this._options.hasHeader = this.hasHeader();
        this._options.columnSeparator = this.columnSeparator();
        this._options.columns.forEach((col, i) => {
            col.name = this.columns()[i].alias();
            col.type = this.columns()[i].type();
        });
        await this.updatePreview(true);
    }
    /****************************************/
    async updateGroups() {
        const group = await this._adapter.loadGroupAsync(this._text, this._options);
        let childNode = new TreeNode(new GroupItem(group));
        this.treeView.root().clear();
        this.treeView.root().addNode(childNode);
        childNode.value().attachNode(childNode);
        this.updateNode(childNode, group);
        childNode.isExpanded(true);
    }
    /****************************************/
    updateNode(node, group) {
        node.clear();
        if (group.groups) {
            for (let item of (0,Core_Linq/* linq */.k)(group.groups)) {
                let childNode = new TreeNode(new GroupItem(item.value));
                childNode.loadChildNodes = async () => this.updateNode(childNode, item.value);
                node.addNode(childNode);
                childNode.value().attachNode(childNode);
            }
        }
        if (group.series) {
            for (let item of (0,Core_Linq/* linq */.k)(group.series)) {
                let childNode = new TreeNode(new SerieItem(item.value));
                node.addNode(childNode);
                childNode.value().attachNode(childNode);
            }
        }
    }
    /****************************************/
    async updateTable() {
        const result = await this._adapter.loadTableAsync(this._text, this._options, 50);
        const table = {
            header: (0,Core_Linq/* linq */.k)(this._options.columns).where(a => a.type != DaColumnType.Exclude).select(a => a.name).toArray(),
            rows: (0,Core_Linq/* linq */.k)(result).select(a => (0,Core_Linq/* linq */.k)(a).select(b => this.format(b.value)).toArray()).toArray()
        };
        this.table(table);
    }
    /****************************************/
    format(value) {
        if (typeof value == "number")
            return formatNumber(value);
        if (typeof value == "boolean")
            return $string(value ? "$(yes)" : "$(no)");
        if (value instanceof Date)
            return DateUtils_formatDate(value, $string("$(date-format)"));
        return value;
    }
    /****************************************/
    async updatePreview(force = false) {
        if (force || this._options.rowsCount < 5000 - 1)
            await this.updateGroups();
        else
            this.treeView.root().clear();
        await this.updateTable();
    }
    /****************************************/
    onNodeSelected(node) {
        if (node && node.value() instanceof SerieItem) {
            const serie = node.value().value;
            const xColumn = (0,Core_Linq/* linq */.k)(this._options.columns).where(a => a.type == DaColumnType.XAxis).select(a => a.name).first();
            const table = {
                header: [xColumn, serie.name],
                rows: (0,Core_Linq/* linq */.k)(serie.values).take(50).select(a => [this.format(a.x), this.format(a.y)]).toArray()
            };
            this.table(table);
        }
        else
            this.table(null);
    }
    /****************************************/
    show() {
        if (!this._model) {
            this._model = M.Modal.init(document.getElementById("dataImport"), {
                onCloseEnd: el => {
                    if (this._onGetData)
                        this._onGetData([]);
                    this.reset();
                }
            });
        }
        this._model.open();
        return new Promise(res => this._onGetData = res);
    }
    /****************************************/
    reset() {
        this._text = null;
        this._options = null;
        this._onGetData = null;
        this.hasData(false);
        this.treeView.root().clear();
        this.table(null);
    }
    /****************************************/
    async importUrl() {
        const op = Operation.begin($string("$(msg-download-progress)"));
        try {
            let request = await fetch(this.sourceUrl());
            if (request.ok) {
                const text = await request.text();
                if (text) {
                    this.importText(text);
                    return;
                }
            }
            M.toast({ html: $string("$(msg-download-error): " + request.statusText) });
        }
        finally {
            op.end();
        }
    }
    /****************************************/
    hasHeader = ko.observable();
    columnSeparator = ko.observable();
    columns = ko.observable();
    columnSeparators;
    table = ko.observable();
    treeView = new TreeView();
    progress = new ProgressViewModel();
    hasData = ko.observable(false);
    sourceUrl = ko.observable();
    fileDrop = new FileDragDrop();
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Components/GraphContext.js

/****************************************/
class GraphContext {
    setExpressions(values) {
        const state = this.calculator.getState();
        for (let value of values) {
            const curExp = (0,Linq/* linq */.k)(state.expressions.list).first(a => a.id == value.id);
            if (!curExp)
                state.expressions.list.push(value);
            else {
                for (let prop of Object.getOwnPropertyNames(value))
                    curExp[prop] = value[prop];
            }
        }
        const groups = (0,Linq/* linq */.k)(state.expressions.list).where(a => a.type != "folder").groupBy(a => a.folderId ? a.folderId : "").toDictionary(a => a.key, a => a.values.toArray());
        const newList = [];
        for (let folder of (0,Linq/* linq */.k)(state.expressions.list).where(a => a.type == "folder")) {
            newList.push(folder);
            const items = groups[folder.id];
            if (items)
                for (let item of items)
                    newList.push(item);
        }
        const items = groups[""];
        if (items)
            for (let item of items)
                newList.push(item);
        state.expressions.list = newList;
        this.calculator.setState(state);
    }
    /****************************************/
    setSelectedId(id) {
        if (this.calculator.controller.listModel.selectedItem && this.calculator.controller.listModel.selectedItem.id == id)
            return;
        this.calculator.controller.dispatch({ type: "set-selected-id", id: id });
    }
    /****************************************/
    setColor(id, color) {
        this.calculator.controller.dispatch({ type: "set-item-color", id: id, color: color });
    }
    /****************************************/
    updateTable(id, values) {
        const exp = (0,Linq/* linq */.k)(this.calculator.getExpressions()).where(a => a.id == id).first();
        if (exp) {
            exp.columns[0].values = (0,Linq/* linq */.k)(values).select(a => a.x.toString()).toArray();
            exp.columns[1].values = (0,Linq/* linq */.k)(values).select(a => a.y.toString()).toArray();
            this.calculator.setExpression(exp);
        }
        /*

        this.calculator.setExpression({
            id: id,
            type: "table",
            columns: [
                {
                    values: linq(values).select(a => a.x.toString()).toArray()
                },
                {
                    values: linq(values).select(a => a.y.toString()).toArray(),
                    hidden: false
                },
            ]
        });*/
    }
    /****************************************/
    updateExpression(value) {
        //const exp = <Desmos.IMathExpression>linq(this.calculator.getExpressions()).where(a => a.id == value.id).first();
        /*if (exp) {
            for (let prop of Object.getOwnPropertyNames(value))
                exp[prop] = value[prop];
            this.calculator.setExpression(exp);
        }*/
        this.calculator.setExpression(value);
    }
    /****************************************/
    updateVariable(id, varName, value) {
        if (!varName)
            return;
        this.updateExpression({ id: id, latex: varName + "=" + value.toString() });
    }
    /****************************************/
    expressionZoomFit(id) {
        this.calculator.controller.dispatch({ type: "expression-zoom-fit", id: id });
    }
    /****************************************/
    setItemVisibile(id, value) {
        this.updateExpression({ id: id, hidden: !value });
        //this.calculator.controller._setItemHidden(id, !value);
        //this.calculator.updateSettings({});
    }
    /****************************************/
    generateVars(map) {
        for (let key in map) {
            if (!map[key])
                map[key] = this.generateVar(key);
        }
    }
    /****************************************/
    generateVar(prefix = "a") {
        if (!this.vars[prefix[0]])
            this.vars[prefix[0]] = 0;
        this.vars[prefix[0]]++;
        return prefix[0] + "_{" + this.vars[prefix[0]] + "}";
    }
    /****************************************/
    serieCalculator;
    calculator;
    vars = {};
    treeItems = {};
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Components/BaseStudioItem.js


/****************************************/
class BaseStudioItem extends BaseTreeItem {
    _graphCtx;
    _varsMap;
    _isUpdating = 0;
    constructor() {
        super();
    }
    /****************************************/
    createActions(result) {
        result.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(delete)");
            action.icon = "delete";
            action.execute = () => this.remove();
        }));
    }
    /****************************************/
    setState(state) {
        this._isUpdating++;
        if (state.name)
            this.name(state.name);
        if (state.visible != undefined)
            this.node.isVisible(state.visible);
        if (state.color)
            this.color(state.color);
        if (state.opened != undefined)
            this.node.isExpanded(state.opened);
        if (state.folderId)
            this.folderId = state.folderId;
        this.setStateWork(state);
        this.updateGraph();
        this.setChildrenStateWork(state);
        this._isUpdating--;
    }
    /****************************************/
    getState() {
        return {
            name: this.name(),
            visible: this.node.isVisible(),
            folderId: this.folderId,
            color: this.color(),
            opened: this.node.isExpanded()
        };
    }
    /****************************************/
    getVar(name) {
        return this._varsMap[name];
    }
    /****************************************/
    remove(recursive = true) {
        if (this._graphCtx) {
            this._graphCtx.calculator.removeExpression({ id: this.getGraphId("private") });
            this._graphCtx.calculator.removeExpression({ id: this.getGraphId("public") });
        }
        this.node.remove();
        if (recursive)
            this.children.foreach(a => a.remove());
    }
    /****************************************/
    attachNode(node) {
        this.node = node;
        this.node.isVisible.subscribe(value => this.updateGraphVisibility());
        this.node.isSelected.subscribe(value => {
            if (value)
                this.onSelected();
        });
        const actions = [];
        this.createActions(actions);
        this.node.actions(actions);
    }
    /****************************************/
    attachGraph(ctx) {
        this._graphCtx = ctx;
        this._graphCtx.calculator.observe("expressionAnalysis", () => this.onGraphChanged());
        this.color.subscribe(value => this.updateColor());
    }
    /****************************************/
    isFullVisible() {
        let curNode = this.node;
        while (curNode) {
            if (!curNode.isVisible())
                return false;
            curNode = curNode.parentNode;
        }
        return true;
    }
    /****************************************/
    updateGraphVisibility(recorsive = true) {
        const visible = this.isFullVisible();
        this._graphCtx.setItemVisibile(this.getGraphId("public"), visible);
        this._graphCtx.setItemVisibile(this.getGraphId("private"), visible);
        if (recorsive)
            this.children.foreach(a => a.updateGraphVisibility());
        return visible;
    }
    /****************************************/
    updateGraph(recursive = true) {
        if (!this._graphCtx)
            return;
        if (!this.folderId)
            this.folderId = uuidv4();
        this._graphCtx.treeItems[this.folderId] = this;
        const values = this.getExpressions();
        this._graphCtx.setExpressions(values);
        this.updateGraphWork();
        this.updateGraphVisibility();
        this.updateParameters();
        if (recursive)
            this.children.foreach(a => a.updateGraph(recursive));
    }
    /****************************************/
    onParentChanged() {
        this.updateGraphVisibility();
    }
    /****************************************/
    get parent() {
        return this.node.parentNode.value();
    }
    /****************************************/
    get children() {
        return (0,Linq/* linq */.k)(this.node.nodes()).select(a => a.value());
    }
    /****************************************/
    replaceVars(value) {
        for (let item in this._varsMap) {
            const reg = new RegExp("\\$" + item, "g");
            value = value.replace(reg, this._varsMap[item]);
        }
        return value;
    }
    /****************************************/
    getGraphId(section) {
        return this.folderId + "/" + section;
    }
    /****************************************/
    addChildrenWork(value, updateGraph = true) {
        const node = new TreeNode(value);
        this.node.addNode(node);
        value.attachNode(node);
        value.attachGraph(this._graphCtx);
        if (updateGraph)
            value.updateGraph();
        value.onParentChanged();
        return value;
    }
    /****************************************/
    createParameters(result) {
        return false;
    }
    /****************************************/
    updateParameters() {
        const values = [];
        if (this.createParameters(values)) {
            this.parameters.removeAll();
            values.forEach(a => this.parameters.push(a));
        }
    }
    /****************************************/
    updateGraphWork() {
    }
    /****************************************/
    setChildrenStateWork(state) {
    }
    /****************************************/
    onSelected() {
        if (this.mainExpression && this._graphCtx)
            this._graphCtx.setSelectedId(this.mainExpression);
    }
    /****************************************/
    onGraphChanged() {
    }
    /****************************************/
    updateColor() {
    }
    get mainExpression() {
        return undefined;
    }
    /****************************************/
    folderId;
    time = ko.observable(0);
    optionsTemplateName;
    parameters = ko.observableArray();
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Framework/Graphics.js

/****************************************/
class LinearGradient {
    constructor(...values) {
        if (values.length > 0) {
            if (typeof values[0] == "string")
                this.colors = (0,Linq/* linq */.k)(values).select(a => new RgbColor(a)).toArray();
            else
                this.colors = values;
        }
        else
            this.colors = [];
    }
    /****************************************/
    valueAt(pos) {
        if (pos < 0)
            return this.colors[0];
        if (pos > 1)
            this.colors[this.colors.length - 1];
        const stepSize = 1 / (this.colors.length - 1);
        const minX = Math.floor(pos / stepSize);
        const maxX = Math.ceil(pos / stepSize);
        const minOfs = (pos - minX * stepSize) / stepSize;
        const c1 = this.colors[minX];
        const c2 = this.colors[maxX];
        const c3 = new RgbColor();
        c3.r = c1.r + (c2.r - c1.r) * minOfs;
        c3.g = c1.g + (c2.g - c1.g) * minOfs;
        c3.b = c1.b + (c2.b - c1.b) * minOfs;
        return c3;
    }
    /****************************************/
    colors;
}
/****************************************/
class RgbColor {
    constructor(value) {
        if (value)
            this.fromHex(value);
    }
    /****************************************/
    fromHex(value) {
        if (value.length == 4) {
            this.r = parseInt("0x" + value[1] + value[1]) / 255;
            this.g = parseInt("0x" + value[2] + value[2]) / 255;
            this.b = parseInt("0x" + value[3] + value[3]) / 255;
        }
        else {
            this.r = parseInt("0x" + value[1] + value[2]) / 255;
            this.g = parseInt("0x" + value[3] + value[4]) / 255;
            this.b = parseInt("0x" + value[5] + value[6]) / 255;
        }
    }
    /****************************************/
    toString() {
        function toHex(value) {
            let res = Math.round(value * 255).toString(16);
            if (res.length == 1)
                return "0" + res;
            return res;
        }
        return "#" + toHex(this.r) + toHex(this.g) + toHex(this.b);
    }
    /****************************************/
    r = 0;
    g = 0;
    b = 0;
}
/****************************************/
class Graphics {
    _svg;
    constructor(svg) {
        this._svg = svg;
    }
    /****************************************/
    setViewPort(minX, minY, maxX, maxY) {
        this._svg.viewBox.baseVal.x = minX;
        this._svg.viewBox.baseVal.y = minY;
        this._svg.viewBox.baseVal.width = maxX - minX;
        this._svg.viewBox.baseVal.height = maxY - minY;
    }
    /****************************************/
    drawPoly(poly) {
        var polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        polygon.style.fill = poly.fillColor;
        polygon.style.stroke = poly.strokeColor;
        polygon.style.strokeWidth = poly.strokeSize + "%";
        polygon.id = poly.id;
        for (let i = 0; i < poly.geometry.points.length; i++) {
            let point = this._svg.createSVGPoint();
            point.x = poly.geometry.points[i].x;
            point.y = poly.geometry.points[i].y;
            polygon.points.appendItem(point);
        }
        this._svg.appendChild(polygon);
    }
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Indicators.js

class ConstIndicatorFunction {
    _value;
    constructor(value) {
        this._value = value;
    }
    /****************************************/
    value(main, delta, exMain, exDelta, area) {
        let result = this._value(main, area);
        if (exMain) {
            for (var i in exMain)
                result = sumNull(result, -this.value(exMain[i], exDelta[i], null, null, area));
        }
        return result;
    }
}
/****************************************/
class SimpleIndicatorFunction {
    _value;
    constructor(value) {
        this._value = value;
    }
    /****************************************/
    value(main, delta, exMain, exDelta, area) {
        var result = this._value(main, area);
        if (delta)
            result -= this._value(delta, area);
        if (exMain) {
            for (var i in exMain)
                result -= this.value(exMain[i], exDelta[i], null, null, area);
        }
        return result;
    }
}
/****************************************/
class CombineIndicatorFunction {
    _value;
    _indicators;
    constructor(indicators, value) {
        this._value = value;
        this._indicators = indicators;
    }
    /****************************************/
    value(main, delta, exMain, exDelta, area) {
        const value = {};
        for (var key in this._indicators)
            value[key] = this._indicators[key].value(main, delta, exMain, exDelta, area);
        return this._value(value);
    }
}
/****************************************/
class SimpleFactorFunction {
    _value;
    constructor(value) {
        this._value = value;
    }
    /****************************************/
    value(main, delta, exMain, exDelta, area, indicator) {
        let curValue;
        for (var i in main)
            curValue = sumNull(curValue, indicator.value(main[i], delta[i], exMain[i], exDelta[i], area));
        return this._value(curValue, main[0], area);
    }
}
/****************************************/
class DoubleFactorFunction {
    _value;
    _factor;
    constructor(value, factor) {
        this._value = value;
        this._factor = factor;
    }
    /****************************************/
    value(main, delta, exMain, exDelta, area, indicator) {
        let curValue;
        let curFactor;
        for (var i in main) {
            curValue = sumNull(curValue, indicator.value(main[i], delta[i], exMain[i], exDelta[i], area));
            curFactor = sumNull(curFactor, this._factor.value(main[i], delta[i], exMain[i], exDelta[i], area));
        }
        return this._value(curValue, curFactor);
    }
}
class IndicatorCalculator {
    constructor(data, dataSet, geo) {
        this.data = data;
        this.dataSet = dataSet;
        this.geo = geo;
    }
    /****************************************/
    getDataAtDay(number, curAreaId) {
        if (number < 0)
            return undefined;
        const day = this.data.get(number);
        if (day) {
            const data = day.values[curAreaId];
            if (data)
                return data;
        }
        return this.dataSet.empty;
    }
    /****************************************/
    getFactorValue(options) {
        if (options.isAvg && typeof (options.dayNumberOrGroup) == "number") {
            let sum = 0;
            const startVal = this.getFactorValue({ ...options, isAvg: false });
            for (let d = options.dayNumberOrGroup - 6; d <= options.dayNumberOrGroup; d++) {
                const value = d < 1 ? 0 : this.getFactorValue({ ...options, dayNumberOrGroup: d, isAvg: false });
                sum += value;
            }
            return sum / 7;
        }
        const areaId = (typeof options.areaOrId == "string" ? options.areaOrId : options.areaOrId.id).toLowerCase();
        let dayGroup;
        if (!Array.isArray(options.dayNumberOrGroup))
            dayGroup = [options.dayNumberOrGroup];
        else
            dayGroup = options.dayNumberOrGroup;
        let main = [];
        let delta = [];
        let exMain = [];
        let exDelta = [];
        for (var dayNumber of dayGroup) {
            main.push(this.getDataAtDay(dayNumber, areaId));
            if (options.isDayDelta)
                delta.push(this.getDataAtDay(dayNumber - 1, areaId));
            if (options.execludedAreas) {
                var curExMain = [];
                var curExDelta = [];
                for (var exAreaId of options.execludedAreas) {
                    curExMain.push(this.getDataAtDay(dayNumber, exAreaId.toLowerCase()));
                    if (options.isDayDelta)
                        curExDelta.push(this.getDataAtDay(dayNumber - 1, exAreaId.toLowerCase()));
                }
                exMain.push(curExMain);
                exDelta.push(curExDelta);
            }
        }
        const factor = (0,Linq/* linq */.k)(this.dataSet.factors).first(a => a.id == options.factorId);
        const indicator = (0,Linq/* linq */.k)(this.dataSet.indicators).first(a => a.id == options.indicatorId);
        return factor.compute.value(main, delta, exMain, exDelta, this.geo.areas[areaId], indicator.compute);
    }
    /****************************************/
    getIndicatorValue(options) {
        const areaId = (typeof options.areaOrId == "string" ? options.areaOrId : options.areaOrId.id).toLowerCase();
        const indicator = (0,Linq/* linq */.k)(this.dataSet.indicators).first(a => a.id == options.indicatorId);
        let main = this.getDataAtDay(options.dayNumber, areaId);
        let delta;
        let exMain;
        let exDelta;
        if (options.isDayDelta)
            delta = this.getDataAtDay(options.dayNumber - 1, areaId);
        if (options.execludedAreas) {
            exMain = [];
            exDelta = [];
            for (var exAreaId of options.execludedAreas) {
                exMain.push(this.getDataAtDay(options.dayNumber, exAreaId.toLowerCase()));
                if (options.isDayDelta)
                    exDelta.push(this.getDataAtDay(options.dayNumber - 1, exAreaId.toLowerCase()));
            }
            ;
        }
        return indicator.compute.value(main, delta, exMain, exDelta, this.geo.areas[areaId]);
    }
    /****************************************/
    getSerie(source) {
        const result = [];
        let index = source.startDay + (source.isDelta ? 1 : 0);
        let lastItem;
        if (source.groupSize > 1) {
            let count = source.groupSize;
            let group = [];
            this.data.days.skip(index).foreach((day) => {
                group.push(index);
                count--;
                if (count == 0) {
                    const item = {
                        x: (source.xAxis == "date" ? new Date(day.date) : index),
                        y: this.getFactorValue({
                            dayNumberOrGroup: source.isDelta ? group : index,
                            areaOrId: source.areaId,
                            factorId: source.factorId,
                            indicatorId: source.indicatorId,
                            execludedAreas: source.exeludedAreaIds,
                            isDayDelta: source.isDelta
                        })
                    };
                    result.push(item);
                    count = source.groupSize;
                    group = [];
                }
                index++;
            });
        }
        else {
            this.data.days.skip(index).foreach((day) => {
                const item = {
                    x: (source.xAxis == "date" ? new Date(day.date) : index),
                    y: this.getFactorValue({
                        dayNumberOrGroup: index,
                        areaOrId: source.areaId,
                        factorId: source.factorId,
                        indicatorId: source.indicatorId,
                        execludedAreas: source.exeludedAreaIds,
                        isDayDelta: source.isDelta,
                        isAvg: source.isAvg
                    })
                };
                result.push(item);
                index++;
            });
        }
        return result;
    }
    data;
    dataSet;
    geo;
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Data/InfectionDataSet.js



/****************************************/
var InfectionDataSet = {
    name: "COVID-19",
    empty: {
        currentPositive: undefined,
        historicDeaths: { "2015": undefined, "2016": undefined, "2017": undefined, "2018": undefined, "2019": undefined, "2020": undefined },
        toatlTests: undefined,
        totalDeath: undefined,
        totalHealed: undefined,
        totalHospedalized: undefined,
        totalPositive: undefined,
        totalSevere: undefined,
        totalCaseTested: undefined,
        newICU: undefined,
        totalAntigenicPositive: undefined,
        totalAntigenicTests: undefined,
        totalMolecularPositive: undefined,
        totalMolecularTests: undefined,
    },
    indicators: [
        {
            id: "totalPositive",
            name: $string("$(total-positive)"),
            colorLight: "#f44336",
            colorDark: "#b71c1c",
            validFor: ["region", "country", "district"],
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalPositive)
        },
        {
            id: "totalAntigenicPositive",
            name: $string("$(antigenic-positive)"),
            colorLight: "#f44336",
            colorDark: "#b71c1c",
            validFor: ["region", "country"],
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalAntigenicPositive)
        },
        {
            id: "totalMolecularPositive",
            name: $string("$(molecular-positive)"),
            colorLight: "#f44336",
            colorDark: "#b71c1c",
            validFor: ["region", "country"],
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalMolecularPositive)
        },
        {
            id: "currentPositive",
            name: $string("$(current-positive)"),
            validFor: ["region", "country"],
            colorLight: "#e91e63",
            colorDark: "#880e4f",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.currentPositive)
        },
        {
            id: "totalDeath",
            name: $string("$(death)"),
            validFor: ["region", "country"],
            colorLight: "#9c27b0",
            colorDark: "#4a148c",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalDeath)
        },
        {
            id: "totalSevere",
            name: $string("$(severe)"),
            validFor: ["region", "country"],
            colorLight: "#ff9800",
            colorDark: "#e65100",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalSevere)
        },
        {
            id: "newICU",
            name: $string("$(newICU)"),
            validFor: ["region", "country"],
            colorLight: "#ff9800",
            colorDark: "#e65100",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.newICU)
        },
        {
            id: "totalHospedalized",
            name: $string("$(hospedalized)"),
            validFor: ["region", "country"],
            colorLight: "#fdd835",
            colorDark: "#fbc02d",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalHospedalized)
        },
        {
            id: "totalHealed",
            name: $string("$(healed)"),
            validFor: ["region", "country"],
            colorLight: "#4caf50",
            colorDark: "#1b5e20",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalHealed)
        },
        {
            id: "toatlTests",
            name: $string("$(tested)"),
            validFor: ["region", "country"],
            colorLight: "#03a9f4",
            colorDark: "#01579b",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.toatlTests)
        },
        {
            id: "totalCaseTested",
            name: $string("$(caseTested)"),
            validFor: ["region", "country"],
            colorLight: "#03a9f4",
            colorDark: "#01579b",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalCaseTested)
        },
        {
            id: "totalMolecularTests",
            name: $string("$(molecularTests)"),
            validFor: ["region", "country"],
            colorLight: "#03a9f4",
            colorDark: "#01579b",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalMolecularTests)
        },
        {
            id: "totalAntigenicTests",
            name: $string("$(antigenicTests)"),
            validFor: ["region", "country"],
            colorLight: "#03a9f4",
            colorDark: "#01579b",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.totalAntigenicTests)
        },
        {
            id: "surface",
            name: $string("$(surface) ($(geo))"),
            validFor: ["region", "district"],
            colorLight: "#777",
            colorDark: "#222",
            showInFavorites: false,
            compute: new ConstIndicatorFunction((v, a) => round(a.surface, 0))
        },
        {
            id: "density",
            name: $string("$(density) ($(geo))"),
            validFor: ["region", "district"],
            colorLight: "#777",
            colorDark: "#222",
            showInFavorites: false,
            compute: new ConstIndicatorFunction((v, a) => round(a.demography.total / a.surface, 0))
        },
        {
            id: "death2021",
            name: $string("$(total-death) +60 (2021)*"),
            validFor: ["details"],
            colorLight: "#9c27b0",
            colorDark: "#4a148c",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.historicDeaths ? a.historicDeaths["2021"] : undefined)
        },
        {
            id: "death2020",
            name: $string("$(total-death) +60 (2020)"),
            validFor: ["details", "region", "district"],
            colorLight: "#9c27b0",
            colorDark: "#4a148c",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.historicDeaths ? a.historicDeaths["2020"] : undefined)
        },
        {
            id: "death2019",
            name: $string("$(total-death) +60 (2019)"),
            validFor: ["region", "district", "details"],
            colorLight: "#9c27b0",
            colorDark: "#4a148c",
            showInFavorites: true,
            compute: new SimpleIndicatorFunction(a => a.historicDeaths ? a.historicDeaths["2019"] : undefined)
        },
        {
            id: "death2018",
            name: $string("$(total-death) +60 (2018)"),
            validFor: ["region", "district", "details"],
            colorLight: "#9c27b0",
            colorDark: "#4a148c",
            showInFavorites: false,
            compute: new SimpleIndicatorFunction(a => a.historicDeaths ? a.historicDeaths["2018"] : undefined)
        },
        {
            id: "death2017",
            name: $string("$(total-death) +60 (2017)"),
            validFor: ["region", "district", "details"],
            colorLight: "#9c27b0",
            colorDark: "#4a148c",
            showInFavorites: false,
            compute: new SimpleIndicatorFunction(a => a.historicDeaths ? a.historicDeaths["2017"] : undefined)
        },
        {
            id: "death-diff-2020-2019",
            name: $string("DIff. decessi 2020-19"),
            validFor: ["details"],
            colorLight: "#f44336",
            colorDark: "#b71c1c",
            gradient: new LinearGradient("#00c853", "#bdbdbd", "#ff1744"),
            canBeNegative: true,
            compute: new CombineIndicatorFunction({
                death2019: new SimpleIndicatorFunction(a => a.historicDeaths[2019]),
                death2020: new SimpleIndicatorFunction(a => a.historicDeaths[2020]),
            }, values => isNaNOrNull(values.death2020) || isNaNOrNull(values.death2019) ? undefined : (values.death2020 - values.death2019))
        },
        {
            id: "death-diff-2021-2020",
            name: $string("DIff. decessi 2021-20"),
            validFor: ["details"],
            colorLight: "#f44336",
            colorDark: "#b71c1c",
            gradient: new LinearGradient("#00c853", "#bdbdbd", "#ff1744"),
            canBeNegative: true,
            compute: new CombineIndicatorFunction({
                death2020: new SimpleIndicatorFunction(a => a.historicDeaths[2020]),
                death2021: new SimpleIndicatorFunction(a => a.historicDeaths[2021]),
            }, values => isNaNOrNull(values.death2021) || isNaNOrNull(values.death2020) ? undefined : (values.death2021 - values.death2020))
        },
        {
            id: "population",
            name: $string("$(population) ($(geo))"),
            validFor: ["region", "district", "details", "country"],
            colorLight: "#777",
            colorDark: "#222",
            showInFavorites: false,
            compute: new ConstIndicatorFunction((v, a) => a.demography.total)
        },
        {
            id: "populationOld",
            name: $string("$(population) +65 ($(geo))"),
            validFor: ["region", "district", "country"],
            colorLight: "#777",
            colorDark: "#222",
            showInFavorites: false,
            compute: new ConstIndicatorFunction((v, a) => a.demography.over65)
        },
        /*,
        {
            id: "extimated-death",
            name: $string("Morti stimati"),
            validFor: ["country"],
            colorLight: "#f44336",
            colorDark: "#b71c1c",
            compute: new CombineIndicatorFunction({
                totalPositive: new SimpleIndicatorFunction(a => a.totalPositive),
                toatlTests: new SimpleIndicatorFunction(a => a.toatlTests),
                dailyDeath: new ConstIndicatorFunction((v, a) => 1450)
            }, values => Math.round((values.totalPositive / values.toatlTests) * values.dailyDeath))
        },
        {
            id: "healed-death",
            name: $string("$(death) + $(healed)"),
            validFor: ["country", "region"],
            colorLight: "#4caf50",
            colorDark: "#1b5e20",
            compute: new CombineIndicatorFunction({
                totalHealed: new SimpleIndicatorFunction(a => a.totalHealed),
                totalDeath: new SimpleIndicatorFunction(a => a.totalDeath)
            }, values => values.totalHealed + values.totalDeath)
        }*/
    ],
    factors: [
        {
            id: "none",
            name: $string("$(none)"),
            compute: new SimpleFactorFunction((i, v, a) => i),
            format: a => formatNumber(a),
            reference: (v, a) => "N/A",
            description: $string("[indicator]")
        },
        {
            id: "population",
            validFor: ["region", "country", "details", "district"],
            name: $string("$(population)"),
            compute: new SimpleFactorFunction((i, v, a) => divideNull(i, a.demography.total) * 100000),
            format: a => formatNumber(a),
            reference: (v, a) => formatNumber(a.demography.total),
            description: $string("[indicator] $(every-100k)")
        },
        {
            id: "populationOld",
            validFor: ["region", "country", "district"],
            name: $string("$(population) +65"),
            compute: new SimpleFactorFunction((i, v, a) => divideNull(i, a.demography.over65) * 100000),
            format: a => formatNumber(round(a, 1)),
            reference: (v, a) => formatNumber(a.demography.over65),
            description: $string("[indicator] $(every-100k) +65")
        },
        {
            id: "density",
            name: $string("$(density)"),
            validFor: ["region", "country", "district"],
            compute: new SimpleFactorFunction((i, v, a) => divideNull(i, divideNull(a.demography.total, a.surface)) * 100000),
            format: a => formatNumber(round(a, 1)),
            reference: (v, a) => formatNumber(round(a.demography.total / a.surface, 1)),
            description: $string("[indicator] $(over-density)")
        },
        {
            id: "totalPositive",
            name: $string("$(total-positive)"),
            validFor: ["region", "country"],
            compute: new DoubleFactorFunction((i, f) => isNaNOrNull(i) ? undefined : (i / f) * 100, new SimpleIndicatorFunction(v => v.totalPositive)),
            format: a => round(a, 1) + "%",
            reference: (v, a) => formatNumber(v.totalPositive),
            description: $string("% [indicator] $(over-total-positive)")
        },
        {
            id: "currentPositive",
            name: $string("$(current-positive)"),
            validFor: ["region", "country"],
            compute: new DoubleFactorFunction((i, f) => isNaNOrNull(i) ? undefined : (i / f) * 100, new SimpleIndicatorFunction(v => v.currentPositive)),
            format: a => round(a, 1) + "%",
            reference: (v, a) => formatNumber(v.totalPositive),
            description: $string("% [indicator] $(over-current-positive)")
        },
        {
            id: "severe",
            name: $string("$(severe)"),
            validFor: ["region", "country"],
            compute: new DoubleFactorFunction((i, f) => isNaNOrNull(i) ? undefined : (i / f) * 100, new SimpleIndicatorFunction(v => v.totalSevere)),
            format: a => round(a, 1) + "%",
            reference: (v, a) => formatNumber(v.totalSevere),
            description: $string("% [indicator] $(over-severe)")
        },
        {
            id: "test",
            name: $string("$(tested)"),
            validFor: ["region", "country"],
            compute: new DoubleFactorFunction((i, f) => isNaNOrNull(i) ? undefined : (i / f) * 100, new SimpleIndicatorFunction(v => v.toatlTests)),
            format: a => round(a, 1) + "%",
            reference: (v, a) => formatNumber(v.toatlTests),
            description: $string("% [indicator] $(over-tested)")
        },
        {
            id: "caseTested",
            name: $string("$(caseTested)"),
            validFor: ["region", "country"],
            compute: new DoubleFactorFunction((i, f) => isNaNOrNull(i) ? undefined : (i / f) * 100, new SimpleIndicatorFunction(v => v.totalCaseTested)),
            format: a => round(a, 1) + "%",
            reference: (v, a) => formatNumber(v.totalCaseTested),
            description: $string("% [indicator] $(over-case-tested)")
        },
        {
            id: "death2019Perc",
            name: $string("$(total-death) +60 (2019)"),
            validFor: ["details"],
            compute: new DoubleFactorFunction((i, f) => isNaNOrNull(i) ? undefined : (i / f) * 100, new SimpleIndicatorFunction(v => v.historicDeaths[2019])),
            format: a => isNaNOrNull(a) ? "N/A" : (a > 0 ? "+" : "") + round(a, 1) + "%",
            reference: (v, a) => formatNumber(v.historicDeaths[2019]),
            description: $string("% [indicator] $(over-tested)")
        },
    ]
};

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Data/RangeDayAreaDataSet.js

class RangeDayAreaDataSet {
    _days;
    constructor(data) {
        this._days = data.days;
    }
    get days() {
        const startIndex = this.startDay ?? 0;
        const endIndex = this.endDay ?? this._days.length - 1;
        return (0,Linq/* linq */.k)(this._days).skip(startIndex).take(endIndex - startIndex + 1);
    }
    get(index) {
        index = typeof index == "string" ? parseInt(index) : index;
        return this._days[(this.startDay ?? 0) + index];
    }
    get count() {
        const startIndex = this.startDay ?? 0;
        const endIndex = this.endDay ?? this._days.length - 1;
        return endIndex - startIndex + 1;
    }
    startDay;
    endDay;
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Types.js
var AggregationFunc;
(function (AggregationFunc) {
    AggregationFunc[AggregationFunc["SUm"] = 0] = "SUm";
    AggregationFunc[AggregationFunc["Avg"] = 1] = "Avg";
})(AggregationFunc || (AggregationFunc = {}));
var GeoAreaType;
(function (GeoAreaType) {
    GeoAreaType[GeoAreaType["Continent"] = 0] = "Continent";
    GeoAreaType[GeoAreaType["CountryGroup"] = 1] = "CountryGroup";
    GeoAreaType[GeoAreaType["Country"] = 2] = "Country";
    GeoAreaType[GeoAreaType["State"] = 3] = "State";
    GeoAreaType[GeoAreaType["Region"] = 4] = "Region";
    GeoAreaType[GeoAreaType["District"] = 5] = "District";
    GeoAreaType[GeoAreaType["Municipality"] = 6] = "Municipality";
})(GeoAreaType || (GeoAreaType = {}));
var Gender;
(function (Gender) {
    Gender[Gender["All"] = 0] = "All";
    Gender[Gender["Male"] = 1] = "Male";
    Gender[Gender["Female"] = 2] = "Female";
})(Gender || (Gender = {}));
/****************************************/
const MATERIAL_COLORS = {
    "red": { "600": "#f44336" },
    "pink": { "600": "#e91e63" },
    "purple": { "600": "#9c27b0" },
    "deep_purple": { "600": "#673ab7" },
    "indigo": { "600": "#3f51b5" },
    "blue": { "600": "#2196f3" },
    "light_blue": { "600": "#03a9f4" },
    "cyan": { "600": "#00bcd4" },
    "teal": { "600": "#009688" },
    "green": { "600": "#4caf50" },
    "light_green": { "600": "#8bc34a" },
    "lime": { "600": "#cddc39" },
    "yellow": { "600": "#ffeb3b" },
    "amber": { "600": "#ffc107" },
    "orange": { "600": "#ff9800" },
    "depp_orange": { "600": "#ff5722" },
    "brown": { "600": "#795548" },
    "grey": { "600": "#9e9e9e" },
    "blue_gray": { "600": "#607d8b" },
};

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Components/ColorPicker.js

/****************************************/
class ColorPicker {
    _onSelected;
    _element;
    _mouseDown;
    /****************************************/
    constructor() {
        for (var color in MATERIAL_COLORS)
            this.addColor(MATERIAL_COLORS[color][600]);
        this._mouseDown = ev => this.onMouseDown(ev);
    }
    /****************************************/
    attachNode(element) {
        this._element = element;
        document.body.appendChild(this._element);
    }
    /****************************************/
    async pick() {
        await this.open();
        return new Promise(res => this._onSelected = res);
    }
    /****************************************/
    addColor(color) {
        this.colors.push({
            value: color,
            select: () => {
                if (this._onSelected)
                    this._onSelected(color);
                this._onSelected = null;
                this.close();
            }
        });
    }
    /****************************************/
    async open() {
        if (this.isOpened())
            return;
        this.isOpened(true);
        if (window.event) {
            const mouseEvent = window.event;
            const coords = { x: mouseEvent.pageX, y: mouseEvent.pageY };
            //await PromiseUtils.delay(0);
            this._element.style.left = coords.x + "px";
            this._element.style.top = (coords.y - this._element.clientHeight) + "px";
        }
        document.body.addEventListener("mousedown", this._mouseDown);
    }
    /****************************************/
    close() {
        if (!this.isOpened())
            return;
        this.isOpened(false);
        document.body.removeEventListener("mousedown", this._mouseDown);
    }
    /****************************************/
    onMouseDown(ev) {
        if (ev.target.parentElement != this._element) {
            if (this._onSelected)
                this._onSelected(undefined);
            this._onSelected = null;
            this.close();
        }
    }
    /****************************************/
    isOpened = ko.observable(false);
    colors = [];
    static instance = new ColorPicker();
}

// EXTERNAL MODULE: external "Desmos"
var external_Desmos_ = __webpack_require__(1431);
;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Components/StudioRegression.js




function pSBCr(d) {
    let r, g, b, a;
    let m = Math.round;
    let i = parseInt;
    let n = d.length, x = {};
    if (n > 9) {
        [r, g, b, a] = d = d.split(","), n = d.length;
        if (n < 3 || n > 4)
            return null;
        x.r = i(r[3] == "a" ? r.slice(5) : r.slice(4)), x.g = i(g), x.b = i(b), x.a = a ? parseFloat(a) : -1;
    }
    else {
        if (n == 8 || n == 6 || n < 4)
            return null;
        if (n < 6)
            d = "#" + d[1] + d[1] + d[2] + d[2] + d[3] + d[3] + (n > 4 ? d[4] + d[4] : "");
        d = i(d.slice(1), 16);
        if (n == 9 || n == 5)
            x.r = d >> 24 & 255, x.g = d >> 16 & 255, x.b = d >> 8 & 255, x.a = m((d & 255) / 0.255) / 1000;
        else
            x.r = d >> 16, x.g = d >> 8 & 255, x.b = d & 255, x.a = -1;
    }
    return x;
}
function blendColor(p, c0, c1, l) {
    let r, g, b, P, f, t, h, i = parseInt, m = Math.round, a = typeof (c1) == "string";
    if (typeof (p) != "number" || p < -1 || p > 1 || typeof (c0) != "string" || (c0[0] != 'r' && c0[0] != '#') || (c1 && !a))
        return null;
    h = c0.length > 9, h = a ? c1.length > 9 ? true : c1 == "c" ? !h : false : h, f = pSBCr(c0), P = p < 0, t = c1 && c1 != "c" ? pSBCr(c1) : P ? { r: 0, g: 0, b: 0, a: -1 } : { r: 255, g: 255, b: 255, a: -1 }, p = P ? p * -1 : p, P = 1 - p;
    if (!f || !t)
        return null;
    if (l)
        r = m(P * f.r + p * t.r), g = m(P * f.g + p * t.g), b = m(P * f.b + p * t.b);
    else
        r = m((P * f.r ** 2 + p * t.r ** 2) ** 0.5), g = m((P * f.g ** 2 + p * t.g ** 2) ** 0.5), b = m((P * f.b ** 2 + p * t.b ** 2) ** 0.5);
    a = f.a, t = t.a, f = a >= 0 || t >= 0, a = f ? a < 0 ? t : t < 0 ? a : a * P + t * p : 0;
    if (h)
        return "rgb" + (f ? "a(" : "(") + r + "," + g + "," + b + (f ? "," + m(a * 1000) / 1000 : "") + ")";
    else
        return "#" + (4294967296 + r * 16777216 + g * 65536 + b * 256 + (f ? m(a * 255) : 0)).toString(16).slice(1, f ? undefined : -2);
}
function toSafeString(value) {
    if (value == null || value == undefined)
        return undefined;
    return value.toString();
}
/****************************************/
class RegressionFunctionViewModel {
    select() {
    }
    /****************************************/
    icon;
    value;
    vars = ko.observable();
}
/****************************************/
class RegressionFunctionVarViewModel {
    value;
    curValue = ko.observable();
    autoCompute = ko.observable();
    min = ko.observable();
    max = ko.observable();
    step = ko.observable();
}
/****************************************/
class StudioSerieRegression extends BaseStudioItem {
    _varsMap = {};
    /****************************************/
    constructor(config) {
        super();
        this._varsMap = {
            "fun": null,
            "sum": null,
            "n1": null,
            "n2": null,
            "value": null,
            "time": null,
            "tend": null,
            "tstart": null,
            "xp": null,
            "s": null,
            "n3": null,
        };
        this.itemType = "regression";
        this.icon = "show_chart";
        this.optionsTemplateName = "RegressionOptionsTemplate";
        this.functions = [];
        this.addFunction({
            name: $string("$(log-normal)"),
            type: "log-normal",
            value: "$s\\sim $c\\cdot\\frac{ e^ {-\\frac{ \\left(\\ln\\ \\left($x - $a\\right) \\ -$u\\right)^ { 2}} { 2$o^ { 2} }}}{ \\left($x - $a\\right) \\sqrt{ 2\\pi } $o }",
            vars: [{
                    name: "a",
                    label: $string("$(offset)"),
                    autoCompute: true,
                    precision: 0
                },
                {
                    name: "c",
                    label: $string("$(total)"),
                    autoCompute: true,
                    precision: 0
                },
                {
                    name: "o",
                    label: $string("$(variance)"),
                    autoCompute: true,
                    precision: 5
                },
                {
                    name: "u",
                    label: $string("$(average)"),
                    autoCompute: true,
                    precision: 5
                }]
        });
        this.addFunction({
            name: $string("$(normal)"),
            type: "normal",
            value: "$s\\sim $c\\cdot\\ \\left(\\frac{1}{\\sqrt{2\\cdot\\pi}\\cdot $o}\\right)\\cdot e^{-\\frac{1}{2}\\cdot\\left(\\frac{\\left($x-$u\\right)}{$o}\\right)^{2}}",
            vars: [
                {
                    name: "c",
                    label: $string("$(total)"),
                    autoCompute: true,
                    precision: 0
                },
                {
                    name: "o",
                    label: $string("$(variance)"),
                    autoCompute: true,
                    precision: 5
                },
                {
                    name: "u",
                    label: $string("$(avg-peak)"),
                    autoCompute: true,
                    precision: 0
                }
            ]
        });
        this.addFunction({
            name: $string("$(exponential)"),
            type: "exponential",
            value: "$s\\sim $a^{\\left($x-$b\\right)}",
            vars: [
                {
                    name: "a",
                    label: $string("$(base)"),
                    autoCompute: true,
                    precision: 5
                },
                {
                    name: "b",
                    label: $string("$(offset)"),
                    autoCompute: true,
                    precision: 5
                }
            ]
        });
        this.addFunction({
            name: $string("$(linear)"),
            type: "linear",
            value: "$s\\sim $a+$m$x",
            vars: [
                {
                    name: "a",
                    label: $string("$(offset)"),
                    autoCompute: true,
                    precision: 5
                },
                {
                    name: "m",
                    label: $string("$(slope)"),
                    autoCompute: true,
                    precision: 5
                }
            ]
        });
        this.showIntegration.subscribe(() => {
            this._graphCtx.setItemVisibile(this.getGraphId("sum-serie"), this.isFullVisible() && this.showIntegration());
            this._graphCtx.setItemVisibile(this.getGraphId("sum-point"), this.isFullVisible() && this.showIntegration());
        });
        this.selectedFunction.subscribe(a => {
            if (!this.name() && a)
                return this.name(a.value.name);
        });
        this.startDay.subscribe(a => this.updateStartDay());
        this.endDay.subscribe(a => this.updateEndDay());
        this.maxDay.subscribe(a => {
            this.updateEndDay();
            this.updateStartDay();
        });
        this.selectedFunction(this.functions[0]);
        if (config)
            this.setState(config);
    }
    /****************************************/
    get mainExpression() {
        return this.getGraphId("main-func");
    }
    /****************************************/
    addFunction(value) {
        const model = new RegressionFunctionViewModel();
        model.value = value;
        model.select = () => {
            this.selectedFunction(model);
            this.name(model.value.name);
            this.updateGraph();
        };
        const vars = [];
        for (let item of value.vars) {
            const vModel = new RegressionFunctionVarViewModel();
            vModel.value = item;
            vModel.curValue(item.value);
            vModel.autoCompute(item.autoCompute);
            vModel.min(item.minValue);
            vModel.max(item.maxValue);
            vModel.step(item.step);
            vModel.min.subscribe(a => item.minValue = a);
            vModel.max.subscribe(a => item.maxValue = a);
            vModel.step.subscribe(a => item.step = a);
            vModel.curValue.subscribe(a => item.value = a);
            vModel.autoCompute.subscribe(a => {
                item.autoCompute = a;
                this.updateGraph();
            });
            vModel.curValue.subscribe(value => {
                if (!vModel.autoCompute()) {
                    this._graphCtx.updateVariable(this.getGraphId(item.name + "-value"), this.getVar(item.name), value);
                }
            });
            vars.push(vModel);
        }
        model.vars(vars);
        this.functions.push(model);
        return model;
    }
    /****************************************/
    onGraphChanged() {
        /*
        const item = this._graphCtx.calculator.expressionAnalysis[this.getGraphId("end-day")];
        if (item && item.evaluation)
            this.endDay(item.evaluation.value);*/
        this.updateRegressionVars();
    }
    /****************************************/
    updateRegressionVars() {
        let model = this._graphCtx.calculator.controller.getItemModel(this.getGraphId("main"));
        if (model && model.regressionParameters) {
            for (let item of this.selectedFunction().vars()) {
                const varName = this.getVar(item.value.name).replace("{", "").replace("}", "");
                let value = model.regressionParameters[varName];
                if (value != undefined) {
                    if (item.value.precision != undefined)
                        value = round(value, item.value.precision);
                    item.curValue(value);
                }
            }
        }
    }
    /****************************************/
    createParameters(result) {
        result.push(apply(new ParameterViewModel({ value: this.startDay, name: $string("$(start-day)") }), p => {
            p.max = this.maxDay;
            p.min(1);
            p.step(1);
        }));
        result.push(apply(new ParameterViewModel({ value: this.endDay, name: $string("$(end-day)") }), p => {
            p.max = this.maxDay;
            p.min(1);
            p.step(1);
        }));
        return true;
    }
    /****************************************/
    setStateWork(state) {
        if (state.function) {
            const func = (0,Linq/* linq */.k)(this.functions).first(a => a.value.type == state.function.type);
            if (func) {
                for (let item of state.function.vars) {
                    const funcVar = (0,Linq/* linq */.k)(func.vars()).first(a => a.value.name == item.name);
                    if (funcVar) {
                        funcVar.autoCompute(item.autoCompute);
                        funcVar.max(item.maxValue);
                        funcVar.min(item.minValue);
                        funcVar.step(item.step);
                        funcVar.curValue(item.value);
                    }
                }
                this.selectedFunction(func);
            }
        }
        if (state.showIntegration != undefined)
            this.showIntegration(state.showIntegration);
        if (state.startDay != undefined)
            this.startDay(state.startDay);
        if (state.endDay != undefined)
            this.endDay(state.endDay);
    }
    /****************************************/
    getState() {
        const state = super.getState();
        state.function = this.selectedFunction().value;
        state.showIntegration = this.showIntegration();
        state.startDay = this.startDay();
        state.endDay = this.endDay();
        for (let item of this.selectedFunction().vars()) {
            item.value.value = item.curValue();
            item.value.maxValue = item.max();
            item.value.minValue = item.min();
            item.value.step = item.step();
            item.value.autoCompute = item.autoCompute();
        }
        return state;
    }
    /****************************************/
    onParentChanged() {
        super.onParentChanged();
        this.color(this.parent.color());
        this.maxDay((0,Linq/* linq */.k)(this.parent.values).max(a => a.x));
        if (this.endDay() == undefined)
            this.endDay(this.maxDay());
        if (this.startDay() == undefined)
            this.startDay(1);
    }
    /****************************************/
    updateEndDay() {
        if (!this._varsMap["tend"])
            return;
        this._graphCtx.updateExpression({
            type: "expression",
            id: this.getGraphId("end-day"),
            latex: this._varsMap["tend"] + "=" + this.endDay(),
            slider: {
                min: "0",
                step: "1",
                max: (this.maxDay()).toString(),
            }
        });
    }
    /****************************************/
    updateStartDay() {
        if (!this._varsMap["tstart"])
            return;
        this._graphCtx.updateExpression({
            type: "expression",
            id: this.getGraphId("start-day"),
            latex: this._varsMap["tstart"] + "=" + this.startDay(),
            slider: {
                min: "0",
                step: "1",
                max: (this.maxDay()).toString(),
            }
        });
    }
    /****************************************/
    updateColor() {
        this._graphCtx.setColor(this.getGraphId("main-func"), this.color());
        this._graphCtx.setColor(this.getGraphId("sum-serie"), this.color());
        this._graphCtx.setColor(this.getGraphId("sum-point"), this.color());
        this._graphCtx.setColor(this.getGraphId("end-day-line"), this.color());
        this._graphCtx.setColor(this.getGraphId("start-day-line"), this.color());
    }
    /****************************************/
    updateGraphWork() {
        this.updateRegressionVars();
    }
    /****************************************/
    getExpressions() {
        const values = [];
        values.push({
            type: "folder",
            id: this.getGraphId("public"),
            title: this.parent.name() + " - " + this.name(),
            collapsed: true
        });
        values.push({
            type: "folder",
            id: this.getGraphId("private"),
            secret: true,
            title: this.parent.name() + " - " + this.name(),
            collapsed: true
        });
        const func = this.selectedFunction().value;
        this._varsMap["x"] = "";
        this._varsMap["y"] = this.parent.getVar("y");
        this._varsMap["time"] = this.parent.parent.getVar("time");
        for (let item of func.vars) {
            if (!this._varsMap[item.name])
                this._varsMap[item.name] = null;
        }
        this._graphCtx.generateVars(this._varsMap);
        this._varsMap["x"] = this.getVar("xp");
        const regColor = blendColor(-0.3, this.color(), false, true);
        values.push({
            type: "expression",
            id: this.getGraphId("main"),
            folderId: this.getGraphId("private"),
            latex: this.replaceVars(func.value),
            hidden: true
        });
        values.push({
            type: "expression",
            id: this.getGraphId("main-func"),
            folderId: this.getGraphId("private"),
            latex: this.replaceVars(func.value.replace("$s\\sim ", "$fun\\left(x\\right)=").replace(/\$x/g, "x")),
            color: regColor,
            lineStyle: external_Desmos_.Styles.DASHED
        });
        values.push({
            type: "expression",
            id: this.getGraphId("sum-func"),
            folderId: this.getGraphId("private"),
            latex: this.replaceVars("$sum\\left(x\\right)=\\sum_{$n1=1}^{x}\\operatorname{round}\\left($fun\\left($n1\\right)\\right)"),
            hidden: true
        });
        values.push({
            type: "expression",
            id: this.getGraphId("subserie-func"),
            folderId: this.getGraphId("private"),
            latex: this.replaceVars("$s=\\sum_{$n3=$xp}^{$xp}{$y}[$n3+1]"),
            hidden: true
        });
        values.push({
            type: "expression",
            id: this.getGraphId("subserie-hl"),
            folderId: this.getGraphId("private"),
            latex: this.replaceVars("($xp, $s)"),
            color: regColor,
            lines: false,
            lineStyle: external_Desmos_.Styles.POINT,
            pointStyle: "NONE",
            points: true
        });
        values.push({
            type: "expression",
            id: this.getGraphId("sum-x-time"),
            folderId: this.getGraphId("private"),
            latex: this.replaceVars("$n2=\\left[1,...,$time\\right]"),
        });
        values.push({
            type: "expression",
            id: this.getGraphId("sum-serie"),
            folderId: this.getGraphId("private"),
            latex: this.replaceVars("\\left($n2,\\ $sum\\left($n2\\right)\\right)"),
            color: this.parent.color(),
            lines: true,
            hidden: !this.showIntegration(),
            lineStyle: external_Desmos_.Styles.SOLID,
            pointStyle: "NONE",
            points: false
        });
        values.push({
            type: "expression",
            id: this.getGraphId("sum-value"),
            folderId: this.getGraphId("public"),
            latex: this.replaceVars("$value=$sum\\left($time\\right)"),
        });
        values.push({
            type: "expression",
            id: this.getGraphId("sum-point"),
            folderId: this.getGraphId("private"),
            hidden: !this.showIntegration(),
            latex: this.replaceVars("\\left($time,$value\\right)"),
            color: this.parent.color(),
            label: this.parent.name(),
            dragMode: "XY",
            showLabel: true
        });
        values.push({
            type: "expression",
            id: this.getGraphId("end-day"),
            latex: this._varsMap["tend"] + "=" + this.endDay(),
            folderId: this.getGraphId("public"),
            label: "Fine Previsione",
            slider: {
                min: (0).toString(),
                max: (this.maxDay()).toString(),
                hardMax: true,
                hardMin: true,
                step: "1"
            }
        });
        values.push({
            type: "expression",
            id: this.getGraphId("start-day"),
            latex: this._varsMap["tstart"] + "=" + this.startDay(),
            folderId: this.getGraphId("public"),
            label: "Inizio Previsione",
            slider: {
                min: (0).toString(),
                max: (this.maxDay()).toString(),
                hardMax: true,
                hardMin: true,
                step: "1"
            }
        });
        values.push({
            type: "expression",
            id: this.getGraphId("end-day-line"),
            color: regColor,
            latex: "x=" + this._varsMap["tend"],
            folderId: this.getGraphId("private"),
            lines: true
        });
        values.push({
            type: "expression",
            id: this.getGraphId("start-day-line"),
            color: regColor,
            latex: "x=" + this._varsMap["tstart"],
            folderId: this.getGraphId("private"),
            lines: true
        });
        values.push({
            type: "expression",
            id: this.getGraphId("end-day-serie"),
            latex: this.replaceVars("$xp=[$tstart,...,$tend]+" + this.parent.getVar("ofs")),
            folderId: this.getGraphId("private"),
            hidden: true
        });
        for (let item of this.selectedFunction().vars()) {
            if (item.autoCompute())
                this._graphCtx.calculator.removeExpression({ id: this.getGraphId(item.value.name + "-value") });
            else {
                values.push({
                    type: "expression",
                    id: this.getGraphId(item.value.name + "-value"),
                    latex: this.getVar(item.value.name) + "=" + (item.curValue() ? item.curValue().toString() : "0"),
                    folderId: this.getGraphId("public"),
                    label: item.value.name,
                    slider: {
                        min: toSafeString(item.value.minValue),
                        max: toSafeString(item.value.maxValue),
                        hardMax: true,
                        hardMin: true,
                        step: toSafeString(item.value.step)
                    }
                });
            }
        }
        return values;
    }
    /****************************************/
    functions;
    selectedFunction = ko.observable();
    showIntegration = ko.observable(true);
    maxDay = ko.observable();
    endDay = ko.observable();
    startDay = ko.observable();
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Components/StudioSerie.js










/****************************************/
class StudioSerie extends BaseStudioItem {
    constructor(config) {
        super();
        this.canDrag = true;
        this.itemType = "serie";
        this.icon = "insert_chart";
        this.optionsTemplateName = "StudioOptionsTemplate";
        this._varsMap = {
            "x": null,
            "y": null,
            "ofs": null,
            "xofs": null,
        };
        if (config) {
            this.setState(config);
        }
    }
    /****************************************/
    importValues(points) {
        if (points && points.length > 0) {
            if (points[0].x instanceof Date) {
                const startDate = points[0].x;
                this.values = (0,Linq/* linq */.k)(points).select(a => ({
                    x: Math.round(dateDiff(a.x, startDate).totalDays),
                    xLabel: a.x,
                    y: a.y
                })).toArray();
            }
            else if (isNaN(points[0].x)) {
                this.values = (0,Linq/* linq */.k)(points).select((a, i) => ({
                    x: i,
                    xLabel: a.x,
                    y: a.y
                })).toArray();
                return;
            }
            else
                this.values = points;
        }
        else
            this.values = [];
        this.onSerieChanged();
    }
    /****************************************/
    writeData(transfer) {
        var data = {
            version: 1,
            type: "serieState",
            state: this.getState()
        };
        transfer.setData("application/json+studio", JSON.stringify(data));
        transfer.setData("text/html+id", this.node.element.id);
        return true;
    }
    /****************************************/
    createActions(result) {
        super.createActions(result);
        result.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(update)");
            action.icon = "autorenew";
            action.execute = () => this.updateSerie();
        }));
        result.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(new-regression)");
            action.icon = "add_box";
            action.execute = () => {
                const reg = this.addRegression(null, false);
                reg.updateGraph();
                this.node.isExpanded(true);
                reg.node.isSelected(true);
            };
        }));
        result.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(zoom)");
            action.icon = "zoom_in";
            action.execute = () => this.zoom();
        }));
        result.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(align-with-this)");
            action.icon = "compare_arrows";
            action.execute = () => {
                let answer = prompt($string("$(tollerance)"), "10");
                this.alignOthers(isNaN(answer) ? 10 : parseInt(answer));
            };
        }));
    }
    /****************************************/
    static fromText(text) {
        try {
            const obj = JSON.parse(text);
            if (obj) {
                if (obj.type == "serie")
                    return new StudioSerie({
                        name: obj.title,
                        values: obj.values,
                        source: obj.serie,
                        color: obj.color
                    });
                if (obj.type == "serieState")
                    return new StudioSerie(obj.state);
            }
        }
        catch {
        }
    }
    /****************************************/
    getExpressions() {
        if (!this.color())
            this.color("#0000ff");
        this._graphCtx.generateVars(this._varsMap);
        const values = [
            {
                type: "folder",
                id: this.getGraphId("public"),
                title: this.parent.name() + " - " + this.name(),
                collapsed: true
            }, {
                type: "folder",
                id: this.getGraphId("private"),
                title: this.parent.name() + " - " + this.name(),
                secret: true,
                collapsed: true
            }, {
                type: "expression",
                id: this.getGraphId("offset"),
                latex: this._varsMap["ofs"] + "=" + this.offsetX(),
                folderId: this.getGraphId("public"),
                label: "Scostamento",
                slider: {
                    min: (-this.values.length).toString(),
                    max: (this.values.length).toString(),
                    hardMax: true,
                    hardMin: true,
                    step: "1"
                }
            }, {
                type: "expression",
                id: this.getGraphId("offset-x"),
                latex: this._varsMap["xofs"] + "=" + this._varsMap["x"] + "+" + this._varsMap["ofs"],
                folderId: this.getGraphId("private"),
            }, {
                type: "expression",
                id: this.getGraphId("offset-x-serie"),
                latex: "(" + this._varsMap["xofs"] + "," + this._varsMap["y"] + ")",
                folderId: this.getGraphId("private"),
                points: true,
                lines: true,
                color: this.color()
            }, {
                type: "table",
                id: this.getGraphId("table"),
                folderId: this.getGraphId("private"),
                columns: [
                    {
                        id: this.getGraphId("table/x"),
                        latex: this._varsMap["x"],
                    },
                    {
                        id: this.getGraphId("table/y"),
                        latex: this._varsMap["y"],
                        hidden: true
                    }
                ]
            }
        ];
        return values;
    }
    /****************************************/
    alignOthers(tollerance, ...series) {
        if (!series || series.length == 0)
            series = this.parent.children.where(a => a != this).toArray();
        for (let serie of series)
            serie.alignWith(this, tollerance);
    }
    /****************************************/
    alignWith(other, tollerance) {
        let minOfs = 0;
        let minValue = Number.NEGATIVE_INFINITY;
        for (let ofs = -this.values.length; ofs < this.values.length; ofs++) {
            let value = 0;
            for (let i = 0; i < this.values.length; i++) {
                const ofsX = i - ofs;
                if (ofsX < 0 || ofsX >= this.values.length)
                    continue;
                if (i >= other.values.length)
                    continue;
                if (Math.abs(this.values[ofsX].y - other.values[i].y) < tollerance)
                    value++;
            }
            if (value > minValue) {
                minValue = value;
                minOfs = ofs;
            }
        }
        other.offsetX(0);
        this.offsetX(minOfs);
    }
    /****************************************/
    get mainExpression() {
        return this.getGraphId("offset-x-serie");
    }
    /****************************************/
    createParameters(result) {
        result.push(apply(new ParameterViewModel({ value: this.offsetX, name: $string("$(shift)") }), p => {
            p.max(this.values.length);
            p.min(-this.values.length);
            p.step(1);
        }));
        return true;
    }
    /****************************************/
    updateGraphWork() {
        this._graphCtx.updateTable(this.getGraphId("table"), this.values);
    }
    /****************************************/
    onGraphChanged() {
        /*
        const item = this._graphCtx.calculator.expressionAnalysis[this.getGraphId("offset")];
        if (item && item.evaluation)
            this.offsetX(item.evaluation.value);*/
    }
    /****************************************/
    onSelected() {
        super.onSelected();
        //this._graphCtx.expressionZoomFit(this.getGraphId("table"));
    }
    /****************************************/
    updateColor() {
        this._graphCtx.setColor(this.getGraphId("offset-x-serie"), this.color());
        this.children.foreach(a => a.onParentChanged());
    }
    /****************************************/
    attachGraph(ctx) {
        super.attachGraph(ctx);
        this.offsetX.subscribe(value => {
            this._graphCtx.updateVariable(this.getGraphId("offset"), this._varsMap["ofs"], value);
            this.onSerieChanged();
        });
    }
    /****************************************/
    onSerieChanged() {
        if (this._isUpdating == 0)
            this.parent.updateAggregate();
    }
    /****************************************/
    setChildrenStateWork(state) {
        if (state.children != undefined) {
            this.children.foreach(a => a.remove());
            state.children.forEach(a => {
                const reg = this.addRegression(null, false);
                reg.setState(a);
            });
        }
    }
    /****************************************/
    setStateWork(state) {
        if (state.offsetX != undefined)
            this.offsetX(state.offsetX);
        if (state.source)
            this.source = this.upgradeSource(state.source);
        if (state.values != undefined)
            this.importValues(state.values);
    }
    /****************************************/
    upgradeSource(source) {
        if (!source.type)
            source.type = "geoplot";
        if (source.type == "geoplot") {
            source.areaId = this.upgradeAreaId(source.areaId);
            if (source.exeludedAreaIds)
                for (let i = 0; i < source.exeludedAreaIds.length; i++)
                    source.exeludedAreaIds[i] = this.upgradeAreaId(source.exeludedAreaIds[i]);
        }
        return source;
    }
    /****************************************/
    upgradeAreaId(id) {
        if (id) {
            if (id.startsWith("R") && id.length == 2)
                return "R0" + id.substring(1);
            if (id.startsWith("D") && id.length == 2)
                return "D00" + id.substring(1);
            if (id.startsWith("D") && id.length == 3)
                return "D0" + id.substring(1);
        }
        return id;
    }
    /****************************************/
    getState() {
        const state = super.getState();
        state.offsetX = this.offsetX();
        state.source = this.source;
        state.values = this.values;
        state.children = this.children.select(a => a.getState()).toArray();
        return state;
    }
    /****************************************/
    addRegression(configOrState, updateGraph = true) {
        return this.addChildrenWork(configOrState instanceof StudioSerieRegression ? configOrState : new StudioSerieRegression(configOrState), updateGraph);
    }
    /****************************************/
    async changeColor() {
        const color = await ColorPicker.instance.pick();
        if (color)
            this.color(color);
    }
    /****************************************/
    async updateSerie() {
        if (this.source.type == "geoplot" || !this.source.type) {
            if (!this._graphCtx.serieCalculator) {
                M.toast({ html: $string("$(msg-downloading-data)") });
                const model = await Api.loadStudioData();
                this._graphCtx.serieCalculator = new IndicatorCalculator(new RangeDayAreaDataSet(model.data), InfectionDataSet, model.geo);
            }
            const daySource = this.source;
            if (daySource.range) {
                this._graphCtx.serieCalculator.data.startDay = daySource.range.start;
                this._graphCtx.serieCalculator.data.endDay = daySource.range.end;
            }
            else {
                this._graphCtx.serieCalculator.data.startDay = undefined;
                this._graphCtx.serieCalculator.data.endDay = undefined;
            }
            this.importValues(this._graphCtx.serieCalculator.getSerie(daySource));
            this._graphCtx.updateTable(this.getGraphId("table"), this.values);
            this.children.foreach(a => a.onParentChanged());
            this.onSerieChanged();
            M.toast({ html: $string("$(msg-update-complete)") });
        }
        else
            M.toast({ html: $string("$(msg-update-not-supported)") });
    }
    /****************************************/
    zoom() {
        const minX = (0,Linq/* linq */.k)(this.values).min(a => a.x);
        const minY = (0,Linq/* linq */.k)(this.values).min(a => a.y);
        const maxX = (0,Linq/* linq */.k)(this.values).max(a => a.x);
        const maxY = (0,Linq/* linq */.k)(this.values).max(a => a.y);
        this._graphCtx.calculator.setMathBounds({
            top: maxY + (maxY - minY) * 0.1,
            right: maxX + (maxX - minX) * 0.1,
            bottom: minY - (maxY - minY) * 0.1,
            left: minX - (maxX - minX) * 0.1,
        });
    }
    /****************************************/
    color = ko.observable();
    offsetX = ko.observable(0);
    source;
    values = [];
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Components/StudioProject.js





/****************************************/
class StudioProject extends BaseStudioItem {
    constructor(config) {
        super();
        this.itemType = "project";
        this.icon = "folder";
        this.optionsTemplateName = "ProjectOptionsTemplate";
        this.aggregationModes = [
            {
                text: $string("$(none)"),
                value: "none"
            },
            {
                text: $string("$(sum)"),
                value: "sum"
            },
            {
                text: $string("$(average)"),
                value: "avg",
            }
        ];
        this._varsMap = {
            "time": null,
            "xagg": null,
            "yagg": null
        };
        if (config)
            this.setState(config);
    }
    /****************************************/
    createActions(result) {
        super.createActions(result);
        result.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(update-all-proj)");
            action.icon = "autorenew";
            action.execute = () => this.updateAllSerie();
        }));
    }
    /****************************************/
    async updateAllSerie() {
        for (let item of this.children)
            await item.updateSerie();
    }
    /****************************************/
    canAccept(value) {
        return (value instanceof StudioSerie);
    }
    /****************************************/
    canReadData(transfer) {
        return transfer.types.indexOf("application/json+studio") != -1;
    }
    /****************************************/
    readData(transfer) {
        const textData = transfer.getData("application/json+studio");
        let serie = StudioSerie.fromText(textData);
        if (serie) {
            this.addSerie(serie);
            this.node.isExpanded(true);
        }
    }
    /****************************************/
    getExpressions() {
        this._graphCtx.generateVars(this._varsMap);
        const values = [
            {
                type: "folder",
                id: this.getGraphId("public"),
                title: this.name(),
                collapsed: true
            },
            {
                type: "folder",
                id: this.getGraphId("private"),
                title: this.name(),
                secret: true,
                collapsed: true
            },
            {
                type: "expression",
                folderId: this.getGraphId("public"),
                id: this.getGraphId("time"),
                latex: this._varsMap["time"] + "=" + this.time(),
                slider: {
                    hardMin: true,
                    hardMax: true,
                    min: "0",
                    max: "100",
                    step: "1"
                }
            },
            {
                type: "table",
                id: this.getGraphId("aggregate"),
                folderId: this.getGraphId("private"),
                columns: [
                    {
                        id: this.getGraphId("table/xagg"),
                        latex: this._varsMap["xagg"],
                    },
                    {
                        id: this.getGraphId("table/yagg"),
                        latex: this._varsMap["yagg"],
                        lines: true,
                        points: true
                        //hidden: this.aggregationMode() == "none"
                    }
                ]
            }
        ];
        return values;
    }
    /****************************************/
    updateAggregate() {
        const values = {};
        const children = this.children.toArray();
        for (var child of children) {
            const ofs = parseInt(child.offsetX());
            for (var item of child.values) {
                const xReal = item.x + ofs;
                if (!(xReal in values))
                    values[xReal] = item.y;
                else
                    values[xReal] += item.y;
            }
        }
        const funValues = (0,Linq/* linq */.k)(values).orderBy(a => a.key).select(a => ({ x: a.key, y: a.value })).toArray();
        this._graphCtx.updateTable(this.getGraphId("aggregate"), funValues);
    }
    /****************************************/
    updateColor() {
        this._graphCtx.setColor(this.getGraphId("aggregate"), this.color());
    }
    /****************************************/
    get mainExpression() {
        return this.getGraphId("aggregate");
    }
    /****************************************/
    createParameters(result) {
        result.push(apply(new ParameterViewModel({ value: this.time, name: $string("$(day)") }), p => {
            p.max(100);
            p.min(0);
            p.step(1);
        }));
        return true;
    }
    /****************************************/
    setStateWork(state) {
        if (state.time != undefined)
            this.time(state.time);
        if (state.aggregationMode)
            this.aggregationMode(state.aggregationMode);
        else
            this.aggregationMode("none");
    }
    /****************************************/
    setChildrenStateWork(state) {
        if (state.children != undefined) {
            this.children.foreach(a => a.remove());
            state.children.forEach(a => {
                const item = this.addSerie(null, false);
                item.setState(a);
            });
        }
        if (this.aggregationMode() != "none")
            this.updateAggregate();
    }
    /****************************************/
    getState() {
        const state = super.getState();
        state.time = this.time();
        state.children = this.children.select(a => a.getState()).toArray();
        state.aggregationMode = this.aggregationMode();
        return state;
    }
    /****************************************/
    onGraphChanged() {
        /*
        const item = this._graphCtx.calculator.expressionAnalysis[this.getGraphId("time")];
        if (item)
            this.time(item.evaluation.value);*/
    }
    /****************************************/
    attachGraph(ctx) {
        super.attachGraph(ctx);
        this.time.subscribe(value => this._graphCtx.updateVariable(this.getGraphId("time"), this._varsMap["time"], this.time()));
        this.aggregationMode.subscribe(a => this.updateAggregate());
    }
    /****************************************/
    addSerie(configOrSerie, updateGraph = true) {
        return this.addChildrenWork(configOrSerie instanceof StudioSerie ? configOrSerie : new StudioSerie(configOrSerie), updateGraph);
    }
    /****************************************/
    time = ko.observable(0);
    aggregationMode = ko.observable("none");
    aggregationModes;
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Pages/StudioPage.js








/****************************************/
class ParameterViewModel {
    constructor(config) {
        this.value = config.value;
        this.name = config.name;
    }
    name;
    min = ko.observable();
    max = ko.observable();
    step = ko.observable();
    isSelected = ko.observable(true);
    value;
}
/****************************************/
class StudioPage {
    _graphCtx;
    _projectId;
    constructor(projectId) {
        this._projectId = projectId;
        this._graphCtx = new GraphContext();
        this._graphCtx.calculator = external_Desmos_.GraphingCalculator(document.getElementById("calculator"), {
            //xAxisArrowMode: Desmos.AxisArrowModes.BOTH,
            pasteGraphLink: false,
            pasteTableData: false,
            expressionsCollapsed: true,
            //lockViewport: false,
            restrictedFunctions: true,
            //restrictGridToFirstQuadrant: true,
            administerSecretFolders: true,
            authorIDE: true,
            advancedStyling: true
        });
        this._graphCtx.calculator.controller.listModel.onSelectionChanged = item => this.onGraphSelectionChanged(item);
        const actions = [];
        actions.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(new-project)"),
                action.icon = "create_new_folder";
            action.execute = () => this.newProject();
        }));
        actions.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(save)"),
                action.icon = "save";
            action.execute = () => this.saveState();
        }));
        actions.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(import)"),
                action.icon = "import_export";
            action.execute = () => this.import();
        }));
        actions.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(share) Studio"),
                action.icon = "share";
            action.execute = () => this.share();
        }));
        actions.push(apply(new TreeView_ActionView(), action => {
            action.text = $string("$(options)"),
                action.icon = "settings";
            action.execute = () => this.showOptions();
        }));
        const root = new TreeNode();
        root.actions(actions);
        this.items.setRoot(root);
        document.body.addEventListener("paste", async (ev) => {
            if (ev.target.tagName == "INPUT")
                return;
            if (await this.onPaste(ev.clipboardData))
                ev.preventDefault();
        });
        M.Modal.init(document.getElementById("options"), {
            onCloseEnd: () => this.updateOptions()
        });
        setTimeout(() => this.init());
    }
    /****************************************/
    onGraphSelectionChanged(item) {
        if (!item || !item.folderId)
            return;
        const folderGuid = item.folderId.split("/")[0];
        const treeItem = this._graphCtx.treeItems[folderGuid];
        if (!treeItem)
            return;
        treeItem.node.select(true);
    }
    /****************************************/
    updateOptions() {
        const maxX = parseInt(this.maxX());
        const maxY = parseInt(this.maxY());
        this._graphCtx.calculator.setMathBounds({
            bottom: -maxY / 10,
            left: -maxX / 10,
            right: maxX,
            top: maxY
        });
    }
    /****************************************/
    async share() {
        const projectId = uuidv4();
        await Api.saveState(projectId, this.getState());
        const url = Helpers_Uri/* Uri.absolute */.S.absolute("~/" + $language.split("-")[0] + "/Studio/" + projectId);
        await copyText(url);
        M.toast({ html: $string("$(msg-shared)") });
    }
    /****************************************/
    showOptions() {
        const bounds = this._graphCtx.calculator.graphpaperBounds;
        this.maxX(Math.round(bounds.mathCoordinates.width));
        this.maxY(Math.round(bounds.mathCoordinates.height));
        const dialog = M.Modal.getInstance(document.getElementById("options"));
        dialog.open();
    }
    /****************************************/
    getSelectedProject() {
        if (!this.items.selectedNode())
            return;
        const value = this.items.selectedNode().value();
        if (value.itemType == "project")
            return value;
        if (value.itemType == "serie")
            return value.parent;
        if (value.itemType == "regression")
            return value.parent.parent;
    }
    /****************************************/
    newProject() {
        const proj = this.addProject({ name: "Project " + (this.projects.count() + 1) });
        proj.node.isSelected(true);
        return proj;
    }
    /****************************************/
    addProject(config, updateGraph = true) {
        const project = new StudioProject(config);
        const node = new TreeNode(project);
        this.items.root().addNode(node);
        project.attachNode(node);
        project.attachGraph(this._graphCtx);
        if (updateGraph)
            project.updateGraph();
        return project;
    }
    /****************************************/
    getState() {
        const result = { version: 2 };
        result.graphState = this._graphCtx.calculator.getState();
        result.vars = this._graphCtx.vars;
        result.projects = this.projects.select(a => a.getState()).toArray();
        return result;
    }
    /****************************************/
    setState(value) {
        if (!value)
            return;
        if (value.graphState) {
            value.graphState.expressions.list = [];
            this._graphCtx.calculator.setState(value.graphState);
        }
        if (value.projects != undefined) {
            this.projects.toArray().forEach(a => a.remove());
            value.projects.forEach(a => {
                const proj = this.addProject(null, false);
                proj.setState(a);
            });
        }
    }
    /****************************************/
    async loadState() {
        if (this._projectId) {
            let result = await Api.loadState(this._projectId);
            this.setState(result);
        }
        else {
            const json = localStorage.getItem("studio");
            if (json)
                this.setState(JSON.parse(json));
        }
    }
    /****************************************/
    async saveState() {
        if (this._projectId) {
            await Api.saveState(this._projectId, this.getState());
            M.toast({ html: $string("$(msg-saved)") });
        }
        else {
            localStorage.setItem("studio", JSON.stringify(this.getState()));
            M.toast({ html: $string("$(msg-saved-device)") });
        }
    }
    /****************************************/
    demo() {
        const proj = this.addProject({ name: "Project 1" });
        this.addProject({ name: "Project 2" });
        this.addProject({ name: "Project 3" });
        proj.addSerie({
            name: "Serie 1"
        });
    }
    /****************************************/
    async onPaste(data) {
        const text = data.getData("text/plain").toString();
        if (text)
            return await this.importText(text);
        return false;
    }
    /****************************************/
    async import() {
        //var text = await (await fetch("https://raw.githubusercontent.com/datasets/covid-19/master/data/countries-aggregated.csv")).text();
        let project = this.getSelectedProject();
        const data = await this.dataImport.show();
        this.addImportedData(data, project);
        return true;
    }
    /****************************************/
    async importText(text) {
        let project = this.getSelectedProject();
        if (!project && !this.projects.any())
            project = this.newProject();
        if (!project) {
            M.toast({ html: $string("$(msg-select-project)") });
            return false;
        }
        const serie = StudioSerie.fromText(text);
        if (serie) {
            project.addSerie(serie);
            project.node.isExpanded(true);
            serie.node.isExpanded(true);
            serie.zoom();
            const reg = serie.addRegression(null, false);
            reg.updateGraph();
            reg.node.isSelected(true);
            return true;
        }
        try {
            if (await this.dataImport.importText(text))
                await this.import();
        }
        catch (e) {
            console.error(e);
        }
        M.toast({ html: $string("$(msg-format-not-reconized)") });
        return false;
    }
    /****************************************/
    addImportedData(data, project) {
        if (data.length == 1) {
            if (this.items.selectedNode() && this.items.selectedNode().value() instanceof StudioSerie) {
                if (confirm($string("$(msg-replace-serie)"))) {
                    const serie = this.items.selectedNode().value();
                    serie.source = data[0];
                    serie.importValues(data[0].serie.values);
                    serie.updateGraph(true);
                    return true;
                }
            }
        }
        project.node.isExpanded(true);
        for (let item of data) {
            const serie = new StudioSerie({
                name: item.serie.name,
                values: item.serie.values,
                source: item
            });
            project.addSerie(serie);
            serie.node.isExpanded(true);
            const reg = serie.addRegression(null, false);
            reg.updateGraph();
            reg.node.isSelected(true);
        }
    }
    /****************************************/
    get projects() {
        function* items() {
            for (let node of this.items.root().nodes())
                yield node.value();
        }
        return (0,Linq/* linq */.k)(items.apply(this));
    }
    /****************************************/
    async init() {
        this.loadState();
    }
    /****************************************/
    items = new TreeView();
    maxX = ko.observable();
    maxY = ko.observable();
    dataImport = new DataImportControl();
}

// EXTERNAL MODULE: external "Chart"
var external_Chart_ = __webpack_require__(2370);
;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Data/ViewModes.js

var ViewModes = {
    "district": {
        label: {
            singular: $string("$(district)"),
            plural: $string("$(districts)")
        },
        mapGroup: "group_district",
        tab: "districtTab",
        areaType: GeoAreaType.District,
        validateId: (id) => id[0].toLowerCase() == 'd'
    },
    "region": {
        label: {
            singular: $string("$(region)"),
            plural: $string("$(regions)")
        },
        mapGroup: "group_region",
        tab: "regionTab",
        areaType: GeoAreaType.Region,
        validateId: (id) => id[0].toLowerCase() == 'r'
    },
    "country": {
        label: {
            singular: $string("$(italian)"),
            plural: $string("$(italians)")
        },
        mapGroup: "group_country",
        tab: "italyTab",
        areaType: GeoAreaType.Country,
        validateId: (id) => id.toLowerCase() == 'it'
    },
    'details': {
        label: {
            singular: $string("$(area-details)"),
            plural: $string("$(area-details)")
        },
        mapGroup: "group_municipality",
        tab: "detailsTab",
        areaType: GeoAreaType.Municipality,
        validateId: (id) => id[0].toLowerCase() == 'm'
    }
};

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Framework/TipManager.js

/****************************************/
class TipViewModel {
    _closeTimeoutId;
    _element;
    _closeAfter;
    constructor(value, closeAfter) {
        this.value = value;
        this._closeAfter = closeAfter;
    }
    /****************************************/
    dontShowAgain() {
    }
    /****************************************/
    onActionExecuted() {
    }
    /****************************************/
    executeAction() {
        if (this.value.showAction)
            this.value.showAction();
        setTimeout(() => this.startPulse());
        this.onActionExecuted();
    }
    /****************************************/
    startPulse() {
        this._element = document.querySelector(this.value.elementSelector);
        if (!this._element)
            return;
        let relY = centerElement(this._element);
        DomUtils_addClass(this._element, "pulse");
        let tipElement = document.querySelector(".tip-container");
        if (relY < (tipElement.clientTop + tipElement.clientHeight))
            this.isTransparent(true);
    }
    /****************************************/
    stopPulse() {
        if (!this._element)
            return;
        DomUtils_removeClass(this._element, "pulse");
        this.isTransparent(false);
    }
    /****************************************/
    next() {
    }
    /****************************************/
    understood() {
    }
    /****************************************/
    onClose() {
    }
    /****************************************/
    close() {
        clearTimeout(this._closeTimeoutId);
        this.stopPulse();
        this.isVisible(false);
        this.onClose();
    }
    /****************************************/
    show() {
        if (this._closeTimeoutId)
            clearTimeout(this._closeTimeoutId);
        this.isVisible(true);
        if (this._closeAfter)
            this._closeTimeoutId = setTimeout(() => this.close(), this._closeAfter);
    }
    /****************************************/
    value;
    isVisible = ko.observable(false);
    isTransparent = ko.observable(false);
}
/****************************************/
class TipManager {
    _getPreferences;
    _tips;
    constructor(tips, getPreferences, savePreferences) {
        this._getPreferences = getPreferences;
        this._tips = tips;
        this.savePreferences = savePreferences;
    }
    /****************************************/
    get preferences() {
        return this._getPreferences();
    }
    /****************************************/
    savePreferences() {
    }
    /****************************************/
    markAction(actionId, label) {
        this.preferences.actions[actionId]++;
        this.savePreferences();
        if (!window["gtag"])
            return;
        safeCall(() => gtag("event", actionId, {
            event_category: "GeoPlot",
            event_label: label,
            value: this.preferences.actions[actionId]
        }));
    }
    /****************************************/
    markTip(tipId, action) {
        if (!window["gtag"])
            return;
        safeCall(() => gtag("event", action, {
            event_category: "GeoPlot/Tip",
            event_label: tipId
        }));
    }
    /****************************************/
    engageUser() {
        if (this.preferences.showTips != undefined && !this.preferences.showTips)
            return;
        const nextTip = (0,Linq/* linq */.k)(this._tips).where(a => a.value.showAfter > 0 && this.preferences.actions[a.key] == 0).first();
        if (!this.showTip(nextTip.key, {
            onClose: () => this.engageUser(),
            timeout: nextTip.value.showAfter,
        })) {
            this.engageUser();
        }
    }
    /****************************************/
    showTip(tipId, options) {
        if (this.preferences.showTips != undefined && !this.preferences.showTips)
            return false;
        if ((!options || !options.override) && this.tip() && this.tip().isVisible())
            return false;
        if ((!options || !options.force) && this.preferences.actions[tipId])
            return false;
        const tip = this._tips[tipId];
        const model = new TipViewModel(tip);
        model.onActionExecuted = () => {
            this.markTip(tipId, "how");
        };
        model.dontShowAgain = () => {
            this.preferences.showTips = false;
            this.savePreferences();
            model.close();
            this.markTip(tipId, "dontShowAgain");
        };
        model.understood = () => {
            this.preferences.actions[tipId]++;
            this.savePreferences();
            model.close();
            this.markTip(tipId, "understood");
        };
        model.onClose = () => {
            //this.tip(null);
            if (options && options.onClose)
                options.onClose();
        };
        let nextTip = (0,Linq/* linq */.k)(this._tips).where(a => a.value.order > tip.order && this.preferences.actions[a.key] == 0).first();
        if (nextTip) {
            model.next = () => {
                model.close();
                this.preferences.actions[tipId]++;
                this.showTip(nextTip.key);
                this.markTip(tipId, "next");
            };
        }
        else
            model.next = null;
        this.tip(model);
        setTimeout(() => model.show(), options && options.timeout ? options.timeout * 1000 : 0);
        return true;
    }
    tip = ko.observable();
}

;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/it/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'meno di un secondo',
    other: 'meno di {{count}} secondi'
  },
  xSeconds: {
    one: 'un secondo',
    other: '{{count}} secondi'
  },
  halfAMinute: 'alcuni secondi',
  lessThanXMinutes: {
    one: 'meno di un minuto',
    other: 'meno di {{count}} minuti'
  },
  xMinutes: {
    one: 'un minuto',
    other: '{{count}} minuti'
  },
  aboutXHours: {
    one: "circa un'ora",
    other: 'circa {{count}} ore'
  },
  xHours: {
    one: "un'ora",
    other: '{{count}} ore'
  },
  xDays: {
    one: 'un giorno',
    other: '{{count}} giorni'
  },
  aboutXWeeks: {
    one: 'circa una settimana',
    other: 'circa {{count}} settimane'
  },
  xWeeks: {
    one: 'una settimana',
    other: '{{count}} settimane'
  },
  aboutXMonths: {
    one: 'circa un mese',
    other: 'circa {{count}} mesi'
  },
  xMonths: {
    one: 'un mese',
    other: '{{count}} mesi'
  },
  aboutXYears: {
    one: 'circa un anno',
    other: 'circa {{count}} anni'
  },
  xYears: {
    one: 'un anno',
    other: '{{count}} anni'
  },
  overXYears: {
    one: 'più di un anno',
    other: 'più di {{count}} anni'
  },
  almostXYears: {
    one: 'quasi un anno',
    other: 'quasi {{count}} anni'
  }
};
function formatDistance(token, count, options) {
  options = options || {};
  var result;

  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return 'tra ' + result;
    } else {
      return result + ' fa';
    }
  }

  return result;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/it/_lib/formatLong/index.js

var dateFormats = {
  full: 'EEEE d MMMM y',
  long: 'd MMMM y',
  medium: 'd MMM y',
  short: 'dd/MM/y'
};
var timeFormats = {
  full: 'HH:mm:ss zzzz',
  long: 'HH:mm:ss z',
  medium: 'HH:mm:ss',
  short: 'HH:mm'
};
var dateTimeFormats = {
  full: '{{date}} {{time}}',
  long: '{{date}} {{time}}',
  medium: '{{date}} {{time}}',
  short: '{{date}} {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const _lib_formatLong = (formatLong);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/toDate/index.js

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js

 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function isSameUTCWeek(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var dateLeftStartOfWeek = startOfUTCWeek(dirtyDateLeft, options);
  var dateRightStartOfWeek = startOfUTCWeek(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/it/_lib/formatRelative/index.js

var weekdays = ['domenica', 'lunedì', 'martedì', 'mercoledì', 'giovedì', 'venerdì', 'sabato'];

function lastWeek(day) {
  switch (day) {
    case 0:
      return "'domenica scorsa alle' p";

    default:
      return "'" + weekdays[day] + " scorso alle' p";
  }
}

function thisWeek(day) {
  return "'" + weekdays[day] + " alle' p";
}

function nextWeek(day) {
  switch (day) {
    case 0:
      return "'domenica prossima alle' p";

    default:
      return "'" + weekdays[day] + " prossimo alle' p";
  }
}

var formatRelativeLocale = {
  lastWeek: function (date, baseDate, options) {
    var day = date.getUTCDay();

    if (isSameUTCWeek(date, baseDate, options)) {
      return thisWeek(day);
    } else {
      return lastWeek(day);
    }
  },
  yesterday: "'ieri alle' p",
  today: "'oggi alle' p",
  tomorrow: "'domani alle' p",
  nextWeek: function (date, baseDate, options) {
    var day = date.getUTCDay();

    if (isSameUTCWeek(date, baseDate, options)) {
      return thisWeek(day);
    } else {
      return nextWeek(day);
    }
  },
  other: 'P'
};
function formatRelative(token, date, baseDate, options) {
  var format = formatRelativeLocale[token];

  if (typeof format === 'function') {
    return format(date, baseDate, options);
  }

  return format;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/it/_lib/localize/index.js

var eraValues = {
  narrow: ['aC', 'dC'],
  abbreviated: ['a.C.', 'd.C.'],
  wide: ['avanti Cristo', 'dopo Cristo']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['T1', 'T2', 'T3', 'T4'],
  wide: ['1º trimestre', '2º trimestre', '3º trimestre', '4º trimestre']
};
var monthValues = {
  narrow: ['G', 'F', 'M', 'A', 'M', 'G', 'L', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['gen', 'feb', 'mar', 'apr', 'mag', 'giu', 'lug', 'ago', 'set', 'ott', 'nov', 'dic'],
  wide: ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre']
};
var dayValues = {
  narrow: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
  short: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],
  abbreviated: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],
  wide: ['domenica', 'lunedì', 'martedì', 'mercoledì', 'giovedì', 'venerdì', 'sabato']
};
var dayPeriodValues = {
  narrow: {
    am: 'm.',
    pm: 'p.',
    midnight: 'mezzanotte',
    noon: 'mezzogiorno',
    morning: 'mattina',
    afternoon: 'pomeriggio',
    evening: 'sera',
    night: 'notte'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'mezzanotte',
    noon: 'mezzogiorno',
    morning: 'mattina',
    afternoon: 'pomeriggio',
    evening: 'sera',
    night: 'notte'
  },
  wide: {
    am: 'AM',
    pm: 'PM',
    midnight: 'mezzanotte',
    noon: 'mezzogiorno',
    morning: 'mattina',
    afternoon: 'pomeriggio',
    evening: 'sera',
    night: 'notte'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'm.',
    pm: 'p.',
    midnight: 'mezzanotte',
    noon: 'mezzogiorno',
    morning: 'di mattina',
    afternoon: 'del pomeriggio',
    evening: 'di sera',
    night: 'di notte'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'mezzanotte',
    noon: 'mezzogiorno',
    morning: 'di mattina',
    afternoon: 'del pomeriggio',
    evening: 'di sera',
    night: 'di notte'
  },
  wide: {
    am: 'AM',
    pm: 'PM',
    midnight: 'mezzanotte',
    noon: 'mezzogiorno',
    morning: 'di mattina',
    afternoon: 'del pomeriggio',
    evening: 'di sera',
    night: 'di notte'
  }
};

function ordinalNumber(dirtyNumber) {
  var number = Number(dirtyNumber);
  return number + 'º';
}

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const _lib_localize = (localize);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/it/_lib/match/index.js


var matchOrdinalNumberPattern = /^(\d+)(º)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(aC|dC)/i,
  abbreviated: /^(a\.?\s?C\.?|a\.?\s?e\.?\s?v\.?|d\.?\s?C\.?|e\.?\s?v\.?)/i,
  wide: /^(avanti Cristo|avanti Era Volgare|dopo Cristo|Era Volgare)/i
};
var parseEraPatterns = {
  any: [/^a/i, /^(d|e)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^t[1234]/i,
  wide: /^[1234](º)? trimestre/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[gfmalsond]/i,
  abbreviated: /^(gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)/i,
  wide: /^(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)/i
};
var parseMonthPatterns = {
  narrow: [/^g/i, /^f/i, /^m/i, /^a/i, /^m/i, /^g/i, /^l/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ge/i, /^f/i, /^mar/i, /^ap/i, /^mag/i, /^gi/i, /^l/i, /^ag/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[dlmgvs]/i,
  short: /^(do|lu|ma|me|gi|ve|sa)/i,
  abbreviated: /^(dom|lun|mar|mer|gio|ven|sab)/i,
  wide: /^(domenica|luned[i|ì]|marted[i|ì]|mercoled[i|ì]|gioved[i|ì]|venerd[i|ì]|sabato)/i
};
var parseDayPatterns = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^g/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^g/i, /^v/i, /^s/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|m\.|p|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
  any: /^([ap]\.?\s?m\.?|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mezza/i,
    noon: /^mezzo/i,
    morning: /mattina/i,
    afternoon: /pomeriggio/i,
    evening: /sera/i,
    night: /notte/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const _lib_match = (match);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/it/index.js





/**
 * @type {Locale}
 * @category Locales
 * @summary Italian locale.
 * @language Italian
 * @iso-639-2 ita
 * @author Alberto Restifo [@albertorestifo]{@link https://github.com/albertorestifo}
 * @author Giovanni Polimeni [@giofilo]{@link https://github.com/giofilo}
 * @author Vincenzo Carrese [@vin-car]{@link https://github.com/vin-car}
 */

var locale = {
  code: 'it',
  formatDistance: formatDistance,
  formatLong: _lib_formatLong,
  formatRelative: formatRelative,
  localize: _lib_localize,
  match: _lib_match,
  options: {
    weekStartsOn: 1
    /* Monday */
    ,
    firstWeekContainsDate: 4
  }
};
/* harmony default export */ const it = (locale);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistance_formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance_formatDistance = function (token, count, options) {
  var result;
  var tokenValue = formatDistance_formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

/* harmony default export */ const _lib_formatDistance = (formatDistance_formatDistance);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js

var formatLong_dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var formatLong_timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var formatLong_dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong_formatLong = {
  date: buildFormatLongFn({
    formats: formatLong_dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: formatLong_timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: formatLong_dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const en_US_lib_formatLong = (formatLong_formatLong);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelative_formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative_formatRelative = function (token, _date, _baseDate, _options) {
  return formatRelative_formatRelativeLocale[token];
};

/* harmony default export */ const _lib_formatRelative = (formatRelative_formatRelative);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js

var localize_eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var localize_quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var localize_monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var localize_dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var localize_dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var localize_formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var localize_ordinalNumber = function (dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize_localize = {
  ordinalNumber: localize_ordinalNumber,
  era: buildLocalizeFn({
    values: localize_eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: localize_quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: localize_monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: localize_dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: localize_dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: localize_formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const en_US_lib_localize = (localize_localize);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js


var match_matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var match_parseOrdinalNumberPattern = /\d+/i;
var match_matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var match_parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var match_matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var match_parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var match_matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var match_parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var match_matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var match_parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var match_matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var match_parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match_match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: match_matchOrdinalNumberPattern,
    parsePattern: match_parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: match_matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: match_parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: match_matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: match_parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: match_matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: match_parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: match_matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: match_parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: match_matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: match_parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const en_US_lib_match = (match_match);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/index.js






/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var en_US_locale = {
  code: 'en-US',
  formatDistance: _lib_formatDistance,
  formatLong: en_US_lib_formatLong,
  formatRelative: _lib_formatRelative,
  localize: en_US_lib_localize,
  match: en_US_lib_match,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
/* harmony default export */ const en_US = (en_US_locale);
;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Pages/GeoPlotPage.js









/****************************************/
class IndicatorViewModel {
    select() {
    }
    indicator;
    value = ko.observable();
}
/****************************************/
class AreaViewModel {
    select() {
    }
    /****************************************/
    value;
    data = ko.observable();
    factor = ko.observable();
    indicator = ko.observable();
    reference = ko.observable();
    indicators = ko.observable();
}
/****************************************/
class GeoPlotPage {
    _mainData;
    _mainGeo;
    _detailsData;
    _detailsGeo;
    _selectedArea;
    ù;
    _chart;
    _daysData;
    _topAreasVisible = false;
    _mapSvg;
    _execludedArea = new Map();
    _dataSet = InfectionDataSet;
    _keepState = false;
    _debugMode = false;
    _preferences;
    _calculator;
    _tips = {
        areaSelected: {
            order: 0,
            featureName: "Zone",
            html: "Puoi vedere i dati relativi ad una particolare area selezionadoli sulla mappa.",
            elementSelector: ".card-map .center-align",
            showAfter: 3,
            showAction: () => {
                this.viewMode("region");
                this.selectedArea = this._calculator.geo.areas["r10"];
            }
        },
        indicatorSelected: {
            order: 1,
            featureName: "Indicatori",
            html: "Puoi vedere il grafico associato all'indicatore, facendo click sull'indicatore.",
            elementSelector: ".indicators .summary-field",
            showAfter: 15,
            showAction: () => {
                if (!this.currentArea())
                    this._tips.areaSelected.showAction();
                this.selectedIndicator((0,Linq/* linq */.k)(this._dataSet.indicators).first(a => a.id == "totalDeath"));
            }
        },
        dayChanged: {
            order: 2,
            featureName: "Cronologia",
            html: "Puoi vedere gli indicatori dei giorni precedenti muovendo la slide.",
            elementSelector: ".day input[type=range]",
            showAfter: 20,
            showAction: () => {
                this.dayNumber(5);
            }
        },
        indicatorChanged: {
            order: 3,
            featureName: "Indicatori",
            html: "Puoi cambiare l'indicatore scegliendolo dal filtro nell'elenco.",
            elementSelector: ".filter-indicator",
            showAfter: 0
        },
        viewChanged: {
            order: 4,
            featureName: "Zone",
            html: "Puoi vedere gli indicatori a livello regionale, nazionale o provinciale.",
            elementSelector: "#areaTabs",
            showAfter: 0,
            showAction: () => {
                this.viewMode("district");
            }
        },
        topAreasOpened: {
            order: 5,
            featureName: "Zone",
            html: "Puo vedere le zone più colpite di un qualsiasi indicatore scelto.",
            elementSelector: "#topCases .card-title",
            showAfter: 20,
            showAction: () => {
                if (this.viewMode() == "country")
                    this.viewMode("region");
                M.Collapsible.getInstance(document.getElementById("topCases")).open(0);
            }
        },
        deltaSelected: {
            order: 5.5,
            featureName: "Indicatori",
            html: "Puoi vedere l'incremento giornaliero dell'indicatore anzichè il valore totale.",
            elementSelector: ".day-delta",
            showAfter: 20,
            showAction: () => {
                if (!this.currentArea())
                    this._tips.areaSelected.showAction();
                this.isDayDelta(true);
            }
        },
        factorChanged: {
            order: 6,
            featureName: "Indicatori",
            html: "Puoi mettere in relazione qualsiasi indicatore a numerosi parametri (es. % Positivi su Tamponi).",
            elementSelector: ".filter-factor",
            showAfter: 30,
            showAction: () => {
                if (!this.currentArea())
                    this._tips.areaSelected.showAction();
                this.selectedIndicator((0,Linq/* linq */.k)(this._dataSet.indicators).first(a => a.id == "totalPositive"));
                this.selectedFactor((0,Linq/* linq */.k)(this._dataSet.factors).first(a => a.id == "population"));
            }
        },
        groupChanged: {
            order: 7,
            featureName: "Grafico",
            html: "Puo raggruppare i dati del grafico in gruppi da 1 a 7 giorni. Puoi anche scegliere la data d'inizio.",
            elementSelector: ".row-chart-group .select-wrapper",
            showAfter: 30,
            showAction: () => {
                if (!this.currentArea())
                    this._tips.areaSelected.showAction();
                var element = document.querySelector(".chart-options");
                if (element.classList.contains("closed"))
                    element.classList.remove("closed");
                this.groupSize(2);
                M.FormSelect.init(document.querySelectorAll(".row-chart-group select"));
            }
        },
        chartActionExecuted: {
            order: 8,
            featureName: "Grafico",
            html: "Puoi portare il grafico a schermo interno, copiarlo, o copiare la serie numerico e incollarla in excel.",
            elementSelector: ".chart .actions",
            showAfter: 30
        },
        scaleChanged: {
            order: 9,
            featureName: "Grafico",
            html: "Puoi cambiare da scala logaritmica a scala lineare.",
            elementSelector: ".log-scale",
            showAfter: 210,
            showAction: () => {
                this.isLogScale(true);
            }
        },
        maxFactorChanged: {
            order: 10,
            featureName: "Mappa",
            html: "Puoi cambiare il riferimento rispetto al quale la mappa viene colorata. Normalmente è in base al valore massimo che si ha avuto globalmente.",
            elementSelector: ".max-factor",
            showAfter: 60,
            showAction: () => {
                if (!this.currentArea())
                    this._tips.areaSelected.showAction();
                this.selectedIndicator((0,Linq/* linq */.k)(this._dataSet.indicators).first(a => a.id == "totalPositive"));
                this.autoMaxFactor(false);
                this.maxFactor(1000);
            }
        },
        regionExcluded: {
            order: 11,
            featureName: "Mappa",
            html: "Nella vista nazionale puoi escludere dagli indicatori il valore di una o più regioni cliccando sulla mappa.",
            elementSelector: ".card-map .center-align",
            showAfter: 0,
            showAction: () => {
                if (this.viewMode() != "country")
                    this.viewMode("country");
                this._execludedArea.set("R8", this._calculator.geo.areas["r8"]);
                this.updateIndicator();
            }
        }
    };
    _specialDates = {
        current: {
            date: undefined,
            color: "#000",
            width: 0.5,
            label: "Giorno corrente"
        },
        "dpcm8": {
            date: new Date(2020, 2, 7),
            color: "#000",
            dash: [5, 5],
            width: 1,
            visible: true,
            label: "DPCM 8 Marzo (italia zona rossa)"
        },
        "dpcm9": {
            date: new Date(2020, 2, 9),
            color: "#000",
            dash: [5, 5],
            width: 1,
            visible: true,
            label: "DPCM 9 Marzo (italia zona rossa)"
        },
        "dpcm11": {
            date: new Date(2020, 2, 11),
            color: "#000",
            dash: [5, 5],
            width: 1,
            visible: true,
            label: "DPCM 11 Marzo (chiusura attività)"
        },
        "mds20": {
            date: new Date(2020, 2, 20),
            color: "#070",
            dash: [5, 5],
            width: 1,
            visible: false,
            label: "MDS 20 Marzo (chiura parchi, motoria nelle vicinane)"
        },
        "dpcm22": {
            date: new Date(2020, 2, 21),
            color: "#000",
            dash: [5, 5],
            width: 1,
            visible: true,
            label: "DPCM 22 Marzo (chiusura ulteriore attività)"
        },
        "dpcm25": {
            date: new Date(2020, 2, 24),
            color: "#000",
            dash: [5, 5],
            width: 1,
            visible: true,
            label: "DPCM 25 Marzo (maggiori sanzioni)"
        }
    };
    _dataRanges = [
        {
            id: 0,
            name: "$(all)",
        },
        {
            id: 1,
            name: "1° $(wave)",
            endDay: new Date(2020, 7, 31)
        },
        {
            id: 2,
            name: "2° $(wave)",
            startDay: new Date(2020, 8, 1)
        },
        {
            id: 3,
            name: "3° $(wave)",
            startDay: new Date(2021, 5, 23)
        },
    ];
    constructor(model) {
        this._mainData = new RangeDayAreaDataSet(model.data);
        this._mainGeo = model.geo;
        this._debugMode = model.debugMode;
        this._calculator = new IndicatorCalculator(this._mainData, this._dataSet, this._mainGeo);
        this.dataRange.subscribe(value => {
            const findDayIndex = (date) => {
                return this._mainData.days.indexOf(a => parseDate(a.date).getTime() >= date.getTime());
            };
            this._mainData.startDay = undefined;
            this._mainData.endDay = undefined;
            this._mainData.startDay = value.startDay ? findDayIndex(value.startDay) : undefined;
            this._mainData.endDay = value.endDay ? findDayIndex(value.endDay) : undefined;
            this.updateDays();
            this.dayNumber(this._mainData.count - 1);
        });
        this.dayNumber.subscribe(value => {
            if (value != this._calculator.data.count - 1)
                this.tipManager.markAction("dayChanged");
            this.updateDayData();
            this._specialDates.current.date = new Date(this._calculator.data.get(value).date);
            this.updateChart();
        });
        this._mapSvg = document.getElementsByTagName("svg").item(0);
        this._mapSvg.addEventListener("click", e => this.onMapClick(e, false));
        this._mapSvg.addEventListener("dblclick", e => this.onMapClick(e, true));
        this.updateDays();
        const areaTabs = M.Tabs.init(document.getElementById("areaTabs"));
        areaTabs.options.onShow = (el) => {
            this.setViewMode(el.dataset["viewMode"]);
        };
        const topCasesView = M.Collapsible.init(document.getElementById("topCases"));
        topCasesView.options.onOpenStart = () => {
            if (!this._daysData)
                this.updateTopAreas();
            this._topAreasVisible = true;
            this.tipManager.markAction("topAreasOpened");
        };
        topCasesView.options.onCloseEnd = () => {
            this._topAreasVisible = false;
        };
        this.indicators = ko.computed(() => (0,Linq/* linq */.k)(this._dataSet.indicators)
            .where(a => !a.validFor || a.validFor.indexOf(this.viewMode()) != -1)
            .toArray());
        this.factors = ko.computed(() => (0,Linq/* linq */.k)(this._dataSet.factors)
            .where(a => !a.validFor || a.validFor.indexOf(this.viewMode()) != -1)
            .toArray());
        this.detailsArea.subscribe(value => {
            this.updateDetailsArea();
        });
        this.selectedIndicator.subscribe(value => {
            if (!value)
                return;
            this.updateIndicator();
            if (value.id != "totalPositive")
                this.tipManager.markAction("indicatorChanged", value.id);
        });
        this.selectedFactor.subscribe(value => {
            if (!value)
                return;
            this.updateIndicator();
            if (value.id != "none")
                this.tipManager.markAction("factorChanged", value.id);
            setTimeout(() => M.FormSelect.init(document.querySelectorAll(".row-chart-group select")));
        });
        this.autoMaxFactor.subscribe(value => {
            if (value) {
                this.updateMaxFactor();
                this.updateMap();
            }
            this.updateUrl();
        });
        this.maxFactor.subscribe(value => {
            if (!this.autoMaxFactor()) {
                this.updateMap();
                this.tipManager.markAction("maxFactorChanged", value.toString());
            }
            this.updateUrl();
        });
        this.baseFactor.subscribe(value => {
            if (!this.autoMaxFactor()) {
                this.updateMap();
            }
            this.updateUrl();
        });
        this.isDayDelta.subscribe(value => {
            this.computeStartDayForGroup();
            this.updateIndicator();
            if (value)
                this.tipManager.markAction("deltaSelected");
        });
        this.isAvg.subscribe(value => {
            this.computeStartDayForGroup();
            this.updateIndicator();
            this.updateUrl();
        });
        this.isLogScale.subscribe(value => {
            this.updateChart();
            this.updateUrl();
            if (value)
                this.tipManager.markAction("scaleChanged");
        });
        this.isZoomChart.subscribe(value => {
            this.updateChart();
        });
        this.groupSize.subscribe(value => {
            this.computeStartDayForGroup();
            this.updateChart();
            this.updateUrl();
            if (value > 1)
                this.tipManager.markAction("groupChanged", value.toString());
        });
        this.startDay.subscribe(value => {
            this.updateChart();
            this.updateUrl();
        });
        const urlParams = new URLSearchParams(window.location.search);
        const stateRaw = urlParams.get("state");
        this._keepState = urlParams.get("keepState") == "true";
        this.loadPreferences();
        this.tipManager = new TipManager(this._tips, () => this._preferences, () => this.savePreferences());
        this.tipManager.engageUser();
        let state;
        if (stateRaw && this._keepState)
            state = JSON.parse(atob(stateRaw));
        else
            state = {};
        setTimeout(() => this.loadState(state), 0);
        if (!this._debugMode)
            window.addEventListener("beforeunload", () => this.savePreferences());
        //Templating.template(document.querySelector("#template"), "TestComponent", Templating.model({ isChecked: false }));
    }
    /****************************************/
    isDefaultState(state) {
        return (!state.day || state.day == this._calculator.data.count - 1) &&
            (!state.view || state.view == "region") &&
            !state.area &&
            (!state.indicator || state.indicator == "totalPositive") &&
            (!state.factor || state.factor == "none") &&
            !state.maxFactor &&
            !state.dayDelta &&
            !state.logScale &&
            !state.showEnvData &&
            state.dateRangeId == 0,
            (!state.groupSize || state.groupSize == 1) &&
                (state.startDay == undefined || state.startDay == 0) &&
                (!state.excludedArea) &&
                (!state.detailsArea);
    }
    /****************************************/
    loadState(state) {
        if (!state.view)
            state.view = "region";
        const viewTabs = M.Tabs.getInstance(document.getElementById("areaTabs"));
        viewTabs.select(ViewModes[state.view].tab);
        document.body.scrollTop = 0;
        if (!state.dateRangeId)
            this.dataRange(this.dataRanges[0]);
        else
            this.dataRange((0,Linq/* linq */.k)(this.dataRanges).first(a => a.id == state.dateRangeId));
        if (state.logScale != undefined)
            this.isLogScale(state.logScale);
        if (state.groupSize)
            this.groupSize(state.groupSize);
        if (state.startDay != undefined)
            this.startDay(state.startDay);
        if (state.dayDelta != undefined)
            this.isDayDelta(state.dayDelta);
        if (state.showEnvData != undefined)
            this.isShowEnvData(state.showEnvData);
        if (state.maxFactor) {
            this.autoMaxFactor(false);
            this.maxFactor(state.maxFactor);
        }
        this.dayNumber(state.day != undefined ? state.day : this._calculator.data.count - 1);
        if (state.excludedArea) {
            this._execludedArea.clear();
            for (let areaId of state.excludedArea)
                this._execludedArea.set(areaId, this._calculator.geo.areas[areaId.toLowerCase()]);
        }
        if (state.indicator)
            this.selectedIndicator((0,Linq/* linq */.k)(this._dataSet.indicators).first(a => a.id == state.indicator));
        if (state.factor)
            this.selectedFactor((0,Linq/* linq */.k)(this._dataSet.factors).first(a => a.id == state.factor));
        if (state.area)
            this.selectedArea = this._calculator.geo.areas[state.area.toLowerCase()];
        if (state.detailsArea)
            this.detailsArea(this._calculator.geo.areas[state.detailsArea]);
    }
    /****************************************/
    saveStata() {
        return {
            view: this.viewMode() == "region" ? undefined : this.viewMode(),
            indicator: this.selectedIndicator() ? this.selectedIndicator().id : undefined,
            factor: this.selectedFactor() ? this.selectedFactor().id : undefined,
            dayDelta: this.isDayDelta() ? true : undefined,
            maxFactor: this.autoMaxFactor() ? undefined : this.maxFactor(),
            day: this.dayNumber() == this._calculator.data.count - 1 ? undefined : this.dayNumber(),
            area: this.selectedArea ? this.selectedArea.id : undefined,
            groupSize: this.groupSize() == 1 ? undefined : this.groupSize(),
            startDay: this.startDay() == 0 ? undefined : this.startDay(),
            logScale: this.isLogScale() ? true : undefined,
            excludedArea: this._execludedArea.size > 0 ? (0,Linq/* linq */.k)(this._execludedArea.keys()).toArray() : undefined,
            showEnvData: this.isShowEnvData() ? true : undefined,
            detailsArea: this.detailsArea() ? this.detailsArea().id : undefined,
            dateRangeId: this.dataRange().id
        };
    }
    /****************************************/
    loadPreferences() {
        let json = localStorage.getItem("preferences");
        if (json) {
            try {
                this._preferences = JSON.parse(json);
            }
            catch {
            }
            if (!this._preferences || this._preferences.version != 1) {
                this._preferences = this.getDefaultPreferences();
                this._preferences.isFirstView = false;
                this._preferences.showTips = false;
                this.savePreferences();
            }
        }
        else
            this._preferences = this.getDefaultPreferences();
    }
    /****************************************/
    getDefaultPreferences() {
        return ({
            isFirstView: true,
            showTips: true,
            version: 1,
            actions: {
                areaSelected: 0,
                indicatorSelected: 0,
                indicatorChanged: 0,
                dayChanged: 0,
                viewChanged: 0,
                chartActionExecuted: 0,
                factorChanged: 0,
                groupChanged: 0,
                maxFactorChanged: 0,
                scaleChanged: 0,
                topAreasOpened: 0,
                deltaSelected: 0,
                regionExcluded: 0
            }
        });
    }
    /****************************************/
    savePreferences() {
        this._preferences.isFirstView = false;
        localStorage.setItem("preferences", JSON.stringify(this._preferences));
    }
    /****************************************/
    toggleChartZoom() {
        this._preferences.actions.chartActionExecuted++;
        this.isZoomChart(!this.isZoomChart());
    }
    /****************************************/
    async copyMap() {
        const element = document.querySelector("svg.map");
        const svgText = element.outerHTML;
        const blob = new Blob([svgText], { type: "image/svg+xml" });
        if (navigator["clipboard"] && navigator["clipboard"]["write"]) {
            const svgImage = document.createElement('img');
            svgImage.style.width = element.clientWidth + "px";
            svgImage.style.height = element.clientHeight + "px";
            svgImage.onload = function () {
                const canvas = document.createElement("canvas");
                canvas.width = element.clientWidth;
                canvas.height = element.clientHeight;
                const ctx = canvas.getContext("2d");
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(svgImage, 0, 0);
                canvas.toBlob(async (pngBlob) => {
                    let item = new ClipboardItem({ [pngBlob.type]: pngBlob });
                    await navigator.clipboard.write([item]);
                    M.toast({ html: $string("$(msg-map-copied)") });
                });
            };
            svgImage.src = window.URL.createObjectURL(blob);
        }
        else {
            const element = document.createElement("a");
            element.href = window.URL.createObjectURL(blob);
            element.target = "_blan";
            element.download = "map.svg";
            element.click();
            M.toast({ html: $string("$(msg-no-copy)") });
        }
    }
    /****************************************/
    copyChart() {
        this._chart.canvas.toBlob(async (blob) => {
            if (navigator["clipboard"] && navigator["clipboard"]["write"]) {
                let item = new ClipboardItem({ [blob.type]: blob });
                await navigator.clipboard.write([item]);
                M.toast({ html: $string("$(msg-chart-copied)") });
            }
            else {
                const url = window.URL.createObjectURL(blob);
                const element = document.createElement("a");
                element.href = url;
                element.target = "_blan";
                element.download = this._chart.options.plugins.title.text + ".png";
                element.click();
                M.toast({ html: $string("$(msg-no-copy)") });
            }
        });
        this.tipManager.markAction("chartActionExecuted", "copy");
    }
    /****************************************/
    async copySerie() {
        const data = this._chart.data.datasets[0].data;
        let text = "";
        for (let i = 0; i < data.length; i++) {
            if (i > 0)
                text += "\n";
            text += formatDate(data[i].x, $string("$(date-format)")) + "\t" + i + "\t" + round(data[i].y, 1);
        }
        copyText(text);
        M.toast({ html: $string("$(msg-serie-copied)") });
        this.tipManager.markAction("chartActionExecuted", "copySerie");
    }
    /****************************************/
    async copySerieForStudio() {
        let obj = {
            type: "serie",
            version: 1,
            color: this.selectedIndicator().colorLight,
            serie: {
                type: "geoplot",
                areaId: this.selectedArea.id,
                indicatorId: this.selectedIndicator().id,
                xAxis: "dayNumber",
                exeludedAreaIds: (0,Linq/* linq */.k)(this._execludedArea.keys()).toArray(),
                factorId: this.selectedFactor().id,
                groupSize: this.groupSize(),
                isDelta: this.isDayDelta(),
                startDay: this.startDay(),
                range: {
                    start: this._calculator.data.startDay,
                    end: this._calculator.data.endDay,
                }
            },
            title: this.factorDescription()
        };
        obj.values = this._calculator.getSerie(obj.serie);
        copyText(JSON.stringify(obj));
        M.toast({ html: $string("$(msg-serie-copied-studio)") });
        this.tipManager.markAction("chartActionExecuted", "copySerieForStudio");
    }
    /****************************************/
    play() {
        if (this.dayNumber() == this._calculator.data.count - 1)
            this.dayNumber(0);
        this.isPlaying(true);
        this.nextFrame();
    }
    /****************************************/
    pause() {
        this.isPlaying(false);
    }
    /****************************************/
    setViewMode(mode, fromModel = false) {
        if (fromModel) {
            const areaTabs = M.Tabs.getInstance(document.getElementById("areaTabs"));
            areaTabs.select(ViewModes[mode].tab);
        }
        if (mode == "details") {
            if (this._detailsGeo && this._detailsData) {
                this._calculator.geo = this._detailsGeo;
                this._calculator.data = this._detailsData;
            }
        }
        else {
            this._calculator.geo = this._mainGeo;
            this._calculator.data = this._mainData;
        }
        this.totalDays(this._calculator.data.count - 1);
        if (mode != "region")
            this.tipManager.markAction("viewChanged", mode);
        this.viewMode(mode);
        const districtGroup = document.getElementById("group_district");
        if (mode == "district" || mode == "details")
            districtGroup.style.removeProperty("display");
        else
            districtGroup.style.display = "none";
        this.selectedArea = null;
        this._chart = null;
        this._execludedArea.clear();
        this.clearMap();
        this.updateMaxFactor();
        this.updateDayData();
        if (this.viewMode() == "country") {
            this.selectedArea = this._calculator.geo.areas["it"];
            this.tipManager.showTip("regionExcluded", { timeout: 5 });
        }
        else {
            if (this._topAreasVisible)
                this.updateTopAreas();
            else
                this._daysData = undefined;
        }
        setTimeout(() => M.FormSelect.init(document.querySelectorAll(".row-indicator select")));
    }
    /****************************************/
    get selectedArea() {
        return this._selectedArea;
    }
    set selectedArea(value) {
        if (value == this._selectedArea)
            return;
        if (this._selectedArea) {
            const element = document.getElementById(this._selectedArea.id.toUpperCase());
            if (element)
                element.classList.remove("selected");
        }
        this._selectedArea = value;
        if (this._selectedArea) {
            const element = document.getElementById(this._selectedArea.id.toUpperCase());
            if (element) {
                element.classList.add("selected");
                const parent = element.parentElement;
                element.remove();
                parent.appendChild(element);
            }
        }
        this.changeArea();
    }
    /****************************************/
    getFactorValue(dayNumberOrGroup, areaOrId) {
        return this._calculator.getFactorValue({
            dayNumberOrGroup: dayNumberOrGroup,
            areaOrId: areaOrId,
            factorId: this.selectedFactor().id,
            indicatorId: this.selectedIndicator().id,
            isDayDelta: this.isDayDelta(),
            isAvg: this.isAvg(),
            execludedAreas: (0,Linq/* linq */.k)(this._execludedArea.keys()).toArray()
        });
    }
    /****************************************/
    getIndicatorValue(dayNumber, areaOrId, indicatorId) {
        return this._calculator.getIndicatorValue({
            dayNumber: dayNumber,
            areaOrId: areaOrId,
            indicatorId: indicatorId,
            isDayDelta: this.isDayDelta(),
            execludedAreas: (0,Linq/* linq */.k)(this._execludedArea.keys()).toArray()
        });
    }
    /****************************************/
    computeStartDayForGroup() {
        let totDays = this._calculator.data.count - this.startDay();
        const module = (totDays % this.groupSize());
        if (module != 0) {
            const invModule = this.groupSize() - module;
            if (this.startDay() - invModule >= 0)
                this.startDay(this.startDay() - invModule);
            else if (this.startDay() + module < this._calculator.data.count - 1)
                this.startDay(this.startDay() + module);
            M.FormSelect.init(document.querySelectorAll(".row-chart-group select"));
        }
    }
    /****************************************/
    onMapClick(e, isDouble) {
        const item = e.target;
        const areaId = item.parentElement.id;
        const area = this._calculator.geo.areas[areaId.toLowerCase()];
        if (!area)
            return;
        if (!isDouble) {
            if (this.viewMode() == "country") {
                if (this._execludedArea.has(areaId))
                    this._execludedArea.delete(areaId);
                else {
                    this._execludedArea.set(areaId, area);
                    M.toast({ html: $string("$(msg-region-ex)").replace("[region]", area.name) });
                }
                this.updateIndicator();
            }
            else {
                //if (item.parentElement.classList.contains(this.viewMode()))
                this.selectedArea = area;
            }
            this.tipManager.markAction("areaSelected", area.name);
        }
        else {
            if (this.viewMode() == "region" || this.viewMode() == "district")
                this.detailsArea(area);
        }
    }
    /****************************************/ top;
    nextFrame() {
        if (!this.isPlaying())
            return;
        if (this.dayNumber() >= this._calculator.data.count - 1)
            this.pause();
        else
            this.dayNumber(parseInt(this.dayNumber().toString()) + 1);
        setTimeout(() => this.nextFrame(), 200);
    }
    /****************************************/
    changeArea() {
        if (this._selectedArea == null)
            this.currentArea(null);
        else {
            var isEmptyArea = !this.currentArea();
            const area = new AreaViewModel();
            area.value = this._selectedArea;
            this.updateArea(area);
            this.currentArea(area);
            this.updateFactorDescription();
            this.updateAreaIndicators();
            this.updateChart();
            if (isEmptyArea) {
                M.FormSelect.init(document.querySelectorAll(".row-chart-group select"));
                M.Tooltip.init(document.querySelectorAll(".row-chart-group .tooltipped"));
            }
        }
        this.updateUrl();
    }
    /****************************************/
    updateAreaIndicators() {
        if (!this.currentArea())
            return;
        if (!this.currentArea().indicators()) {
            const items = [];
            for (let indicator of this.indicators()) {
                if (indicator.showInFavorites === false)
                    continue;
                let item = new IndicatorViewModel();
                item.indicator = indicator;
                item.select = () => {
                    this.tipManager.markAction("indicatorSelected", item.indicator.id);
                    this.selectedIndicator(indicator);
                    setTimeout(() => M.FormSelect.init(document.querySelectorAll(".row-indicator select")));
                };
                items.push(item);
            }
            this.currentArea().indicators(items);
        }
        const areaId = this.currentArea().value.id.toLowerCase();
        for (let item of this.currentArea().indicators())
            item.value(this.getIndicatorValue(this.dayNumber(), areaId, item.indicator.id));
    }
    /****************************************/
    updateFactorDescription() {
        let desc = "";
        if (this.isDayDelta())
            desc = "$(new) ";
        desc += this.selectedFactor().description.replace("[indicator]", this.selectedIndicator().name);
        if (this.currentArea())
            desc += " - " + this.currentArea().value.name;
        if (this._execludedArea.size > 0) {
            desc += " - $(except) (";
            let i = 0;
            for (let key of this._execludedArea.keys()) {
                if (i > 0)
                    desc += ", ";
                desc += this._execludedArea.get(key).name;
                i++;
            }
            desc += ")";
        }
        this.factorDescription($string(desc));
    }
    /****************************************/
    updateIndicator() {
        if (!this.selectedIndicator() || !this.selectedFactor())
            return;
        this.updateFactorDescription();
        /*
        if (this.selectedFactor().id != "none") {
 
            if (this.groupSize() != 1)
                this.groupSize(1);
        }*/
        this.updateMaxFactor();
        this.updateDayData();
        this.updateChart();
        this.updateUrl();
        if (this._topAreasVisible)
            this.updateTopAreas();
    }
    /****************************************/
    updateMaxFactor() {
        if (!this.selectedFactor() || !this.selectedIndicator() || !this.autoMaxFactor())
            return;
        let result = Number.NEGATIVE_INFINITY;
        let curView = ViewModes[this.viewMode()];
        let count = 0;
        let list = [];
        this._calculator.data.days.foreach((day, i) => {
            for (let areaId in day.values) {
                if (!curView.validateId(areaId))
                    continue;
                if (!this._calculator.geo.areas[areaId])
                    continue;
                const factor = Math.abs(this.getFactorValue(i, areaId));
                if (!isNaNOrNull(factor) && factor != Number.POSITIVE_INFINITY && factor > result)
                    result = factor;
                if (factor != 0)
                    list.push(factor);
            }
        });
        /*
        list = linq(list).orderBy(a => a).toArray();
        var index = Math.floor(list.length / 2);
        result = list[index];*/
        this.maxFactor(parseFloat(result.toFixed(1)));
    }
    /****************************************/
    initChart() {
        const canvas = document.querySelector("#areaGraph");
        const referencesPlugIn = {
            id: "lines",
            afterDraw: chart => {
                const data = chart.data.datasets[0].data;
                if (!data || data.length == 0)
                    return;
                const xScale = chart.scales.xAxes;
                const ctx = chart.ctx;
                for (let key in this._specialDates) {
                    let item = this._specialDates[key];
                    if (!item.date || item.visible === false)
                        continue;
                    let offset = xScale.getPixelForValue(item.date.getTime());
                    ctx.lineWidth = item.width || 1;
                    ctx.beginPath();
                    ctx.moveTo(offset, chart.chartArea.top);
                    ctx.lineTo(offset, chart.chartArea.bottom);
                    ctx.strokeStyle = item.color || "#000";
                    if (item.dash)
                        ctx.setLineDash(item.dash);
                    else
                        ctx.setLineDash([]);
                    if (item.dashOffset)
                        ctx.lineDashOffset = item.dashOffset;
                    ctx.stroke();
                }
            }
        };
        const bkPlugin = {
            id: "bk",
            beforeDraw: function (chart, args, options) {
                var ctx = chart.ctx;
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, chart.width, chart.height);
            }
        };
        this._chart = new external_Chart_.Chart(canvas, {
            plugins: [bkPlugin, referencesPlugIn],
            type: "line",
            data: {
                datasets: [
                    {
                        fill: "origin",
                        data: [],
                        borderWidth: 1
                    }
                ]
            },
            options: {
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: false
                    },
                    legend: {
                        display: true,
                        position: "bottom"
                    },
                    tooltip: {
                        callbacks: {
                            label: item => {
                                return round(item.parsed.y, 1);
                            }
                        }
                    }
                },
                scales: {
                    xAxes: {
                        type: "time",
                        adapters: {
                            date: {
                                locale: $language == "it-IT" ? it : en_US,
                            }
                        },
                        time: {
                            unit: "day",
                            tooltipFormat: "dd/MMM"
                        }
                    },
                }
            }
        });
    }
    /****************************************/
    updateDays() {
        const days = [];
        this._calculator.data.days.foreach((day, i) => days.push({ number: i, value: new Date(day.date), text: formatDate(day.date, $string("$(date-format-short)")) }));
        this.days(days);
        this.totalDays(this._calculator.data.count - 1);
    }
    /****************************************/
    updateChart() {
        if (!this.selectedIndicator() || !this.currentArea() || !this.selectedFactor())
            return;
        if (this._chart == null)
            this.initChart();
        const area = this.currentArea().value;
        this._chart.data.datasets[0].label = this.factorDescription();
        this._chart.options.plugins.title.text = this._chart.data.datasets[0].label;
        if (this.isLogScale())
            this._chart.options.scales.y.type = "logarithmic";
        else
            this._chart.options.scales.y.type = "linear";
        this._chart.options.scales.y.min = 0;
        this._chart.data.datasets[0].borderColor = this.selectedIndicator().colorDark;
        this._chart.data.datasets[0].backgroundColor = this.selectedIndicator().colorLight;
        const data = this._calculator.getSerie({
            type: "geoplot",
            areaId: area.id,
            indicatorId: this.selectedIndicator().id,
            xAxis: "date",
            startDay: this.startDay(),
            exeludedAreaIds: (0,Linq/* linq */.k)(this._execludedArea.keys()).toArray(),
            factorId: this.selectedFactor().id,
            groupSize: this.groupSize(),
            isDelta: this.isDayDelta(),
            isAvg: this.isAvg()
        });
        const orderedData = (0,Linq/* linq */.k)(data).select(a => a.y).where(a => !isNaN(a)).orderBy(a => a).toArray();
        this._chart.options.scales.y.min = orderedData[0] * 1.1;
        this._chart.options.scales.y.max = orderedData[orderedData.length - 1] * 1.1;
        this._chart.data.datasets[0].data = data;
        this._chart.update();
    }
    /****************************************/
    updateArea(value, dayNumber) {
        if (!value || !this.selectedIndicator() || !this.selectedFactor())
            return;
        if (dayNumber == undefined)
            dayNumber = parseInt(this.dayNumber());
        const id = value.value.id.toLowerCase();
        const area = value.value;
        /*
        if (!day || !day.values[id]) {
            M.toast({
                html: $string("$(msg-no-data)")});
            return;
        }*/
        value.data(this._calculator.getDataAtDay(dayNumber, id));
        value.indicator(this.getIndicatorValue(dayNumber, id, this.selectedIndicator().id));
        value.factor(this.getFactorValue(dayNumber, area));
        value.reference(this.selectedFactor().reference(value.data(), area));
    }
    /****************************************/
    async updateDetailsArea() {
        const detailsEl = document.querySelector(".details-map");
        if (!this.detailsArea()) {
            this.setViewMode("region");
            detailsEl.innerHTML = "";
        }
        else {
            await this.detailsLoading.waitFor();
            this.detailsLoading.reset();
            try {
                this.setViewMode("details", true);
                await (0,PromiseUtils/* delayAsync */.$)(0);
                detailsEl.innerHTML = "<span class = 'loading'><i class ='material-icons'>loop</i></span>";
                document.getSelection().empty();
                const mainData = JSON.parse(await (await fetch(Global/* App.baseUrl */.gV.baseUrl + "AreaData/" + this.detailsArea().id)).text());
                const mapData = await (await fetch(Global/* App.baseUrl */.gV.baseUrl + "AreaMap/" + this.detailsArea().id)).text();
                detailsEl.innerHTML = mapData;
                var svgMap = document.querySelector(".details-map svg");
                svgMap.addEventListener("click", e => this.onMapClick(e, false));
                svgMap.querySelector("#group_municipality").classList.add("active");
                this._detailsData = new RangeDayAreaDataSet(mainData.data);
                this._detailsGeo = mainData.geo;
                this.setViewMode("details", true);
            }
            finally {
                this.detailsLoading.set();
            }
        }
    }
    /****************************************/
    updateTopAreas() {
        this._daysData = [];
        this._calculator.data.days.foreach((day, i) => {
            const item = {};
            const isInArea = ViewModes[this.viewMode()].validateId;
            item.topAreas = (0,Linq/* linq */.k)(day.values).select(a => ({
                factor: this.getFactorValue(i, a.key),
                value: a
            })).where(a => !isNaNOrNull(a.factor))
                .orderByDesc(a => a.factor).where(a => isInArea(a.value.key)).select(a => {
                const area = new AreaViewModel();
                area.value = this._calculator.geo.areas[a.value.key.toLowerCase()];
                area.select = () => this.selectedArea = area.value;
                this.updateArea(area, i);
                return area;
            }).take(25).toArray();
            this._daysData.push(item);
        });
        this.topAreas(this._daysData[this.dayNumber()].topAreas);
    }
    /****************************************/
    updateDayData() {
        const day = this._calculator.data.get(this.dayNumber());
        if (!day) {
            console.warn("No day data: " + this.dayNumber());
            return;
        }
        this.currentData(formatDate(day.date, $string("$(date-format)")));
        this.updateMap();
        this.updateArea(this.currentArea());
        this.updateAreaIndicators();
        if (this._daysData && this._topAreasVisible)
            this.topAreas(this._daysData[this.dayNumber()].topAreas);
        this.updateUrl();
    }
    /****************************************/
    updateUrl() {
        if (!this._keepState)
            return;
        const state = this.saveStata();
        let url = Global/* App.baseUrl */.gV.baseUrl + "Overview";
        if (!this.isDefaultState(state))
            url += "?state=" + encodeURIComponent(btoa(JSON.stringify(state))) + "&keepState=true";
        history.replaceState(null, null, url);
    }
    /****************************************/
    clearMap() {
        const day = this._calculator.data.get(this.dayNumber());
        if (!day || !day.values) {
            console.warn("No day data: " + this.dayNumber());
            return;
        }
        for (const key in day.values) {
            const element = document.getElementById(key.toUpperCase());
            if (element) {
                //element.style.fillOpacity = "1";
                element.style.removeProperty("fill");
            }
        }
    }
    /****************************************/
    updateMap() {
        if (!this.selectedIndicator() || !this.selectedFactor())
            return;
        if (this.viewMode() != "country") {
            const day = this._calculator.data.get(this.dayNumber());
            var indicator = this.selectedIndicator();
            const gradient = indicator.gradient ? indicator.gradient : new LinearGradient("#fff", indicator.colorDark);
            for (const key in day.values) {
                const element = document.getElementById(key.toUpperCase());
                if (element) {
                    const area = this._calculator.geo.areas[key];
                    if (area.type != ViewModes[this.viewMode()].areaType)
                        continue;
                    let factor = this.getFactorValue(parseInt(this.dayNumber()), area);
                    if (factor == Number.POSITIVE_INFINITY)
                        factor = NaN;
                    if (indicator.canBeNegative)
                        factor = 0.5 + ((factor - this.baseFactor()) / (this.maxFactor() * 2));
                    else
                        factor = (factor - this.baseFactor()) / this.maxFactor();
                    factor = Math.min(1, Math.max(0, factor));
                    if (isNaNOrNull(factor)) {
                        if (element.classList.contains("valid"))
                            element.classList.remove("valid");
                        element.style.removeProperty("fill");
                    }
                    else {
                        if (!element.classList.contains("valid"))
                            element.classList.add("valid");
                        let value;
                        if (!indicator.canBeNegative)
                            value = discretize(exponential(factor), 20);
                        else
                            value = discretize(factor, 20);
                        element.style.fill = gradient.valueAt(value).toString();
                    }
                }
            }
        }
        else if (this.viewMode() != "details") {
            (0,Linq/* linq */.k)(document.querySelectorAll(".main-map g.region")).foreach((element) => {
                if (this._execludedArea.has(element.id))
                    element.style.fill = "#444";
                else
                    element.style.fill = "#FFF";
            });
        }
    }
    get dataRanges() {
        return this._dataRanges;
    }
    /****************************************/
    dayNumber = ko.observable(0);
    totalDays = ko.observable(0);
    detailsLoading = new Signal_Signal(true);
    detailsArea = ko.observable();
    currentData = ko.observable();
    currentArea = ko.observable();
    topAreas = ko.observable();
    viewMode = ko.observable("district");
    selectedIndicator = ko.observable();
    selectedFactor = ko.observable();
    autoMaxFactor = ko.observable(true);
    maxFactor = ko.observable();
    baseFactor = ko.observable(0);
    isPlaying = ko.observable(false);
    isLogScale = ko.observable(false);
    isDayDelta = ko.observable(false);
    isAvg = ko.observable(false);
    isZoomChart = ko.observable(false);
    isShowEnvData = ko.observable(false);
    groupSize = ko.observable(1);
    startDay = ko.observable(0);
    dataRange = ko.observable();
    days = ko.observable();
    tipManager;
    isNoFactorSelected = ko.computed(() => this.selectedFactor() && this.selectedFactor().id == 'none');
    groupDays = [1, 2, 3, 4, 5, 6, 7];
    factorDescription = ko.observable();
    indicators;
    factors;
}

;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Global.js
if (!HTMLCanvasElement.prototype.toBlob) {
    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
        value: function (callback, type, quality) {
            let canvas = this;
            setTimeout(() => {
                const binStr = atob(canvas.toDataURL(type, quality).split(',')[1]);
                const len = binStr.length;
                const arr = new Uint8Array(len);
                for (let i = 0; i < len; i++)
                    arr[i] = binStr.charCodeAt(i);
                callback(new Blob([arr], { type: type || 'image/png' }));
            });
        }
    });
}
/****************************************/
function capitalizeFirst(value) {
    return value.substr(0, 1).toUpperCase() + value.substr(1);
}
/****************************************/
function expandCollapse(elment) {
    let container = elment.parentElement;
    let content = container.querySelector(".section-content");
    if (container.classList.contains("closed")) {
        content.style.removeProperty("display");
        container.classList.remove("closed");
    }
    else {
        container.classList.add("closed");
        setTimeout(() => content.style.display = "none", 300);
    }
}

// EXTERNAL MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/Framework/Bindings.js
var Bindings = __webpack_require__(8280);
;// CONCATENATED MODULE: ./obj/js/GeoPlot/GeoPlot.Web/Scripts/index.js









})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=app.map